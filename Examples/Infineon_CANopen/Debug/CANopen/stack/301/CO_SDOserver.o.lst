   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "CO_SDOserver.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.CO_getUint8,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	CO_getUint8:
  25              	.LFB0:
  26              	 .file 1 "D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301/CO_driver.h"
   1:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
   2:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Interface between CAN hardware and CANopenNode.
   3:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
   4:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @file        CO_driver.h
   5:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @ingroup     CO_driver
   6:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @author      Janez Paternoster
   7:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @copyright   2004 - 2020 Janez Paternoster
   8:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
   9:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * This file is part of CANopenNode, an opensource CANopen Stack.
  10:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Project home page is <https://github.com/CANopenNode/CANopenNode>.
  11:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * For more information on CANopen see <http://www.can-cia.org/>.
  12:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  13:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Licensed under the Apache License, Version 2.0 (the "License");
  14:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * you may not use this file except in compliance with the License.
  15:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * You may obtain a copy of the License at
  16:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  17:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *     http://www.apache.org/licenses/LICENSE-2.0
  18:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  19:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Unless required by applicable law or agreed to in writing, software
  20:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * distributed under the License is distributed on an "AS IS" BASIS,
  21:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  22:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * See the License for the specific language governing permissions and
  23:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * limitations under the License.
  24:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
  25:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  26:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_DRIVER_H
  27:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_DRIVER_H
  28:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  29:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #include <string.h>
  30:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  31:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #include "CO_config.h"
  32:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #include "CO_driver_target.h"
  33:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  34:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifdef __cplusplus
  35:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** extern "C" {
  36:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  37:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  38:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /* Stack configuration default global values.
  39:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * For more information see file CO_config.h. */
  40:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_CONFIG_GLOBAL_FLAG_CALLBACK_PRE
  41:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #define CO_CONFIG_GLOBAL_FLAG_CALLBACK_PRE (0)
  42:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  43:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_CONFIG_GLOBAL_RT_FLAG_CALLBACK_PRE
  44:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #define CO_CONFIG_GLOBAL_RT_FLAG_CALLBACK_PRE (0)
  45:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  46:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_CONFIG_GLOBAL_FLAG_TIMERNEXT
  47:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #define CO_CONFIG_GLOBAL_FLAG_TIMERNEXT (0)
  48:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  49:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_CONFIG_GLOBAL_FLAG_OD_DYNAMIC
  50:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #define CO_CONFIG_GLOBAL_FLAG_OD_DYNAMIC CO_CONFIG_FLAG_OD_DYNAMIC
  51:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  52:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifdef CO_DEBUG_COMMON
  53:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #if (CO_CONFIG_DEBUG) & CO_CONFIG_DEBUG_SDO_CLIENT
  54:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****   #define CO_DEBUG_SDO_CLIENT(msg) CO_DEBUG_COMMON(msg)
  55:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #endif
  56:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #if (CO_CONFIG_DEBUG) & CO_CONFIG_DEBUG_SDO_SERVER
  57:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****   #define CO_DEBUG_SDO_SERVER(msg) CO_DEBUG_COMMON(msg)
  58:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #endif
  59:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  60:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  61:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
  62:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @defgroup CO_driver Driver
  63:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Interface between CAN hardware and CANopenNode.
  64:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  65:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @ingroup CO_CANopen_301
  66:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @{
  67:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANopenNode is designed for speed and portability. It runs efficiently on
  68:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * devices from simple 16-bit microcontrollers to PC computers. It can run in
  69:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * multiple threads. Reception of CAN messages is pre-processed with very fast
  70:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * functions. Time critical objects, such as PDO or SYNC are processed in
  71:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * real-time thread and other objects are processed in normal thread. See
  72:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Flowchart in [README.md](index.html) for more information.
  73:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  74:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @anchor CO_obj
  75:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * #### CANopenNode Object
  76:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANopenNode is implemented as a collection of different objects, for example
  77:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * SDO, SYNC, Emergency, PDO, NMT, Heartbeat, etc. Code is written in C language
  78:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * and tries to be object oriented. So each CANopenNode Object is implemented in
  79:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * a pair of .h/.c files. It basically contains a structure with all necessary
  80:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * variables and some functions which operates on it. CANopenNode Object is
  81:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * usually connected with one or more CAN receive or transmit Message Objects.
  82:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * (CAN message Object is a CAN message with specific 11-bit CAN identifier
  83:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * (usually one fixed or a range).)
  84:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  85:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * #### Hardware interface of CANopenNode
  86:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * It consists of minimum three files:
  87:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - **CO_driver.h** file declares common functions. This file is part of the
  88:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANopenNode. It is included from each .c file from CANopenNode.
  89:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - **CO_driver_target.h** file declares microcontroller specific type
  90:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * declarations and defines some macros, which are necessary for CANopenNode.
  91:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * This file is included from CO_driver.h.
  92:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - **CO_driver.c** file defines functions declared in CO_driver.h.
  93:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  94:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * **CO_driver_target.h** and **CO_driver.c** files are specific for each
  95:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * different microcontroller and are not part of CANopenNode. There are separate
  96:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * projects for different microcontrollers, which usually include CANopenNode as
  97:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * a git submodule. CANopenNode only includes those two files in the `example`
  98:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * directory and they are basically empty. It should be possible to compile the
  99:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * `CANopenNode/example` on any system, however compiled program is not usable.
 100:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CO_driver.h contains documentation for all necessary macros, types and
 101:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * functions.
 102:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 103:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * See [CANopenNode/Wiki](https://github.com/CANopenNode/CANopenNode/wiki) for a
 104:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * known list of available implementations of CANopenNode on different systems
 105:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * and microcontrollers. Everybody is welcome to extend the list with a link to
 106:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * his own implementation.
 107:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 108:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Implementation of the hardware interface for specific microcontroller is not
 109:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * always an easy task. For reliable and efficient operation it is necessary to
 110:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * know some parts of the target microcontroller in detail (for example threads
 111:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * (or interrupts), CAN module, etc.).
 112:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 113:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 114:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Major version number of CANopenNode */
 115:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_VERSION_MAJOR 4
 116:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Minor version number of CANopenNode */
 117:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_VERSION_MINOR 0
 118:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 119:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 120:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /* Macros and declarations in following part are only used for documentation. */
 121:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifdef CO_DOXYGEN
 122:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 123:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @defgroup CO_dataTypes Basic definitions
 124:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @{
 125:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 126:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Target specific basic definitions and data types.
 127:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 128:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 129:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 130:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Depending on processor or compiler architecture, one of the two macros must
 131:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * be defined: CO_LITTLE_ENDIAN or CO_BIG_ENDIAN. CANopen itself is little
 132:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * endian.
 133:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 134:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Basic data types may be specified differently on different architectures.
 135:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Usually `true` and `false` are defined in `<stdbool.h>`, `NULL` is defined in
 136:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * `<stddef.h>`, `int8_t` to `uint64_t` are defined in `<stdint.h>`.
 137:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 138:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** CO_LITTLE_ENDIAN or CO_BIG_ENDIAN must be defined */
 139:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_LITTLE_ENDIAN
 140:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Macro must swap bytes, if CO_BIG_ENDIAN is defined */
 141:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_SWAP_16(x) x
 142:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Macro must swap bytes, if CO_BIG_ENDIAN is defined */
 143:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_SWAP_32(x) x
 144:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Macro must swap bytes, if CO_BIG_ENDIAN is defined */
 145:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_SWAP_64(x) x
 146:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** NULL, for general usage */
 147:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define NULL (0)
 148:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Logical true, for general use */
 149:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define true 1
 150:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Logical false, for general use */
 151:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define false 0
 152:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Boolean data type for general use */
 153:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef uint_fast8_t bool_t;
 154:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** INTEGER8 in CANopen (0002h), 8-bit signed integer */
 155:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef signed char int8_t;
 156:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** INTEGER16 in CANopen (0003h), 16-bit signed integer */
 157:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef signed int int16_t;
 158:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** INTEGER32 in CANopen (0004h), 32-bit signed integer */
 159:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef signed long int int32_t;
 160:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** INTEGER64 in CANopen (0015h), 64-bit signed integer */
 161:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef signed long long int int64_t;
 162:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** UNSIGNED8 in CANopen (0005h), 8-bit unsigned integer */
 163:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef unsigned char uint8_t;
 164:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** UNSIGNED16 in CANopen (0006h), 16-bit unsigned integer */
 165:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef unsigned int uint16_t;
 166:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** UNSIGNED32 in CANopen (0007h), 32-bit unsigned integer */
 167:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef unsigned long int uint32_t;
 168:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** UNSIGNED64 in CANopen (001Bh), 64-bit unsigned integer */
 169:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef unsigned long long int uint64_t;
 170:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** REAL32 in CANopen (0008h), single precision floating point value, 32-bit */
 171:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef float float32_t;
 172:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** REAL64 in CANopen (0011h), double precision floating point value, 64-bit */
 173:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef double float64_t;
 174:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** @} */
 175:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 176:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 177:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 178:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @defgroup CO_CAN_Message_reception Reception of CAN messages
 179:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @{
 180:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 181:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Target specific definitions and description of CAN message reception
 182:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 183:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN messages in CANopenNode are usually received by its own thread or higher
 184:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * priority interrupt. Received CAN messages are first filtered by hardware or
 185:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * by software. Thread then examines its 11-bit CAN-id and mask and determines,
 186:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * to which \ref CO_obj "CANopenNode Object" it belongs to. After that it calls
 187:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * predefined CANrx_callback() function, which quickly pre-processes the message
 188:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * and fetches the relevant data. CANrx_callback() function is defined by each
 189:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * \ref CO_obj "CANopenNode Object" separately. Pre-processed fetched data are
 190:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * later processed in another thread.
 191:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 192:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * If \ref CO_obj "CANopenNode Object" reception of specific CAN message, it
 193:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * must first configure its own CO_CANrx_t object with the CO_CANrxBufferInit()
 194:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * function.
 195:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 196:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 197:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 198:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN receive callback function which pre-processes received CAN message
 199:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 200:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * It is called by fast CAN receive thread. Each \ref CO_obj "CANopenNode
 201:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Object" defines its own and registers it with CO_CANrxBufferInit(), by
 202:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * passing function pointer.
 203:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 204:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param object pointer to specific \ref CO_obj "CANopenNode Object",
 205:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * registered with CO_CANrxBufferInit()
 206:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxMsg pointer to received CAN message
 207:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 208:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CANrx_callback(void *object, void *rxMsg);
 209:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 210:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 211:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANrx_callback() can read CAN identifier from received CAN message
 212:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 213:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 214:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 215:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * This is target specific function and is specific for specific
 216:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * microcontroller. It is best to implement it by using inline function or
 217:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * macro. `rxMsg` parameter should cast to a pointer to structure. For best
 218:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * efficiency structure may have the same alignment as CAN registers inside CAN
 219:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * module.
 220:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 221:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxMsg Pointer to received message
 222:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return 11-bit CAN standard identifier.
 223:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 224:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint16_t CO_CANrxMsg_readIdent(void *rxMsg) {
 225:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return 0;
 226:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
 227:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 228:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 229:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANrx_callback() can read Data Length Code from received CAN message
 230:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 231:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * See also CO_CANrxMsg_readIdent():
 232:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 233:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxMsg Pointer to received message
 234:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return data length in bytes (0 to 8)
 235:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 236:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint8_t CO_CANrxMsg_readDLC(void *rxMsg) {
 237:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return 0;
 238:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
 239:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 240:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 241:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANrx_callback() can read pointer to data from received CAN message
 242:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 243:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * See also CO_CANrxMsg_readIdent():
 244:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 245:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxMsg Pointer to received message
 246:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return pointer to data buffer
 247:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 248:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint8_t *CO_CANrxMsg_readData(void *rxMsg) {
 249:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return NULL;
 250:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
 251:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 252:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 253:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Configuration object for CAN received message for specific \ref CO_obj
 254:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * "CANopenNode Object".
 255:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 256:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 257:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 258:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Data fields of this structure are used exclusively by the driver. Usually it
 259:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * has the following data fields, but they may differ for different
 260:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * microcontrollers. Array of multiple CO_CANrx_t objects is included inside
 261:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CO_CANmodule_t.
 262:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 263:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef struct {
 264:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t ident; /**< Standard CAN Identifier (bits 0..10) + RTR (bit 11) */
 265:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t mask;  /**< Standard CAN Identifier mask with the same alignment as
 266:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                        ident */
 267:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void *object;   /**< \ref CO_obj "CANopenNode Object" initialized in from
 268:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                        CO_CANrxBufferInit() */
 269:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void (*pCANrx_callback)(
 270:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         void *object, void *message); /**< Pointer to CANrx_callback()
 271:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          initialized in CO_CANrxBufferInit() */
 272:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_CANrx_t;
 273:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** @} */
 274:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 275:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 276:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 277:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @defgroup CO_CAN_Message_transmission Transmission of CAN messages
 278:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @{
 279:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 280:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Target specific definitions and description of CAN message transmission
 281:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 282:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * If \ref CO_obj "CANopenNode Object" needs transmitting CAN message, it must
 283:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * first configure its own CO_CANtx_t object with the CO_CANtxBufferInit()
 284:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * function. CAN message can then be sent with CO_CANsend() function. If at that
 285:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * moment CAN transmit buffer inside microcontroller's CAN module is free,
 286:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * message is copied directly to the CAN module. Otherwise CO_CANsend() function
 287:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * sets _bufferFull_ flag to true. Message will be then sent by CAN TX interrupt
 288:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * as soon as CAN module is freed. Until message is not copied to CAN module,
 289:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * its contents must not change. If there are multiple CO_CANtx_t objects with
 290:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * _bufferFull_ flag set to true, then CO_CANtx_t with lower index will be sent
 291:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * first.
 292:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 293:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 294:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 295:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Configuration object for CAN transmit message for specific \ref CO_obj
 296:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * "CANopenNode Object".
 297:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 298:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 299:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 300:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Data fields of this structure are used exclusively by the driver. Usually it
 301:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * has the following data fields, but they may differ for different
 302:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * microcontrollers. Array of multiple CO_CANtx_t objects is included inside
 303:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CO_CANmodule_t.
 304:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 305:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef struct {
 306:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint32_t ident;             /**< CAN identifier as aligned in CAN module */
 307:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t DLC;                /**< Length of CAN message */
 308:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t data[8];            /**< 8 data bytes */
 309:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t bufferFull; /**< True if previous message is still in the
 310:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                      buffer */
 311:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t syncFlag;   /**< Synchronous PDO messages has this flag set.
 312:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                   It prevents them to be sent outside the synchronous window */
 313:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_CANtx_t;
 314:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** @} */
 315:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 316:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 317:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 318:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Complete CAN module object.
 319:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 320:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 321:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 322:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Usually it has the following data fields, but they may differ for different
 323:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * microcontrollers.
 324:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 325:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef struct {
 326:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void *CANptr;                      /**< From CO_CANmodule_init() */
 327:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CANrx_t *rxArray;               /**< From CO_CANmodule_init() */
 328:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t rxSize;                   /**< From CO_CANmodule_init() */
 329:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CANtx_t *txArray;               /**< From CO_CANmodule_init() */
 330:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t txSize;                   /**< From CO_CANmodule_init() */
 331:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t CANerrorStatus;           /**< CAN error status bitfield,
 332:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                             see @ref CO_CAN_ERR_status_t */
 333:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t CANnormal;         /**< CAN module is in normal mode */
 334:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t useCANrxFilters;   /**< Value different than zero indicates,
 335:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             that CAN module hardware filters are used for CAN reception. If
 336:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             there is not enough hardware filters, they won't be used. In this
 337:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             case will be *all* received CAN messages processed by software. */
 338:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t bufferInhibitFlag; /**< If flag is true, then message in
 339:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             transmit buffer is synchronous PDO message, which will be aborted,
 340:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             if CO_clearPendingSyncPDOs() function will be called by application.
 341:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             This may be necessary if Synchronous window time was expired. */
 342:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t firstCANtxMessage; /**< Equal to 1, when the first
 343:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             transmitted message (bootup message) is in CAN TX buffers */
 344:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile uint16_t CANtxCount;      /**< Number of messages in transmit
 345:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             buffer, which are waiting to be copied to the CAN module */
 346:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint32_t errOld;                   /**< Previous state of CAN errors */
 347:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_CANmodule_t;
 348:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 349:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 350:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 351:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Data storage object for one entry.
 352:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 353:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 354:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 355:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * For more information on Data storage see @ref CO_storage or **CO_storage.h**
 356:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * file. Structure members documented here are always required or required with
 357:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @ref CO_storage_eeprom. Target system may add own additional, hardware
 358:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * specific variables.
 359:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 360:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef struct {
 361:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Address of data to store, always required. */
 362:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void *addr;
 363:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Length of data to store, always required. */
 364:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     size_t len;
 365:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Sub index in OD objects 1010 and 1011, from 2 to 127. Writing
 366:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * 0x65766173 to 1010,subIndexOD will store data to non-volatile memory.
 367:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * Writing 0x64616F6C to 1011,subIndexOD will restore default data, always
 368:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * required. */
 369:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t subIndexOD;
 370:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Attribute from @ref CO_storage_attributes_t, always required. */
 371:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t attr;
 372:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Pointer to storage module, target system specific usage, required with
 373:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * @ref CO_storage_eeprom. */
 374:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void *storageModule;
 375:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** CRC checksum of the data stored in eeprom, set on store, required with
 376:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * @ref CO_storage_eeprom. */
 377:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t crc;
 378:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Address of entry signature inside eeprom, set by init, required with
 379:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * @ref CO_storage_eeprom. */
 380:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     size_t eepromAddrSignature;
 381:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Address of data inside eeprom, set by init, required with
 382:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * @ref CO_storage_eeprom. */
 383:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     size_t eepromAddr;
 384:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Offset of next byte being updated by automatic storage, required with
 385:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * @ref CO_storage_eeprom. */
 386:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     size_t offset;
 387:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Additional target specific parameters, optional. */
 388:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void *additionalParameters;
 389:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_storage_entry_t;
 390:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 391:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 392:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 393:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @defgroup CO_critical_sections Critical sections
 394:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @{
 395:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 396:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Protection of critical sections in multi-threaded operation.
 397:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 398:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANopenNode is designed to run in different threads, as described in
 399:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * [README.md](index.html). Threads are implemented differently in different
 400:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * systems. In microcontrollers threads are interrupts with different
 401:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * priorities, for example. It is necessary to protect sections, where different
 402:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * threads access to the same resource. In simple systems interrupts or
 403:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * scheduler may be temporary disabled between access to the shared resource.
 404:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Otherwise mutexes or semaphores can be used.
 405:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 406:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * #### Reentrant functions
 407:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Functions CO_CANsend() from C_driver.h, and CO_error() from CO_Emergency.h
 408:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * may be called from different threads. Critical sections must be protected.
 409:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Either by disabling scheduler or interrupts or by mutexes or semaphores.
 410:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Lock/unlock macro is called with pointer to CAN module, which may be used
 411:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * inside.
 412:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 413:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * #### Object Dictionary variables
 414:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * In general, there are two threads, which accesses OD variables: mainline
 415:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * (initialization, storage, SDO access) and timer (PDO access). CANopenNode
 416:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * uses locking mechanism, where SDO server (or other mainline code) prevents
 417:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * execution of the real-time thread at the moment it reads or writes OD
 418:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * variable. CO_LOCK_OD(CAN_MODULE) and CO_UNLOCK_OD(CAN_MODULE) macros
 419:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * are used to protect:
 420:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - Whole real-time thread,
 421:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - SDO server protects read/write access to OD variable, if specific OD
 422:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   variable has ODA_TRPDO or ODA_TRSRDO from @ref OD_attributes_t set. If
 423:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   those attributes are not set, OD variable is not locked by SDO server.
 424:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   Locking of long OD variables, not accessible from real-time thread, may
 425:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   block RT thread.
 426:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - Any mainline code, which accesses PDO-mappable OD variable, must protect
 427:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   read/write with locking macros. Use @ref OD_mappable() for check.
 428:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - Other cases, where non-PDO-mappable OD variable is used inside real-time
 429:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   thread by some other part of the user application must be considered with
 430:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   special care.
 431:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 432:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * #### Synchronization functions for CAN receive
 433:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * After CAN message is received, it is pre-processed in CANrx_callback(), which
 434:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * copies some data into appropriate object and at the end sets **new_message**
 435:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * flag. This flag is then pooled in another thread, which further processes the
 436:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * message. The problem is, that compiler optimization may shuffle memory
 437:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * operations, so it is necessary to ensure, that **new_message** flag is surely
 438:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * set at the end. It is necessary to use [Memory
 439:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * barrier](https://en.wikipedia.org/wiki/Memory_barrier).
 440:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 441:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * If receive function runs inside IRQ, no further synchronization is needed.
 442:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Otherwise, some kind of synchronization has to be included. The following
 443:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * example uses GCC builtin memory barrier `__sync_synchronize()`. More
 444:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * information can be found
 445:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * [here](https://stackoverflow.com/questions/982129/what-does-sync-synchronize-do#982179).
 446:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 447:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 448:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Lock critical section in CO_CANsend() */
 449:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_LOCK_CAN_SEND(CAN_MODULE)
 450:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Unlock critical section in CO_CANsend() */
 451:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_UNLOCK_CAN_SEND(CAN_MODULE)
 452:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Lock critical section in CO_errorReport() or CO_errorReset() */
 453:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_LOCK_EMCY(CAN_MODULE)
 454:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Unlock critical section in CO_errorReport() or CO_errorReset() */
 455:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_UNLOCK_EMCY(CAN_MODULE)
 456:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Lock critical section when accessing Object Dictionary */
 457:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_LOCK_OD(CAN_MODULE)
 458:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Unock critical section when accessing Object Dictionary */
 459:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_UNLOCK_OD(CAN_MODULE)
 460:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 461:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Check if new message has arrived */
 462:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_FLAG_READ(rxNew) ((rxNew) != NULL)
 463:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Set new message flag */
 464:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_FLAG_SET(rxNew) { __sync_synchronize(); rxNew = (void *)1L; }
 465:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Clear new message flag */
 466:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_FLAG_CLEAR(rxNew) { __sync_synchronize(); rxNew = NULL; }
 467:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 468:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** @} */
 469:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif /* CO_DOXYGEN */
 470:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 471:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 472:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 473:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Default CANopen identifiers.
 474:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 475:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Default CANopen identifiers for CANopen communication objects. Same as
 476:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * 11-bit addresses of CAN messages. These are default identifiers and
 477:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * can be changed in CANopen. Especially PDO identifiers are configured
 478:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * in PDO linking phase of the CANopen network configuration.
 479:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 480:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef enum {
 481:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_NMT_SERVICE = 0x000, /**< 0x000, Network management */
 482:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_GFC = 0x001,         /**< 0x001, Global fail-safe command */
 483:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_SYNC = 0x080,        /**< 0x080, Synchronous message */
 484:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_EMERGENCY = 0x080,   /**< 0x080, Emergency messages (+nodeID) */
 485:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_TIME = 0x100,        /**< 0x100, Time message */
 486:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_SRDO_1 = 0x0FF,      /**< 0x0FF, Default SRDO1 (+2*nodeID) */
 487:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_TPDO_1 = 0x180,      /**< 0x180, Default TPDO1 (+nodeID) */
 488:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_RPDO_1 = 0x200,      /**< 0x200, Default RPDO1 (+nodeID) */
 489:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_TPDO_2 = 0x280,      /**< 0x280, Default TPDO2 (+nodeID) */
 490:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_RPDO_2 = 0x300,      /**< 0x300, Default RPDO2 (+nodeID) */
 491:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_TPDO_3 = 0x380,      /**< 0x380, Default TPDO3 (+nodeID) */
 492:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_RPDO_3 = 0x400,      /**< 0x400, Default RPDO3 (+nodeID) */
 493:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_TPDO_4 = 0x480,      /**< 0x480, Default TPDO4 (+nodeID) */
 494:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_RPDO_4 = 0x500,      /**< 0x500, Default RPDO5 (+nodeID) */
 495:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_SDO_SRV = 0x580, /**< 0x580, SDO response from server (+nodeID) */
 496:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_SDO_CLI = 0x600, /**< 0x600, SDO request from client (+nodeID) */
 497:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_HEARTBEAT = 0x700,   /**< 0x700, Heartbeat message */
 498:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_LSS_SLV = 0x7E4,     /**< 0x7E4, LSS response from slave */
 499:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_LSS_MST = 0x7E5      /**< 0x7E5, LSS request from master */
 500:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_Default_CAN_ID_t;
 501:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 502:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 503:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 504:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Restricted CAN-IDs
 505:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 506:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Macro for verifying 'Restricted CAN-IDs', as specified by standard CiA301.
 507:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * They shall not be used for SYNC, TIME, EMCY, PDO and SDO.
 508:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 509:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_IS_RESTRICTED_CAN_ID
 510:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_IS_RESTRICTED_CAN_ID(CAN_ID) ((CAN_ID) <= 0x7F \
 511:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         || ((CAN_ID) >= 0x101 && (CAN_ID) <= 0x180) \
 512:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         || ((CAN_ID) >= 0x581 && (CAN_ID) <= 0x5FF) \
 513:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         || ((CAN_ID) >= 0x601 && (CAN_ID) <= 0x67F) \
 514:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         || ((CAN_ID) >= 0x6E0 && (CAN_ID) <= 0x6FF) \
 515:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         || (CAN_ID) >= 0x701)
 516:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
 517:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 518:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 519:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 520:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN error status bitmasks.
 521:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 522:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN warning level is reached, if CAN transmit or receive error counter is
 523:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * more or equal to 96. CAN passive level is reached, if counters are more or
 524:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * equal to 128. Transmitter goes in error state 'bus off' if transmit error
 525:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * counter is more or equal to 256.
 526:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 527:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef enum {
 528:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRTX_WARNING = 0x0001,  /**< 0x0001, CAN transmitter warning */
 529:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRTX_PASSIVE = 0x0002,  /**< 0x0002, CAN transmitter passive */
 530:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRTX_BUS_OFF = 0x0004,  /**< 0x0004, CAN transmitter bus off */
 531:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRTX_OVERFLOW = 0x0008, /**< 0x0008, CAN transmitter overflow */
 532:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 533:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRTX_PDO_LATE = 0x0080, /**< 0x0080, TPDO is outside sync window */
 534:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 535:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRRX_WARNING = 0x0100,  /**< 0x0100, CAN receiver warning */
 536:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRRX_PASSIVE = 0x0200,  /**< 0x0200, CAN receiver passive */
 537:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRRX_OVERFLOW = 0x0800, /**< 0x0800, CAN receiver overflow */
 538:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 539:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERR_WARN_PASSIVE = 0x0303/**< 0x0303, combination */
 540:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_CAN_ERR_status_t;
 541:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 542:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 543:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 544:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Return values of some CANopen functions. If function was executed
 545:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * successfully it returns 0 otherwise it returns <0.
 546:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 547:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef enum {
 548:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_NO = 0,                /**< Operation completed successfully */
 549:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_ILLEGAL_ARGUMENT = -1, /**< Error in function arguments */
 550:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_OUT_OF_MEMORY = -2,    /**< Memory allocation failed */
 551:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_TIMEOUT = -3,          /**< Function timeout */
 552:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_ILLEGAL_BAUDRATE = -4, /**< Illegal baudrate passed to function
 553:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          CO_CANmodule_init() */
 554:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_RX_OVERFLOW = -5,      /**< Previous message was not processed
 555:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          yet */
 556:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_RX_PDO_OVERFLOW = -6,  /**< previous PDO was not processed yet */
 557:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_RX_MSG_LENGTH = -7,    /**< Wrong receive message length */
 558:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_RX_PDO_LENGTH = -8,    /**< Wrong receive PDO length */
 559:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_TX_OVERFLOW = -9,      /**< Previous message is still waiting,
 560:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          buffer full */
 561:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_TX_PDO_WINDOW = -10,   /**< Synchronous TPDO is outside window */
 562:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_TX_UNCONFIGURED = -11, /**< Transmit buffer was not configured
 563:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          properly */
 564:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_OD_PARAMETERS = -12,   /**< Error in Object Dictionary parameters*/
 565:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_DATA_CORRUPT = -13,    /**< Stored data are corrupt */
 566:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_CRC = -14,             /**< CRC does not match */
 567:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_TX_BUSY = -15,         /**< Sending rejected because driver is
 568:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          busy. Try again */
 569:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_WRONG_NMT_STATE = -16, /**< Command can't be processed in current
 570:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          state */
 571:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_SYSCALL = -17,         /**< Syscall failed */
 572:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_INVALID_STATE = -18,   /**< Driver not ready */
 573:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_NODE_ID_UNCONFIGURED_LSS = -19 /**< Node-id is in LSS unconfigured
 574:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          state. If objects are handled properly,
 575:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          this may not be an error. */
 576:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_ReturnError_t;
 577:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 578:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 579:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 580:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Request CAN configuration (stopped) mode and *wait* until it is set.
 581:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 582:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANptr Pointer to CAN device
 583:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 584:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CO_CANsetConfigurationMode(void *CANptr);
 585:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 586:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 587:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 588:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Request CAN normal (operational) mode and *wait* until it is set.
 589:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 590:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule CO_CANmodule_t object.
 591:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 592:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CO_CANsetNormalMode(CO_CANmodule_t *CANmodule);
 593:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 594:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 595:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 596:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Initialize CAN module object.
 597:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 598:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Function must be called in the communication reset section. CAN module must
 599:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * be in Configuration Mode before.
 600:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 601:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object will be initialized.
 602:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANptr Pointer to CAN device.
 603:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxArray Array for handling received CAN messages
 604:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxSize Size of the above array. Must be equal to number of receiving
 605:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN objects.
 606:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param txArray Array for handling transmitting CAN messages
 607:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param txSize Size of the above array. Must be equal to number of
 608:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * transmitting CAN objects.
 609:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANbitRate Valid values are (in kbps): 10, 20, 50, 125, 250, 500, 800,
 610:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * 1000. If value is illegal, bitrate defaults to 125.
 611:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 612:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Return #CO_ReturnError_t: CO_ERROR_NO or CO_ERROR_ILLEGAL_ARGUMENT.
 613:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 614:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** CO_ReturnError_t CO_CANmodule_init(CO_CANmodule_t *CANmodule,
 615:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    void *CANptr,
 616:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    CO_CANrx_t rxArray[],
 617:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    uint16_t rxSize,
 618:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    CO_CANtx_t txArray[],
 619:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    uint16_t txSize,
 620:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    uint16_t CANbitRate);
 621:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 622:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 623:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 624:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Switch off CANmodule. Call at program exit.
 625:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 626:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule CAN module object.
 627:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 628:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CO_CANmodule_disable(CO_CANmodule_t *CANmodule);
 629:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 630:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 631:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 632:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Configure CAN message receive buffer.
 633:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 634:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Function configures specific CAN receive buffer. It sets CAN identifier
 635:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * and connects buffer with specific object. Function must be called for each
 636:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * member in _rxArray_ from CO_CANmodule_t.
 637:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 638:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object.
 639:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param index Index of the specific buffer in _rxArray_.
 640:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param ident 11-bit standard CAN Identifier. If two or more CANrx buffers
 641:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * have the same _ident_, then buffer with lowest _index_ has precedence and
 642:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * other CANrx buffers will be ignored.
 643:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param mask 11-bit mask for identifier. Most usually set to 0x7FF.
 644:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Received message (rcvMsg) will be accepted if the following
 645:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * condition is true: (((rcvMsgId ^ ident) & mask) == 0).
 646:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rtr If true, 'Remote Transmit Request' messages will be accepted.
 647:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param object CANopen object, to which buffer is connected. It will be used
 648:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * as an argument to CANrx_callback. Its type is (void), CANrx_callback will
 649:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * change its type back to the correct object type.
 650:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANrx_callback Pointer to function, which will be called, if received
 651:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN message matches the identifier. It must be fast function.
 652:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 653:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Return #CO_ReturnError_t: CO_ERROR_NO CO_ERROR_ILLEGAL_ARGUMENT or
 654:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CO_ERROR_OUT_OF_MEMORY (not enough masks for configuration).
 655:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 656:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** CO_ReturnError_t CO_CANrxBufferInit(CO_CANmodule_t *CANmodule,
 657:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     uint16_t index,
 658:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     uint16_t ident,
 659:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     uint16_t mask,
 660:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     bool_t rtr,
 661:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     void *object,
 662:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     void (*CANrx_callback)(void *object,
 663:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                                            void *message));
 664:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 665:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 666:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 667:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Configure CAN message transmit buffer.
 668:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 669:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Function configures specific CAN transmit buffer. Function must be called for
 670:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * each member in _txArray_ from CO_CANmodule_t.
 671:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 672:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object.
 673:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param index Index of the specific buffer in _txArray_.
 674:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param ident 11-bit standard CAN Identifier.
 675:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rtr If true, 'Remote Transmit Request' messages will be transmitted.
 676:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param noOfBytes Length of CAN message in bytes (0 to 8 bytes).
 677:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param syncFlag This flag bit is used for synchronous TPDO messages. If it is
 678:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * set, message will not be sent, if current time is outside synchronous window.
 679:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 680:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return Pointer to CAN transmit message buffer. 8 bytes data array inside
 681:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * buffer should be written, before CO_CANsend() function is called.
 682:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Zero is returned in case of wrong arguments.
 683:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 684:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** CO_CANtx_t *CO_CANtxBufferInit(CO_CANmodule_t *CANmodule,
 685:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                uint16_t index,
 686:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                uint16_t ident,
 687:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                bool_t rtr,
 688:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                uint8_t noOfBytes,
 689:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                bool_t syncFlag);
 690:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 691:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 692:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 693:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Send CAN message.
 694:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 695:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object.
 696:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param buffer Pointer to transmit buffer, returned by CO_CANtxBufferInit().
 697:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Data bytes must be written in buffer before function call.
 698:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 699:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return #CO_ReturnError_t: CO_ERROR_NO, CO_ERROR_TX_OVERFLOW or
 700:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CO_ERROR_TX_PDO_WINDOW (Synchronous TPDO is outside window).
 701:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 702:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** CO_ReturnError_t CO_CANsend(CO_CANmodule_t *CANmodule, CO_CANtx_t *buffer);
 703:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 704:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 705:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 706:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Clear all synchronous TPDOs from CAN module transmit buffers.
 707:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 708:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANopen allows synchronous PDO communication only inside time between SYNC
 709:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * message and SYNC Window. If time is outside this window, new synchronous PDOs
 710:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * must not be sent and all pending sync TPDOs, which may be on CAN TX buffers,
 711:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * may optionally be cleared.
 712:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 713:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * This function checks (and aborts transmission if necessary) CAN TX buffers
 714:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * when it is called. Function should be called by the stack in the moment,
 715:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * when SYNC time was just passed out of synchronous window.
 716:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 717:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object.
 718:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 719:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CO_CANclearPendingSyncPDOs(CO_CANmodule_t *CANmodule);
 720:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 721:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 722:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 723:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Process can module - verify CAN errors
 724:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 725:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Function must be called cyclically. It should calculate CANerrorStatus
 726:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * bitfield for CAN errors defined in @ref CO_CAN_ERR_status_t.
 727:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 728:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object.
 729:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 730:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CO_CANmodule_process(CO_CANmodule_t *CANmodule);
 731:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 732:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 733:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 734:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Get uint8_t value from memory buffer
 735:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 736:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param buf Memory buffer to get value from.
 737:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 738:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return Value
 739:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 740:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint8_t CO_getUint8(const void *buf) {
  27              	 .loc 1 740 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 85B0     	 sub sp,sp,#20
  37              	.LCFI1:
  38              	 .cfi_def_cfa_offset 24
  39 0004 00AF     	 add r7,sp,#0
  40              	.LCFI2:
  41              	 .cfi_def_cfa_register 7
  42 0006 7860     	 str r0,[r7,#4]
 741:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #if (C2000_PORT != 0)
 742:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t value = 0;
 743:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     value = (*((uint8_t *)buf) & 0x00FF);
 744:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return value;
 745:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #else
 746:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t value; memmove(&value, buf, sizeof(value)); return value;
  43              	 .loc 1 746 0
  44 0008 7B68     	 ldr r3,[r7,#4]
  45 000a 1B78     	 ldrb r3,[r3]
  46 000c FB73     	 strb r3,[r7,#15]
  47 000e FB7B     	 ldrb r3,[r7,#15]
 747:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
 748:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
  48              	 .loc 1 748 0
  49 0010 1846     	 mov r0,r3
  50 0012 1437     	 adds r7,r7,#20
  51              	.LCFI3:
  52              	 .cfi_def_cfa_offset 4
  53 0014 BD46     	 mov sp,r7
  54              	.LCFI4:
  55              	 .cfi_def_cfa_register 13
  56              	 
  57 0016 5DF8047B 	 ldr r7,[sp],#4
  58              	.LCFI5:
  59              	 .cfi_restore 7
  60              	 .cfi_def_cfa_offset 0
  61 001a 7047     	 bx lr
  62              	 .cfi_endproc
  63              	.LFE0:
  65              	 .section .text.CO_getUint32,"ax",%progbits
  66              	 .align 2
  67              	 .thumb
  68              	 .thumb_func
  70              	CO_getUint32:
  71              	.LFB2:
 749:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Get uint16_t value from memory buffer, see @ref CO_getUint8 */
 750:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint16_t CO_getUint16(const void *buf) {
 751:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #if (C2000_PORT != 0)
 752:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t value = 0;
 753:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t * pBuf8 = (uint8_t *)buf;
 754:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     for (int i = 0; i < 2; i++) {
 755:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         value += ((uint16_t)(pBuf8[i])) << (8 * i);
 756:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     }
 757:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return value;
 758:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #else
 759:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t value; memmove(&value, buf, sizeof(value)); return value;
 760:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
 761:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
 762:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Get uint32_t value from memory buffer, see @ref CO_getUint8 */
 763:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint32_t CO_getUint32(const void *buf) {
  72              	 .loc 1 763 0
  73              	 .cfi_startproc
  74              	 
  75              	 
  76 0000 80B5     	 push {r7,lr}
  77              	.LCFI6:
  78              	 .cfi_def_cfa_offset 8
  79              	 .cfi_offset 7,-8
  80              	 .cfi_offset 14,-4
  81 0002 84B0     	 sub sp,sp,#16
  82              	.LCFI7:
  83              	 .cfi_def_cfa_offset 24
  84 0004 00AF     	 add r7,sp,#0
  85              	.LCFI8:
  86              	 .cfi_def_cfa_register 7
  87 0006 7860     	 str r0,[r7,#4]
 764:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #if (C2000_PORT != 0)
 765:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint32_t value = 0;
 766:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t * pBuf8 = (uint8_t *)buf;
 767:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     for(int i = 0; i < 4; i++) {
 768:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         value += ((uint32_t)(pBuf8[i])) << (8 * i);
 769:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     }
 770:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return value;
 771:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #else
 772:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint32_t value; memmove(&value, buf, sizeof(value)); return value;
  88              	 .loc 1 772 0
  89 0008 07F10C03 	 add r3,r7,#12
  90 000c 1846     	 mov r0,r3
  91 000e 7968     	 ldr r1,[r7,#4]
  92 0010 0422     	 movs r2,#4
  93 0012 FFF7FEFF 	 bl memmove
  94 0016 FB68     	 ldr r3,[r7,#12]
 773:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
 774:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
  95              	 .loc 1 774 0
  96 0018 1846     	 mov r0,r3
  97 001a 1037     	 adds r7,r7,#16
  98              	.LCFI9:
  99              	 .cfi_def_cfa_offset 8
 100 001c BD46     	 mov sp,r7
 101              	.LCFI10:
 102              	 .cfi_def_cfa_register 13
 103              	 
 104 001e 80BD     	 pop {r7,pc}
 105              	 .cfi_endproc
 106              	.LFE2:
 108              	 .section .text.OD_getIndex,"ax",%progbits
 109              	 .align 2
 110              	 .thumb
 111              	 .thumb_func
 113              	OD_getIndex:
 114              	.LFB6:
 115              	 .file 2 "D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301/CO_ODinterface.h"
   1:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
   2:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * CANopen Object Dictionary interface
   3:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
   4:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @file        CO_ODinterface.h
   5:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ingroup     CO_ODinterface
   6:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @author      Janez Paternoster
   7:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @copyright   2020 Janez Paternoster
   8:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
   9:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * This file is part of CANopenNode, an opensource CANopen Stack.
  10:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Project home page is <https://github.com/CANopenNode/CANopenNode>.
  11:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * For more information on CANopen see <http://www.can-cia.org/>.
  12:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
  13:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Licensed under the Apache License, Version 2.0 (the "License");
  14:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * you may not use this file except in compliance with the License.
  15:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * You may obtain a copy of the License at
  16:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
  17:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *     http://www.apache.org/licenses/LICENSE-2.0
  18:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
  19:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Unless required by applicable law or agreed to in writing, software
  20:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * distributed under the License is distributed on an "AS IS" BASIS,
  21:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  22:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * See the License for the specific language governing permissions and
  23:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * limitations under the License.
  24:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
  25:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  26:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #ifndef CO_OD_INTERFACE_H
  27:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #define CO_OD_INTERFACE_H
  28:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  29:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #include "301/CO_driver.h"
  30:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  31:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #ifdef __cplusplus
  32:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** extern "C" {
  33:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
  34:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  35:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
  36:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @defgroup CO_ODinterface OD interface
  37:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * CANopen Object Dictionary interface.
  38:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
  39:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ingroup CO_CANopen_301
  40:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @{
  41:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * See @ref doc/objectDictionary.md
  42:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
  43:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  44:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #ifndef CO_OD_OWN_TYPES
  45:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Variable of type OD_size_t contains data length in bytes of OD variable */
  46:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef uint32_t OD_size_t;
  47:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Type (and size) of Object Dictionary attribute */
  48:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef uint8_t OD_attr_t;
  49:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
  50:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  51:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #ifndef OD_FLAGS_PDO_SIZE
  52:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Size of of flagsPDO variable inside @ref OD_extension_t, from 0 to 32. */
  53:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #define OD_FLAGS_PDO_SIZE 4
  54:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
  55:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  56:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #ifndef CO_PROGMEM
  57:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Modifier for OD objects. This is large amount of data and is specified in
  58:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Object Dictionary (OD.c file usually) */
  59:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #define CO_PROGMEM const
  60:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
  61:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  62:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  63:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
  64:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Common DS301 object dictionary entries.
  65:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
  66:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef enum {
  67:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1000_DEV_TYPE           = 0x1000U,/**< Device type */
  68:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1001_ERR_REG            = 0x1001U,/**< Error register */
  69:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1002_MANUF_STATUS_REG   = 0x1002U,/**< Manufacturer status register */
  70:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1003_PREDEF_ERR_FIELD   = 0x1003U,/**< Predefined error field */
  71:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1004_RSV                = 0x1004U,/**< Reserved */
  72:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1005_COBID_SYNC         = 0x1005U,/**< Sync message cob-id */
  73:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1006_COMM_CYCL_PERIOD   = 0x1006U,/**< Communication cycle period */
  74:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1007_SYNC_WINDOW_LEN    = 0x1007U,/**< Sync windows length */
  75:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1008_MANUF_DEV_NAME     = 0x1008U,/**< Manufacturer device name */
  76:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1009_MANUF_HW_VERSION   = 0x1009U,/**< Manufacturer hardware version */
  77:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100A_MANUF_SW_VERSION   = 0x100AU,/**< Manufacturer software version */
  78:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100B_RSV                = 0x100BU,/**< Reserved */
  79:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100C_GUARD_TIME         = 0x100CU,/**< Guard time */
  80:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100D_LIFETIME_FACTOR    = 0x100DU,/**< Life time factor */
  81:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100E_RSV                = 0x100EU,/**< Reserved */
  82:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100F_RSV                = 0x100FU,/**< Reserved */
  83:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1010_STORE_PARAMETERS   = 0x1010U,/**< Store params in persistent mem.*/
  84:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1011_RESTORE_DEFAULT    = 0x1011U,/**< Restore default parameters */
  85:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1012_COBID_TIME         = 0x1012U,/**< Timestamp message cob-id */
  86:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1013_HIGH_RES_TIMESTAMP = 0x1013U,/**< High resolution timestamp */
  87:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1014_COBID_EMERGENCY    = 0x1014U,/**< Emergency message cob-id */
  88:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1015_INHIBIT_TIME_EMCY  = 0x1015U,/**< Inhibit time emergency message */
  89:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1016_CONSUMER_HB_TIME   = 0x1016U,/**< Consumer heartbeat time */
  90:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1017_PRODUCER_HB_TIME   = 0x1017U,/**< Producer heartbeat time */
  91:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1018_IDENTITY_OBJECT    = 0x1018U,/**< Identity object */
  92:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1019_SYNC_CNT_OVERFLOW  = 0x1019U,/**< Sync counter overflow value */
  93:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1020_VERIFY_CONFIG      = 0x1020U,/**< Verify configuration */
  94:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1021_STORE_EDS          = 0x1021U,/**< Store EDS */
  95:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1022_STORE_FORMAT       = 0x1022U,/**< Store format */
  96:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1023_OS_CMD             = 0x1023U,/**< OS command */
  97:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1024_OS_CMD_MODE        = 0x1024U,/**< OS command mode */
  98:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1025_OS_DBG_INTERFACE   = 0x1025U,/**< OS debug interface */
  99:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1026_OS_PROMPT          = 0x1026U,/**< OS prompt */
 100:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1027_MODULE_LIST        = 0x1027U,/**< Module list */
 101:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1028_EMCY_CONSUMER      = 0x1028U,/**< Emergency consumer object */
 102:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1029_ERR_BEHAVIOR       = 0x1029U,/**< Error behaviour */
 103:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1200_SDO_SERVER_1_PARAM = 0x1200U,/**< SDO server parameter */
 104:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1280_SDO_CLIENT_1_PARAM = 0x1280U,/**< SDO client parameter */
 105:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1300_GFC_PARAM          = 0x1300U,/**< Global fail-safe command param */
 106:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1301_SRDO_1_PARAM       = 0x1301U,/**< SRDO communication parameter */
 107:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1381_SRDO_1_MAPPING     = 0x1381U,/**< SRDO mapping parameter */
 108:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H13FE_SRDO_VALID         = 0x13FEU,/**< SRDO Configuration valid */
 109:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H13FF_SRDO_CHECKSUM      = 0x13FFU,/**< SRDO configuration checksum */
 110:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1400_RXPDO_1_PARAM      = 0x1400U,/**< RXPDO communication parameter */
 111:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1600_RXPDO_1_MAPPING    = 0x1600U,/**< RXPDO mapping parameters */
 112:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1800_TXPDO_1_PARAM      = 0x1800U,/**< TXPDO communication parameter */
 113:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1A00_TXPDO_1_MAPPING    = 0x1A00U,/**< TXPDO mapping parameters */
 114:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_ObjDicId_30x_t;
 115:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 116:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 117:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 118:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Attributes (bit masks) for OD sub-object.
 119:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 120:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef enum {
 121:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_SDO_R = 0x01, /**< SDO server may read from the variable */
 122:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_SDO_W = 0x02, /**< SDO server may write to the variable */
 123:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_SDO_RW = 0x03, /**< SDO server may read from or write to the variable */
 124:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_TPDO = 0x04, /**< Variable is mappable into TPDO (can be read) */
 125:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_RPDO = 0x08, /**< Variable is mappable into RPDO (can be written) */
 126:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_TRPDO = 0x0C, /**< Variable is mappable into TPDO or RPDO */
 127:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_TSRDO = 0x10, /**< Variable is mappable into transmitting SRDO */
 128:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_RSRDO = 0x20, /**< Variable is mappable into receiving SRDO */
 129:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_TRSRDO = 0x30, /**< Variable is mappable into tx or rx SRDO */
 130:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_MB = 0x40, /**< Variable is multi-byte ((u)int16_t to (u)int64_t) */
 131:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_STR = 0x80 /**< Shorter value, than specified variable size, may be
 132:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     written to the variable. SDO write will fill remaining memory with zeroes.
 133:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     Attribute is used for VISIBLE_STRING and UNICODE_STRING. */
 134:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_attributes_t;
 135:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 136:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 137:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 138:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Return codes from OD access functions.
 139:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 140:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_getSDOabCode() can be used to retrieve corresponding SDO abort code.
 141:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 142:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef enum {
 143:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /* !!!! WARNING !!!!
 144:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * If changing these values, change also OD_getSDOabCode() function!
 145:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 146:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Read/write is only partial, make more calls */
 147:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_PARTIAL = -1,
 148:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x00000000 - Read/write successfully finished */
 149:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_OK = 0,
 150:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x05040005 - Out of memory */
 151:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_OUT_OF_MEM = 1,
 152:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06010000 - Unsupported access to an object */
 153:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_UNSUPP_ACCESS = 2,
 154:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06010001 - Attempt to read a write only object */
 155:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_WRITEONLY = 3,
 156:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06010002 - Attempt to write a read only object */
 157:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_READONLY = 4,
 158:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06020000 - Object does not exist in the object dict. */
 159:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_IDX_NOT_EXIST = 5,
 160:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06040041 - Object cannot be mapped to the PDO */
 161:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_NO_MAP = 6,
 162:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06040042 - PDO length exceeded */
 163:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_MAP_LEN = 7,
 164:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06040043 - General parameter incompatibility reasons */
 165:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_PAR_INCOMPAT = 8,
 166:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06040047 - General internal incompatibility in device */
 167:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DEV_INCOMPAT = 9,
 168:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06060000 - Access failed due to hardware error */
 169:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_HW = 10,
 170:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06070010 - Data type does not match */
 171:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_TYPE_MISMATCH = 11,
 172:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06070012 - Data type does not match, length too high */
 173:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DATA_LONG = 12,
 174:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06070013 - Data type does not match, length too short */
 175:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DATA_SHORT = 13,
 176:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06090011 - Sub index does not exist */
 177:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_SUB_NOT_EXIST = 14,
 178:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06090030 - Invalid value for parameter (download only) */
 179:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_INVALID_VALUE = 15,
 180:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06090031 - Value range of parameter written too high */
 181:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_VALUE_HIGH = 16,
 182:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06090032 - Value range of parameter written too low */
 183:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_VALUE_LOW = 17,
 184:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06090036 - Maximum value is less than minimum value */
 185:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_MAX_LESS_MIN = 18,
 186:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x060A0023 - Resource not available: SDO connection */
 187:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_NO_RESOURCE = 19,
 188:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000000 - General error */
 189:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_GENERAL = 20,
 190:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000020 - Data cannot be transferred or stored to app */
 191:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DATA_TRANSF = 21,
 192:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000021 - Data can't be transferred (local control) */
 193:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DATA_LOC_CTRL = 22,
 194:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000022 - Data can't be transf. (present device state) */
 195:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DATA_DEV_STATE = 23,
 196:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000023 - Object dictionary not present */
 197:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_OD_MISSING = 23,
 198:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000024 - No data available */
 199:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_NO_DATA = 25,
 200:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Last element, number of responses */
 201:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_COUNT = 26
 202:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } ODR_t;
 203:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 204:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 205:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 206:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * IO stream structure, used for read/write access to OD variable, part of
 207:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_IO_t.
 208:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 209:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef struct {
 210:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Pointer to original data object, defined by Object Dictionary. Default
 211:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * read/write functions operate on it. If memory for data object is not
 212:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * specified by Object Dictionary, then dataOrig is NULL.
 213:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      */
 214:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     void *dataOrig;
 215:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Pointer to object, passed by @ref OD_extension_init(). Can be used
 216:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * inside read / write functions from IO extension.
 217:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      */
 218:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     void *object;
 219:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Data length in bytes or 0, if length is not specified */
 220:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_size_t dataLength;
 221:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** In case of large data, dataOffset indicates position of already
 222:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * transferred data */
 223:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_size_t dataOffset;
 224:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Attribute bit-field of the OD sub-object, see @ref OD_attributes_t */
 225:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_attr_t attribute;
 226:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Sub index of the OD sub-object, informative */
 227:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint8_t subIndex;
 228:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_stream_t;
 229:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 230:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 231:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 232:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Structure for input / output on the OD variable. It is initialized with
 233:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_getSub() function. Access principle to OD variable is via read/write
 234:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * functions operating on stream, similar as standard read/write.
 235:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 236:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef struct {
 237:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Object Dictionary stream object, passed to read or write */
 238:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_stream_t stream;
 239:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /**
 240:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Function pointer for reading value from specified variable from Object
 241:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Dictionary. If OD variable is larger than buf, then this function must
 242:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * be called several times. After completed successful read function returns
 243:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * 'ODR_OK'. If read is partial, it returns 'ODR_PARTIAL'. In case of errors
 244:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * function returns code similar to SDO abort code.
 245:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 246:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Read can be restarted with @ref OD_rwRestart() function.
 247:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 248:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * At the moment, when Object Dictionary is initialized, every variable has
 249:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * assigned the same "read" function. This default function simply copies
 250:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * data from Object Dictionary variable. Application can bind its own "read"
 251:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * function for specific object. In that case application is able to
 252:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * calculate data for reading from own internal state at the moment of
 253:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * "read" function call. Own "read" function on OD object can be initialized
 254:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * with @ref OD_extension_init() function.
 255:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 256:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * "read" function must always copy all own data to buf, except if "buf" is
 257:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * not large enough. ("*returnCode" must not return 'ODR_PARTIAL', if there
 258:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * is still space in "buf".)
 259:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 260:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @warning When accessing OD variables by calling the read() function, it
 261:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * may be necessary to use @ref CO_LOCK_OD() and @ref CO_UNLOCK_OD() macros.
 262:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * See @ref CO_critical_sections for more information.
 263:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 264:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param stream Object Dictionary stream object.
 265:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param buf Pointer to external buffer, where to data will be copied.
 266:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param count Size of the external buffer in bytes.
 267:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param [out] countRead If return value is "ODR_OK" or "ODR_PARTIAL",
 268:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * then number of bytes successfully read must be returned here.
 269:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 270:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @return Value from @ref ODR_t, "ODR_OK" in case of success.
 271:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      */
 272:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_t (*read)(OD_stream_t *stream, void *buf,
 273:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                   OD_size_t count, OD_size_t *countRead);
 274:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /**
 275:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Function pointer for writing value into specified variable inside Object
 276:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Dictionary. If OD variable is larger than buf, then this function must
 277:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * be called several times. After completed successful write function
 278:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * returns 'ODR_OK'. If write is partial, it returns 'ODR_PARTIAL'. In case
 279:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * of errors function returns code similar to SDO abort code.
 280:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 281:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Write can be restarted with @ref OD_rwRestart() function.
 282:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 283:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * At the moment, when Object Dictionary is initialized, every variable has
 284:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * assigned the same "write" function, which simply copies data to Object
 285:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Dictionary variable. Application can bind its own "write" function,
 286:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * similar as it can bind "read" function.
 287:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 288:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * "write" function must always copy all available data from buf. If OD
 289:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * variable expect more data, then "*returnCode" must return 'ODR_PARTIAL'.
 290:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 291:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @warning When accessing OD variables by calling the read() function, it
 292:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * may be necessary to use @ref CO_LOCK_OD() and @ref CO_UNLOCK_OD() macros.
 293:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * See @ref CO_critical_sections for more information.
 294:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 295:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param stream Object Dictionary stream object.
 296:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param buf Pointer to external buffer, from where data will be copied.
 297:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param count Size of the external buffer in bytes.
 298:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param [out] countWritten If return value is "ODR_OK" or "ODR_PARTIAL",
 299:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * then number of bytes successfully written must be returned here.
 300:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 301:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @return Value from @ref ODR_t, "ODR_OK" in case of success.
 302:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      */
 303:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_t (*write)(OD_stream_t *stream, const void *buf,
 304:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                    OD_size_t count, OD_size_t *countWritten);
 305:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_IO_t;
 306:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 307:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 308:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 309:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Extension of OD object, which can optionally be specified by application in
 310:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * initialization phase with @ref OD_extension_init() function.
 311:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 312:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef struct {
 313:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Object on which read and write will operate, part of @ref OD_stream_t */
 314:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     void *object;
 315:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Application specified read function pointer. If NULL, then read will be
 316:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * disabled. @ref OD_readOriginal can be used here to keep the original read
 317:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * function. For function description see @ref OD_IO_t. */
 318:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_t (*read)(OD_stream_t *stream, void *buf,
 319:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                   OD_size_t count, OD_size_t *countRead);
 320:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Application specified write function pointer. If NULL, then write will
 321:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * be disabled. @ref OD_writeOriginal can be used here to keep the original
 322:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * write function. For function description see @ref OD_IO_t. */
 323:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_t (*write)(OD_stream_t *stream, const void *buf,
 324:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                    OD_size_t count, OD_size_t *countWritten);
 325:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if OD_FLAGS_PDO_SIZE > 0
 326:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /**PDO flags bit-field provides one bit for each OD variable, which exist
 327:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * inside OD object at specific sub index. If application clears that bit,
 328:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * and OD variable is mapped to an event driven TPDO, then TPDO will be
 329:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * sent.
 330:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 331:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @ref OD_FLAGS_PDO_SIZE can have a value from 0 to 32 bytes, which
 332:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * corresponds to 0 to 256 available bits. If, for example,
 333:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @ref OD_FLAGS_PDO_SIZE has value 4, then OD variables with sub index up
 334:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * to 31 will have the TPDO requesting functionality.
 335:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * See also @ref OD_requestTPDO and @ref OD_TPDOtransmitted. */
 336:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint8_t flagsPDO[OD_FLAGS_PDO_SIZE];
 337:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 338:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_extension_t;
 339:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 340:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 341:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 342:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Object Dictionary entry for one OD object.
 343:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 344:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * OD entries are collected inside OD_t as array (list). Each OD entry contains
 345:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * basic information about OD object (index and subEntriesCount), pointer to
 346:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * odObject with additional information about var, array or record entry and
 347:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * pointer to extension, configurable by application.
 348:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 349:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef struct {
 350:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Object Dictionary index */
 351:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint16_t index;
 352:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Number of all sub-entries, including sub-entry at sub-index 0 */
 353:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint8_t subEntriesCount;
 354:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Type of the odObject, indicated by @ref OD_objectTypes_t enumerator. */
 355:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint8_t odObjectType;
 356:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** OD object of type indicated by odObjectType, from which @ref OD_getSub()
 357:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * fetches the information */
 358:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     CO_PROGMEM void *odObject;
 359:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Extension to OD, specified by application */
 360:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_extension_t *extension;
 361:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_entry_t;
 362:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 363:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 364:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 365:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Object Dictionary
 366:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 367:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef struct {
 368:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Number of elements in the list, without last element, which is blank */
 369:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint16_t size;
 370:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** List OD entries (table of contents), ordered by index */
 371:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_entry_t *list;
 372:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_t;
 373:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 374:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 375:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 376:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Read value from original OD location
 377:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 378:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * This function can be used inside read / write functions, specified by
 379:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_extension_init(). It reads data directly from memory location
 380:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * specified by Object dictionary. If no IO extension is used on OD entry, then
 381:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * io->read returned by @ref OD_getSub() equals to this function. See
 382:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * also @ref OD_IO_t.
 383:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 384:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** ODR_t OD_readOriginal(OD_stream_t *stream, void *buf,
 385:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                       OD_size_t count, OD_size_t *countRead);
 386:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 387:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 388:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 389:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Write value to original OD location
 390:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 391:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * This function can be used inside read / write functions, specified by
 392:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_extension_init(). It writes data directly to memory location
 393:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * specified by Object dictionary. If no IO extension is used on OD entry, then
 394:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * io->write returned by @ref OD_getSub() equals to this function. See
 395:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * also @ref OD_IO_t.
 396:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 397:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** ODR_t OD_writeOriginal(OD_stream_t *stream, const void *buf,
 398:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                        OD_size_t count, OD_size_t *countWritten);
 399:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 400:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 401:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 402:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Find OD entry in Object Dictionary
 403:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 404:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param od Object Dictionary
 405:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param index CANopen Object Dictionary index of object in Object Dictionary
 406:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 407:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return Pointer to OD entry or NULL if not found
 408:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 409:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** OD_entry_t *OD_find(OD_t *od, uint16_t index);
 410:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 411:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 412:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 413:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Find sub-object with specified sub-index on OD entry returned by OD_find.
 414:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Function populates io structure with sub-object data.
 415:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 416:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @warning
 417:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Read and write functions may be called from different threads, so critical
 418:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * sections in custom functions must be observed, see @ref CO_critical_sections.
 419:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 420:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param entry OD entry returned by @ref OD_find().
 421:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param subIndex Sub-index of the variable from the OD object.
 422:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param [out] io Structure will be populated on success.
 423:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param odOrig If true, then potential IO extension on entry will be
 424:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * ignored and access to data entry in the original OD location will be returned
 425:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 426:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return Value from @ref ODR_t, "ODR_OK" in case of success.
 427:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 428:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** ODR_t OD_getSub(const OD_entry_t *entry, uint8_t subIndex,
 429:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                 OD_IO_t *io, bool_t odOrig);
 430:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 431:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 432:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 433:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Return index from OD entry
 434:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 435:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param entry OD entry returned by @ref OD_find().
 436:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 437:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return OD index
 438:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 439:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline uint16_t OD_getIndex(const OD_entry_t *entry) {
 116              	 .loc 2 439 0
 117              	 .cfi_startproc
 118              	 
 119              	 
 120              	 
 121 0000 80B4     	 push {r7}
 122              	.LCFI11:
 123              	 .cfi_def_cfa_offset 4
 124              	 .cfi_offset 7,-4
 125 0002 83B0     	 sub sp,sp,#12
 126              	.LCFI12:
 127              	 .cfi_def_cfa_offset 16
 128 0004 00AF     	 add r7,sp,#0
 129              	.LCFI13:
 130              	 .cfi_def_cfa_register 7
 131 0006 7860     	 str r0,[r7,#4]
 440:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return (entry != NULL) ? entry->index : 0;
 132              	 .loc 2 440 0
 133 0008 7B68     	 ldr r3,[r7,#4]
 134 000a 002B     	 cmp r3,#0
 135 000c 02D0     	 beq .L6
 136              	 .loc 2 440 0 is_stmt 0 discriminator 1
 137 000e 7B68     	 ldr r3,[r7,#4]
 138 0010 1B88     	 ldrh r3,[r3]
 139 0012 00E0     	 b .L7
 140              	.L6:
 141              	 .loc 2 440 0 discriminator 2
 142 0014 0023     	 movs r3,#0
 143              	.L7:
 441:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 144              	 .loc 2 441 0 is_stmt 1 discriminator 4
 145 0016 1846     	 mov r0,r3
 146 0018 0C37     	 adds r7,r7,#12
 147              	.LCFI14:
 148              	 .cfi_def_cfa_offset 4
 149 001a BD46     	 mov sp,r7
 150              	.LCFI15:
 151              	 .cfi_def_cfa_register 13
 152              	 
 153 001c 5DF8047B 	 ldr r7,[sp],#4
 154              	.LCFI16:
 155              	 .cfi_restore 7
 156              	 .cfi_def_cfa_offset 0
 157 0020 7047     	 bx lr
 158              	 .cfi_endproc
 159              	.LFE6:
 161 0022 00BF     	 .section .text.OD_mappable,"ax",%progbits
 162              	 .align 2
 163              	 .thumb
 164              	 .thumb_func
 166              	OD_mappable:
 167              	.LFB7:
 442:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 443:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 444:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 445:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Check, if OD variable is mappable to PDO or SRDO.
 446:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 447:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * If OD variable is mappable, then it may be necessary to protect read/write
 448:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * access from mainline function. See @ref CO_critical_sections.
 449:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 450:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param stream Object Dictionary stream object.
 451:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 452:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return true, if OD variable is mappable.
 453:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 454:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline bool_t OD_mappable(OD_stream_t *stream) {
 168              	 .loc 2 454 0
 169              	 .cfi_startproc
 170              	 
 171              	 
 172              	 
 173 0000 80B4     	 push {r7}
 174              	.LCFI17:
 175              	 .cfi_def_cfa_offset 4
 176              	 .cfi_offset 7,-4
 177 0002 83B0     	 sub sp,sp,#12
 178              	.LCFI18:
 179              	 .cfi_def_cfa_offset 16
 180 0004 00AF     	 add r7,sp,#0
 181              	.LCFI19:
 182              	 .cfi_def_cfa_register 7
 183 0006 7860     	 str r0,[r7,#4]
 455:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return (stream != NULL)
 456:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****          ? (stream->attribute & (ODA_TRPDO | ODA_TRSRDO)) != 0 : false;
 184              	 .loc 2 456 0
 185 0008 7B68     	 ldr r3,[r7,#4]
 186 000a 002B     	 cmp r3,#0
 187 000c 07D0     	 beq .L10
 188              	 .loc 2 456 0 is_stmt 0 discriminator 1
 189 000e 7B68     	 ldr r3,[r7,#4]
 190 0010 1B7C     	 ldrb r3,[r3,#16]
 191 0012 03F03C03 	 and r3,r3,#60
 192 0016 002B     	 cmp r3,#0
 193 0018 01D0     	 beq .L10
 194              	 .loc 2 456 0 discriminator 3
 195 001a 0123     	 movs r3,#1
 196 001c 00E0     	 b .L11
 197              	.L10:
 198              	 .loc 2 456 0 discriminator 4
 199 001e 0023     	 movs r3,#0
 200              	.L11:
 457:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 201              	 .loc 2 457 0 is_stmt 1
 202 0020 1846     	 mov r0,r3
 203 0022 0C37     	 adds r7,r7,#12
 204              	.LCFI20:
 205              	 .cfi_def_cfa_offset 4
 206 0024 BD46     	 mov sp,r7
 207              	.LCFI21:
 208              	 .cfi_def_cfa_register 13
 209              	 
 210 0026 5DF8047B 	 ldr r7,[sp],#4
 211              	.LCFI22:
 212              	 .cfi_restore 7
 213              	 .cfi_def_cfa_offset 0
 214 002a 7047     	 bx lr
 215              	 .cfi_endproc
 216              	.LFE7:
 218              	 .section .text.OD_extension_init,"ax",%progbits
 219              	 .align 2
 220              	 .thumb
 221              	 .thumb_func
 223              	OD_extension_init:
 224              	.LFB12:
 458:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 459:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 460:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 461:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Restart read or write operation on OD variable
 462:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 463:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * It is not necessary to call this function, if stream was initialized by
 464:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_getSub(). It is also not necessary to call this function, if
 465:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * previous read or write was successfully finished.
 466:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 467:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param stream Object Dictionary stream object.
 468:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 469:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline void OD_rwRestart(OD_stream_t *stream) {
 470:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     if (stream != NULL) stream->dataOffset = 0;
 471:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 472:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 473:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 474:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 475:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Get TPDO request flags for OD entry.
 476:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 477:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * flagsPDO can be used for @ref OD_requestTPDO() or @ref OD_TPDOtransmitted().
 478:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 479:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param entry OD entry returned by @ref OD_find().
 480:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 481:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return pointer to flagsPDO
 482:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 483:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline uint8_t *OD_getFlagsPDO(OD_entry_t *entry) {
 484:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if OD_FLAGS_PDO_SIZE > 0
 485:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     if (entry != NULL && entry->extension != NULL) {
 486:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         return &entry->extension->flagsPDO[0];
 487:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     }
 488:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 489:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return 0;
 490:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 491:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 492:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 493:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 494:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Request TPDO, to which OD variable is mapped
 495:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 496:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Function clears the flagPDO bit, which corresponds to OD variable at specific
 497:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * OD index and subindex. For this functionality to work, @ref OD_extension_t
 498:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * must be enabled on OD variable. If OD variable is mapped to any TPDO with
 499:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * event driven transmission, then TPDO will be transmitted after this function
 500:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * call. If OD variable is mapped to more than one TPDO with event driven
 501:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * transmission, only the first matched TPDO will be transmitted.
 502:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 503:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * TPDO event driven transmission is enabled, if TPDO communication parameter,
 504:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * transmission type is set to 0, 254 or 255. For other transmission types
 505:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * (synchronous) flagPDO bit is ignored.
 506:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 507:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param flagsPDO TPDO request flags returned by @ref OD_getFlagsPDO.
 508:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param subIndex subIndex of the OD variable.
 509:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 510:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline void OD_requestTPDO(uint8_t *flagsPDO, uint8_t subIndex) {
 511:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if OD_FLAGS_PDO_SIZE > 0
 512:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     if (flagsPDO != NULL && subIndex < (OD_FLAGS_PDO_SIZE * 8)) {
 513:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         /* clear subIndex-th bit */
 514:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         uint8_t mask = ~(1 << (subIndex & 0x07));
 515:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         flagsPDO[subIndex >> 3] &= mask;
 516:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     }
 517:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 518:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 519:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 520:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 521:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 522:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Check if requested TPDO was transmitted
 523:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 524:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param flagsPDO TPDO request flags returned by @ref OD_getFlagsPDO.
 525:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param subIndex subIndex of the OD variable.
 526:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 527:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return Return true if event driven TPDO with mapping to OD variable,
 528:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * indicated by flagsPDO and subIndex, was transmitted since last
 529:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_requestTPDO call. If there was no @ref OD_requestTPDO call yet and
 530:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * TPDO was transmitted by other event, function also returns true.
 531:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 532:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline bool_t OD_TPDOtransmitted(uint8_t *flagsPDO, uint8_t subIndex) {
 533:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if OD_FLAGS_PDO_SIZE > 0
 534:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     if (flagsPDO != NULL && subIndex < (OD_FLAGS_PDO_SIZE * 8)) {
 535:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         /* return true, if subIndex-th bit is set */
 536:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         uint8_t mask = 1 << (subIndex & 0x07);
 537:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         if ((flagsPDO[subIndex >> 3] & mask) != 0) {
 538:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****             return true;
 539:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         }
 540:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     }
 541:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 542:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return false;
 543:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 544:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 545:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 546:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 547:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Get SDO abort code from returnCode
 548:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 549:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param returnCode Returned from some OD access functions
 550:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 551:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return Corresponding @ref CO_SDO_abortCode_t
 552:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 553:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** uint32_t OD_getSDOabCode(ODR_t returnCode);
 554:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 555:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 556:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 557:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Extend OD object with own read/write functions and/or flagsPDO
 558:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 559:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * This function gives application very powerful tool: definition of own IO
 560:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * access on OD object. Structure and attributes are the same as defined in
 561:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * original OD object, but data are read directly from (or written directly to)
 562:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * application specified object via custom function calls.
 563:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 564:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Before this function specifies extension, OD variables are accessed from
 565:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * original OD location. After this function specifies extension OD variables
 566:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * are accessed from read/write functions specified by extension. (Except when
 567:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * "odOrig" argument to @ref OD_getSub() is set to true.)
 568:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 569:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * This function must also be used, when flagsPDO needs to be enabled for
 570:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * specific entry.
 571:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 572:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @warning
 573:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Object dictionary storage works only directly on OD variables. It does not
 574:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * access read function specified here. So, if extended OD objects needs to be
 575:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * preserved, then @ref OD_writeOriginal can be used inside custom write
 576:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * function.
 577:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 578:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @warning
 579:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Read and write functions may be called from different threads, so critical
 580:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * sections in custom functions must be observed, see @ref CO_critical_sections.
 581:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 582:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param entry OD entry returned by @ref OD_find().
 583:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param extension Extension object, which must be initialized externally.
 584:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Extension object must exist permanently. If NULL, extension will be removed.
 585:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 586:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return "ODR_OK" on success, "ODR_IDX_NOT_EXIST" if OD object doesn't exist.
 587:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 588:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_extension_init(OD_entry_t *entry,
 589:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                       OD_extension_t *extension)
 590:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 225              	 .loc 2 590 0
 226              	 .cfi_startproc
 227              	 
 228              	 
 229              	 
 230 0000 80B4     	 push {r7}
 231              	.LCFI23:
 232              	 .cfi_def_cfa_offset 4
 233              	 .cfi_offset 7,-4
 234 0002 83B0     	 sub sp,sp,#12
 235              	.LCFI24:
 236              	 .cfi_def_cfa_offset 16
 237 0004 00AF     	 add r7,sp,#0
 238              	.LCFI25:
 239              	 .cfi_def_cfa_register 7
 240 0006 7860     	 str r0,[r7,#4]
 241 0008 3960     	 str r1,[r7]
 591:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     if (entry == NULL) return ODR_IDX_NOT_EXIST;
 242              	 .loc 2 591 0
 243 000a 7B68     	 ldr r3,[r7,#4]
 244 000c 002B     	 cmp r3,#0
 245 000e 01D1     	 bne .L14
 246              	 .loc 2 591 0 is_stmt 0 discriminator 1
 247 0010 0523     	 movs r3,#5
 248 0012 03E0     	 b .L15
 249              	.L14:
 592:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     entry->extension = extension;
 250              	 .loc 2 592 0 is_stmt 1
 251 0014 7B68     	 ldr r3,[r7,#4]
 252 0016 3A68     	 ldr r2,[r7]
 253 0018 9A60     	 str r2,[r3,#8]
 593:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return ODR_OK;
 254              	 .loc 2 593 0
 255 001a 0023     	 movs r3,#0
 256              	.L15:
 257 001c 5BB2     	 sxtb r3,r3
 594:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 258              	 .loc 2 594 0
 259 001e 1846     	 mov r0,r3
 260 0020 0C37     	 adds r7,r7,#12
 261              	.LCFI26:
 262              	 .cfi_def_cfa_offset 4
 263 0022 BD46     	 mov sp,r7
 264              	.LCFI27:
 265              	 .cfi_def_cfa_register 13
 266              	 
 267 0024 5DF8047B 	 ldr r7,[sp],#4
 268              	.LCFI28:
 269              	 .cfi_restore 7
 270              	 .cfi_def_cfa_offset 0
 271 0028 7047     	 bx lr
 272              	 .cfi_endproc
 273              	.LFE12:
 275 002a 00BF     	 .section .text.OD_get_u8,"ax",%progbits
 276              	 .align 2
 277              	 .thumb
 278              	 .thumb_func
 280              	OD_get_u8:
 281              	.LFB17:
 595:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 596:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 597:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 598:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @defgroup CO_ODgetSetters Getters and setters
 599:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @{
 600:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 601:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Getter and setter helper functions for accessing different types of Object
 602:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Dictionary variables.
 603:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 604:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 605:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Get variable from Object Dictionary
 606:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 607:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param entry OD entry returned by @ref OD_find().
 608:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param subIndex Sub-index of the variable from the OD object.
 609:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param [out] val Value will be written here.
 610:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param len Size of value to retrieve from OD.
 611:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param odOrig If true, then potential IO extension on entry will be
 612:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * ignored and data in the original OD location will be returned.
 613:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 614:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return Value from @ref ODR_t, "ODR_OK" in case of success. Error, if
 615:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * variable does not exist in object dictionary or it does not have the correct
 616:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * length or other reason.
 617:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 618:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** ODR_t OD_get_value(const OD_entry_t *entry, uint8_t subIndex,
 619:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                    void *val, OD_size_t len, bool_t odOrig);
 620:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 621:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get int8_t variable from Object Dictionary, see @ref OD_get_value */
 622:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_i8(const OD_entry_t *entry, uint8_t subIndex,
 623:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                               int8_t *val, bool_t odOrig)
 624:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 625:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 626:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 1, odOrig);
 627:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 628:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 629:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 630:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 631:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 632:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get int16_t variable from Object Dictionary, see @ref OD_get_value */
 633:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_i16(const OD_entry_t *entry, uint8_t subIndex,
 634:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                int16_t *val, bool_t odOrig)
 635:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 636:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 637:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 2, odOrig);
 638:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 639:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 640:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 641:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 642:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 643:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get int32_t variable from Object Dictionary, see @ref OD_get_value */
 644:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_i32(const OD_entry_t *entry, uint8_t subIndex,
 645:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                int32_t *val, bool_t odOrig)
 646:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 647:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 648:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 4, odOrig);
 649:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 650:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 651:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 652:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 653:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 654:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get int64_t variable from Object Dictionary, see @ref OD_get_value */
 655:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_i64(const OD_entry_t *entry, uint8_t subIndex,
 656:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                int64_t *val, bool_t odOrig)
 657:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 658:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 659:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 8, odOrig);
 660:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 661:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 662:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 663:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 664:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 665:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get uint8_t variable from Object Dictionary, see @ref OD_get_value */
 666:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_u8(const OD_entry_t *entry, uint8_t subIndex,
 667:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                               uint8_t *val, bool_t odOrig)
 668:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 282              	 .loc 2 668 0
 283              	 .cfi_startproc
 284              	 
 285              	 
 286 0000 80B5     	 push {r7,lr}
 287              	.LCFI29:
 288              	 .cfi_def_cfa_offset 8
 289              	 .cfi_offset 7,-8
 290              	 .cfi_offset 14,-4
 291 0002 86B0     	 sub sp,sp,#24
 292              	.LCFI30:
 293              	 .cfi_def_cfa_offset 32
 294 0004 02AF     	 add r7,sp,#8
 295              	.LCFI31:
 296              	 .cfi_def_cfa 7,24
 297 0006 F860     	 str r0,[r7,#12]
 298 0008 7A60     	 str r2,[r7,#4]
 299 000a 3B60     	 str r3,[r7]
 300 000c 0B46     	 mov r3,r1
 301 000e FB72     	 strb r3,[r7,#11]
 669:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 670:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 1, odOrig);
 671:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 672:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 302              	 .loc 2 672 0
 303 0010 FA7A     	 ldrb r2,[r7,#11]
 304 0012 3B68     	 ldr r3,[r7]
 305 0014 0093     	 str r3,[sp]
 306 0016 F868     	 ldr r0,[r7,#12]
 307 0018 1146     	 mov r1,r2
 308 001a 7A68     	 ldr r2,[r7,#4]
 309 001c 0123     	 movs r3,#1
 310 001e FFF7FEFF 	 bl OD_get_value
 311 0022 0346     	 mov r3,r0
 673:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 674:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 312              	 .loc 2 674 0
 313 0024 1846     	 mov r0,r3
 314 0026 1037     	 adds r7,r7,#16
 315              	.LCFI32:
 316              	 .cfi_def_cfa_offset 8
 317 0028 BD46     	 mov sp,r7
 318              	.LCFI33:
 319              	 .cfi_def_cfa_register 13
 320              	 
 321 002a 80BD     	 pop {r7,pc}
 322              	 .cfi_endproc
 323              	.LFE17:
 325              	 .section .text.OD_get_u32,"ax",%progbits
 326              	 .align 2
 327              	 .thumb
 328              	 .thumb_func
 330              	OD_get_u32:
 331              	.LFB19:
 675:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 676:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get uint16_t variable from Object Dictionary, see @ref OD_get_value */
 677:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_u16(const OD_entry_t *entry, uint8_t subIndex,
 678:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                uint16_t *val, bool_t odOrig)
 679:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 680:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 681:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 2, odOrig);
 682:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 683:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 684:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 685:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 686:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 687:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get uint32_t variable from Object Dictionary, see @ref OD_get_value */
 688:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_u32(const OD_entry_t *entry, uint8_t subIndex,
 689:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                uint32_t *val, bool_t odOrig)
 690:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 332              	 .loc 2 690 0
 333              	 .cfi_startproc
 334              	 
 335              	 
 336 0000 80B5     	 push {r7,lr}
 337              	.LCFI34:
 338              	 .cfi_def_cfa_offset 8
 339              	 .cfi_offset 7,-8
 340              	 .cfi_offset 14,-4
 341 0002 86B0     	 sub sp,sp,#24
 342              	.LCFI35:
 343              	 .cfi_def_cfa_offset 32
 344 0004 02AF     	 add r7,sp,#8
 345              	.LCFI36:
 346              	 .cfi_def_cfa 7,24
 347 0006 F860     	 str r0,[r7,#12]
 348 0008 7A60     	 str r2,[r7,#4]
 349 000a 3B60     	 str r3,[r7]
 350 000c 0B46     	 mov r3,r1
 351 000e FB72     	 strb r3,[r7,#11]
 691:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 692:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 4, odOrig);
 693:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 694:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 352              	 .loc 2 694 0
 353 0010 FA7A     	 ldrb r2,[r7,#11]
 354 0012 3B68     	 ldr r3,[r7]
 355 0014 0093     	 str r3,[sp]
 356 0016 F868     	 ldr r0,[r7,#12]
 357 0018 1146     	 mov r1,r2
 358 001a 7A68     	 ldr r2,[r7,#4]
 359 001c 0423     	 movs r3,#4
 360 001e FFF7FEFF 	 bl OD_get_value
 361 0022 0346     	 mov r3,r0
 695:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 696:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 362              	 .loc 2 696 0
 363 0024 1846     	 mov r0,r3
 364 0026 1037     	 adds r7,r7,#16
 365              	.LCFI37:
 366              	 .cfi_def_cfa_offset 8
 367 0028 BD46     	 mov sp,r7
 368              	.LCFI38:
 369              	 .cfi_def_cfa_register 13
 370              	 
 371 002a 80BD     	 pop {r7,pc}
 372              	 .cfi_endproc
 373              	.LFE19:
 375              	 .section .text.OD_set_u32,"ax",%progbits
 376              	 .align 2
 377              	 .thumb
 378              	 .thumb_func
 380              	OD_set_u32:
 381              	.LFB29:
 697:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 698:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get uint64_t variable from Object Dictionary, see @ref OD_get_value */
 699:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_u64(const OD_entry_t *entry, uint8_t subIndex,
 700:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                uint64_t *val, bool_t odOrig)
 701:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 702:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 703:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 8, odOrig);
 704:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 705:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 706:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 707:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 708:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 709:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get float32_t variable from Object Dictionary, see @ref OD_get_value */
 710:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_f32(const OD_entry_t *entry, uint8_t subIndex,
 711:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                float32_t *val, bool_t odOrig)
 712:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 713:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 714:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 4, odOrig);
 715:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 716:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 717:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 718:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 719:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 720:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get float64_t variable from Object Dictionary, see @ref OD_get_value */
 721:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_f64(const OD_entry_t *entry, uint8_t subIndex,
 722:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                float64_t *val, bool_t odOrig)
 723:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 724:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 725:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 8, odOrig);
 726:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 727:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 728:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 729:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 730:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 731:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 732:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Set variable in Object Dictionary
 733:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 734:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param entry OD entry returned by @ref OD_find().
 735:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param subIndex Sub-index of the variable from the OD object.
 736:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param val Pointer to value to write.
 737:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param len Size of value to write.
 738:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param odOrig If true, then potential IO extension on entry will be
 739:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * ignored and data in the original OD location will be written.
 740:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 741:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return Value from @ref ODR_t, "ODR_OK" in case of success. Error, if
 742:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * variable does not exist in object dictionary or it does not have the correct
 743:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * length or other reason.
 744:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 745:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** ODR_t OD_set_value(const OD_entry_t *entry, uint8_t subIndex, void *val,
 746:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                    OD_size_t len, bool_t odOrig);
 747:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 748:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Set int8_t variable in Object Dictionary, see @ref OD_set_value */
 749:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_set_i8(const OD_entry_t *entry, uint8_t subIndex,
 750:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                               int8_t val, bool_t odOrig)
 751:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 752:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 753:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, 1, odOrig);
 754:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 755:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, sizeof(val), odOrig);
 756:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 757:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 758:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 759:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Set int16_t variable in Object Dictionary, see @ref OD_set_value */
 760:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_set_i16(const OD_entry_t *entry, uint8_t subIndex,
 761:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                int16_t val, bool_t odOrig)
 762:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 763:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 764:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, 2, odOrig);
 765:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 766:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, sizeof(val), odOrig);
 767:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 768:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 769:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 770:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Set int32_t variable in Object Dictionary, see @ref OD_set_value */
 771:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_set_i32(const OD_entry_t *entry, uint8_t subIndex,
 772:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                int32_t val, bool_t odOrig)
 773:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 774:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 775:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, 4, odOrig);
 776:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 777:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, sizeof(val), odOrig);
 778:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 779:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 780:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 781:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Set int32_t variable in Object Dictionary, see @ref OD_set_value */
 782:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_set_i64(const OD_entry_t *entry, uint8_t subIndex,
 783:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                int64_t val, bool_t odOrig)
 784:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 785:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 786:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, 8, odOrig);
 787:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 788:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, sizeof(val), odOrig);
 789:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 790:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 791:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 792:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Set uint8_t variable in Object Dictionary, see @ref OD_set_value */
 793:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_set_u8(const OD_entry_t *entry, uint8_t subIndex,
 794:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                               uint8_t val, bool_t odOrig)
 795:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 796:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 797:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, 1, odOrig);
 798:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 799:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, sizeof(val), odOrig);
 800:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 801:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 802:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 803:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Set uint16_t variable in Object Dictionary, see @ref OD_set_value */
 804:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_set_u16(const OD_entry_t *entry, uint8_t subIndex,
 805:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                uint16_t val, bool_t odOrig)
 806:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 807:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 808:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, 2, odOrig);
 809:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 810:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, sizeof(val), odOrig);
 811:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 812:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 813:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 814:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Set uint32_t variable in Object Dictionary, see @ref OD_set_value */
 815:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_set_u32(const OD_entry_t *entry, uint8_t subIndex,
 816:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                uint32_t val, bool_t odOrig)
 817:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 382              	 .loc 2 817 0
 383              	 .cfi_startproc
 384              	 
 385              	 
 386 0000 80B5     	 push {r7,lr}
 387              	.LCFI39:
 388              	 .cfi_def_cfa_offset 8
 389              	 .cfi_offset 7,-8
 390              	 .cfi_offset 14,-4
 391 0002 86B0     	 sub sp,sp,#24
 392              	.LCFI40:
 393              	 .cfi_def_cfa_offset 32
 394 0004 02AF     	 add r7,sp,#8
 395              	.LCFI41:
 396              	 .cfi_def_cfa 7,24
 397 0006 F860     	 str r0,[r7,#12]
 398 0008 7A60     	 str r2,[r7,#4]
 399 000a 3B60     	 str r3,[r7]
 400 000c 0B46     	 mov r3,r1
 401 000e FB72     	 strb r3,[r7,#11]
 818:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 819:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, 4, odOrig);
 820:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 821:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_set_value(entry, subIndex, &val, sizeof(val), odOrig);
 402              	 .loc 2 821 0
 403 0010 F97A     	 ldrb r1,[r7,#11]
 404 0012 3A1D     	 adds r2,r7,#4
 405 0014 3B68     	 ldr r3,[r7]
 406 0016 0093     	 str r3,[sp]
 407 0018 F868     	 ldr r0,[r7,#12]
 408 001a 0423     	 movs r3,#4
 409 001c FFF7FEFF 	 bl OD_set_value
 410 0020 0346     	 mov r3,r0
 822:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 823:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 411              	 .loc 2 823 0
 412 0022 1846     	 mov r0,r3
 413 0024 1037     	 adds r7,r7,#16
 414              	.LCFI42:
 415              	 .cfi_def_cfa_offset 8
 416 0026 BD46     	 mov sp,r7
 417              	.LCFI43:
 418              	 .cfi_def_cfa_register 13
 419              	 
 420 0028 80BD     	 pop {r7,pc}
 421              	 .cfi_endproc
 422              	.LFE29:
 424 002a 00BF     	 .section .text.CO_SDO_receive,"ax",%progbits
 425              	 .align 2
 426              	 .thumb
 427              	 .thumb_func
 429              	CO_SDO_receive:
 430              	.LFB33:
 431              	 .file 3 "../CANopen/stack/301/CO_SDOserver.c"
   1:../CANopen/stack/301/CO_SDOserver.c **** /*
   2:../CANopen/stack/301/CO_SDOserver.c ****  * CANopen Service Data Object - server.
   3:../CANopen/stack/301/CO_SDOserver.c ****  *
   4:../CANopen/stack/301/CO_SDOserver.c ****  * @file        CO_SDOserver.c
   5:../CANopen/stack/301/CO_SDOserver.c ****  * @ingroup     CO_SDOserver
   6:../CANopen/stack/301/CO_SDOserver.c ****  * @author      Janez Paternoster
   7:../CANopen/stack/301/CO_SDOserver.c ****  * @copyright   2020 Janez Paternoster
   8:../CANopen/stack/301/CO_SDOserver.c ****  *
   9:../CANopen/stack/301/CO_SDOserver.c ****  * This file is part of CANopenNode, an opensource CANopen Stack.
  10:../CANopen/stack/301/CO_SDOserver.c ****  * Project home page is <https://github.com/CANopenNode/CANopenNode>.
  11:../CANopen/stack/301/CO_SDOserver.c ****  * For more information on CANopen see <http://www.can-cia.org/>.
  12:../CANopen/stack/301/CO_SDOserver.c ****  *
  13:../CANopen/stack/301/CO_SDOserver.c ****  * Licensed under the Apache License, Version 2.0 (the "License");
  14:../CANopen/stack/301/CO_SDOserver.c ****  * you may not use this file except in compliance with the License.
  15:../CANopen/stack/301/CO_SDOserver.c ****  * You may obtain a copy of the License at
  16:../CANopen/stack/301/CO_SDOserver.c ****  *
  17:../CANopen/stack/301/CO_SDOserver.c ****  *     http://www.apache.org/licenses/LICENSE-2.0
  18:../CANopen/stack/301/CO_SDOserver.c ****  *
  19:../CANopen/stack/301/CO_SDOserver.c ****  * Unless required by applicable law or agreed to in writing, software
  20:../CANopen/stack/301/CO_SDOserver.c ****  * distributed under the License is distributed on an "AS IS" BASIS,
  21:../CANopen/stack/301/CO_SDOserver.c ****  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  22:../CANopen/stack/301/CO_SDOserver.c ****  * See the License for the specific language governing permissions and
  23:../CANopen/stack/301/CO_SDOserver.c ****  * limitations under the License.
  24:../CANopen/stack/301/CO_SDOserver.c ****  */
  25:../CANopen/stack/301/CO_SDOserver.c **** 
  26:../CANopen/stack/301/CO_SDOserver.c **** #include <string.h>
  27:../CANopen/stack/301/CO_SDOserver.c **** 
  28:../CANopen/stack/301/CO_SDOserver.c **** #include "301/CO_SDOserver.h"
  29:../CANopen/stack/301/CO_SDOserver.c **** #include "301/crc16-ccitt.h"
  30:../CANopen/stack/301/CO_SDOserver.c **** 
  31:../CANopen/stack/301/CO_SDOserver.c **** /* verify configuration */
  32:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
  33:../CANopen/stack/301/CO_SDOserver.c ****  #if CO_CONFIG_SDO_SRV_BUFFER_SIZE < 20
  34:../CANopen/stack/301/CO_SDOserver.c ****   #error CO_CONFIG_SDO_SRV_BUFFER_SIZE must be greater or equal than 20.
  35:../CANopen/stack/301/CO_SDOserver.c ****  #endif
  36:../CANopen/stack/301/CO_SDOserver.c **** #endif
  37:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK
  38:../CANopen/stack/301/CO_SDOserver.c ****  #if !((CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED)
  39:../CANopen/stack/301/CO_SDOserver.c ****   #error CO_CONFIG_SDO_SRV_SEGMENTED must be enabled.
  40:../CANopen/stack/301/CO_SDOserver.c ****  #endif
  41:../CANopen/stack/301/CO_SDOserver.c ****  #if !((CO_CONFIG_CRC16) & CO_CONFIG_CRC16_ENABLE)
  42:../CANopen/stack/301/CO_SDOserver.c ****   #error CO_CONFIG_CRC16_ENABLE must be enabled.
  43:../CANopen/stack/301/CO_SDOserver.c ****  #endif
  44:../CANopen/stack/301/CO_SDOserver.c ****  #if CO_CONFIG_SDO_SRV_BUFFER_SIZE < 900
  45:../CANopen/stack/301/CO_SDOserver.c ****   #error CO_CONFIG_SDO_SRV_BUFFER_SIZE must be greater or equal than 900.
  46:../CANopen/stack/301/CO_SDOserver.c ****  #endif
  47:../CANopen/stack/301/CO_SDOserver.c **** #endif
  48:../CANopen/stack/301/CO_SDOserver.c **** 
  49:../CANopen/stack/301/CO_SDOserver.c **** /*
  50:../CANopen/stack/301/CO_SDOserver.c ****  * Read received message from CAN module.
  51:../CANopen/stack/301/CO_SDOserver.c ****  *
  52:../CANopen/stack/301/CO_SDOserver.c ****  * Function will be called (by CAN receive interrupt) every time, when CAN
  53:../CANopen/stack/301/CO_SDOserver.c ****  * message with correct identifier will be received. For more information and
  54:../CANopen/stack/301/CO_SDOserver.c ****  * description of parameters see file CO_driver.h.
  55:../CANopen/stack/301/CO_SDOserver.c ****  */
  56:../CANopen/stack/301/CO_SDOserver.c **** static void CO_SDO_receive(void *object, void *msg) {
 432              	 .loc 3 56 0
 433              	 .cfi_startproc
 434              	 
 435              	 
 436 0000 80B5     	 push {r7,lr}
 437              	.LCFI44:
 438              	 .cfi_def_cfa_offset 8
 439              	 .cfi_offset 7,-8
 440              	 .cfi_offset 14,-4
 441 0002 86B0     	 sub sp,sp,#24
 442              	.LCFI45:
 443              	 .cfi_def_cfa_offset 32
 444 0004 00AF     	 add r7,sp,#0
 445              	.LCFI46:
 446              	 .cfi_def_cfa_register 7
 447 0006 7860     	 str r0,[r7,#4]
 448 0008 3960     	 str r1,[r7]
  57:../CANopen/stack/301/CO_SDOserver.c ****     CO_SDOserver_t *SDO = (CO_SDOserver_t *)object;
 449              	 .loc 3 57 0
 450 000a 7B68     	 ldr r3,[r7,#4]
 451 000c 7B61     	 str r3,[r7,#20]
  58:../CANopen/stack/301/CO_SDOserver.c ****     uint8_t DLC = CO_CANrxMsg_readDLC(msg);
 452              	 .loc 3 58 0
 453 000e 3B68     	 ldr r3,[r7]
 454 0010 1B79     	 ldrb r3,[r3,#4]
 455 0012 FB74     	 strb r3,[r7,#19]
  59:../CANopen/stack/301/CO_SDOserver.c ****     uint8_t *data = CO_CANrxMsg_readData(msg);
 456              	 .loc 3 59 0
 457 0014 3B68     	 ldr r3,[r7]
 458 0016 0533     	 adds r3,r3,#5
 459 0018 FB60     	 str r3,[r7,#12]
  60:../CANopen/stack/301/CO_SDOserver.c **** 
  61:../CANopen/stack/301/CO_SDOserver.c ****     /* ignore messages with wrong length */
  62:../CANopen/stack/301/CO_SDOserver.c ****     if (DLC == 8) {
 460              	 .loc 3 62 0
 461 001a FB7C     	 ldrb r3,[r7,#19]
 462 001c 082B     	 cmp r3,#8
 463 001e 17D1     	 bne .L22
  63:../CANopen/stack/301/CO_SDOserver.c ****         if (data[0] == 0x80) {
 464              	 .loc 3 63 0
 465 0020 FB68     	 ldr r3,[r7,#12]
 466 0022 1B78     	 ldrb r3,[r3]
 467 0024 802B     	 cmp r3,#128
 468 0026 03D1     	 bne .L24
  64:../CANopen/stack/301/CO_SDOserver.c ****             /* abort from client, just make idle */
  65:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_IDLE;
 469              	 .loc 3 65 0
 470 0028 7B69     	 ldr r3,[r7,#20]
 471 002a 0022     	 movs r2,#0
 472 002c 1A75     	 strb r2,[r3,#20]
 473 002e 0FE0     	 b .L22
 474              	.L24:
  66:../CANopen/stack/301/CO_SDOserver.c ****         }
  67:../CANopen/stack/301/CO_SDOserver.c ****         else if (CO_FLAG_READ(SDO->CANrxNew)) {
 475              	 .loc 3 67 0
 476 0030 7B69     	 ldr r3,[r7,#20]
 477 0032 9B6B     	 ldr r3,[r3,#56]
 478 0034 002B     	 cmp r3,#0
 479 0036 0BD1     	 bne .L22
  68:../CANopen/stack/301/CO_SDOserver.c ****             /* ignore message if previous message was not processed yet */
  69:../CANopen/stack/301/CO_SDOserver.c ****         }
  70:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK
  71:../CANopen/stack/301/CO_SDOserver.c ****         else if (SDO->state == CO_SDO_ST_UPLOAD_BLK_END_CRSP && data[0]==0xA1) {
  72:../CANopen/stack/301/CO_SDOserver.c ****             /*  SDO block download successfully transferred, just make idle */
  73:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_IDLE;
  74:../CANopen/stack/301/CO_SDOserver.c ****         }
  75:../CANopen/stack/301/CO_SDOserver.c ****         else if (SDO->state == CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_REQ) {
  76:../CANopen/stack/301/CO_SDOserver.c ****             /* just in case, condition should always pass */
  77:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->bufOffsetWr <= (CO_CONFIG_SDO_SRV_BUFFER_SIZE - (7+2))) {
  78:../CANopen/stack/301/CO_SDOserver.c ****                 /* block download, copy data directly */
  79:../CANopen/stack/301/CO_SDOserver.c ****                 CO_SDO_state_t state = CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_REQ;
  80:../CANopen/stack/301/CO_SDOserver.c ****                 uint8_t seqno = data[0] & 0x7F;
  81:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->timeoutTimer = 0;
  82:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->block_timeoutTimer = 0;
  83:../CANopen/stack/301/CO_SDOserver.c **** 
  84:../CANopen/stack/301/CO_SDOserver.c ****                 /* verify if sequence number is correct */
  85:../CANopen/stack/301/CO_SDOserver.c ****                 if (seqno <= SDO->block_blksize
  86:../CANopen/stack/301/CO_SDOserver.c ****                     && seqno == (SDO->block_seqno + 1)
  87:../CANopen/stack/301/CO_SDOserver.c ****                 ) {
  88:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->block_seqno = seqno;
  89:../CANopen/stack/301/CO_SDOserver.c **** 
  90:../CANopen/stack/301/CO_SDOserver.c ****                     /* Copy data. There is always enough space in buffer,
  91:../CANopen/stack/301/CO_SDOserver.c ****                     * because block_blksize was calculated before */
  92:../CANopen/stack/301/CO_SDOserver.c ****                     memcpy(SDO->buf + SDO->bufOffsetWr, &data[1], 7);
  93:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->bufOffsetWr += 7;
  94:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->sizeTran += 7;
  95:../CANopen/stack/301/CO_SDOserver.c **** 
  96:../CANopen/stack/301/CO_SDOserver.c ****                     /* is this the last segment? */
  97:../CANopen/stack/301/CO_SDOserver.c ****                     if ((data[0] & 0x80) != 0) {
  98:../CANopen/stack/301/CO_SDOserver.c ****                         SDO->finished = true;
  99:../CANopen/stack/301/CO_SDOserver.c ****                         state = CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_RSP;
 100:../CANopen/stack/301/CO_SDOserver.c ****                     }
 101:../CANopen/stack/301/CO_SDOserver.c ****                     else if (seqno == SDO->block_blksize) {
 102:../CANopen/stack/301/CO_SDOserver.c ****                         /* all segments in sub-block has been transferred */
 103:../CANopen/stack/301/CO_SDOserver.c ****                         state = CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_RSP;
 104:../CANopen/stack/301/CO_SDOserver.c ****                     }
 105:../CANopen/stack/301/CO_SDOserver.c ****                 }
 106:../CANopen/stack/301/CO_SDOserver.c ****                 /* If message is duplicate or sequence didn't start yet, ignore
 107:../CANopen/stack/301/CO_SDOserver.c ****                  * it. Otherwise seqno is wrong, so break sub-block. Data after
 108:../CANopen/stack/301/CO_SDOserver.c ****                  * last good seqno will be re-transmitted. */
 109:../CANopen/stack/301/CO_SDOserver.c ****                 else if (seqno != SDO->block_seqno && SDO->block_seqno != 0U) {
 110:../CANopen/stack/301/CO_SDOserver.c ****                     state = CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_RSP;
 111:../CANopen/stack/301/CO_SDOserver.c **** #ifdef CO_DEBUG_SDO_SERVER
 112:../CANopen/stack/301/CO_SDOserver.c ****                     char msg[80];
 113:../CANopen/stack/301/CO_SDOserver.c ****                     sprintf(msg,
 114:../CANopen/stack/301/CO_SDOserver.c ****                             "sub-block, rx WRONG: sequno=%02X, previous=%02X",
 115:../CANopen/stack/301/CO_SDOserver.c ****                             seqno, SDO->block_seqno);
 116:../CANopen/stack/301/CO_SDOserver.c ****                     CO_DEBUG_SDO_SERVER(msg);
 117:../CANopen/stack/301/CO_SDOserver.c **** #endif
 118:../CANopen/stack/301/CO_SDOserver.c ****                 }
 119:../CANopen/stack/301/CO_SDOserver.c **** #ifdef CO_DEBUG_SDO_SERVER
 120:../CANopen/stack/301/CO_SDOserver.c ****                 else {
 121:../CANopen/stack/301/CO_SDOserver.c ****                     char msg[80];
 122:../CANopen/stack/301/CO_SDOserver.c ****                     sprintf(msg,
 123:../CANopen/stack/301/CO_SDOserver.c ****                             "sub-block, rx ignored: sequno=%02X, expected=%02X",
 124:../CANopen/stack/301/CO_SDOserver.c ****                             seqno, SDO->block_seqno + 1);
 125:../CANopen/stack/301/CO_SDOserver.c ****                     CO_DEBUG_SDO_SERVER(msg);
 126:../CANopen/stack/301/CO_SDOserver.c ****                 }
 127:../CANopen/stack/301/CO_SDOserver.c **** #endif
 128:../CANopen/stack/301/CO_SDOserver.c **** 
 129:../CANopen/stack/301/CO_SDOserver.c ****                 if (state != CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_REQ) {
 130:../CANopen/stack/301/CO_SDOserver.c ****                     /* SDO->state has changed, processing will continue in
 131:../CANopen/stack/301/CO_SDOserver.c ****                      * another thread. Make memory barrier here with
 132:../CANopen/stack/301/CO_SDOserver.c ****                      * CO_FLAG_CLEAR() call. */
 133:../CANopen/stack/301/CO_SDOserver.c ****                     CO_FLAG_CLEAR(SDO->CANrxNew);
 134:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = state;
 135:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_CALLBACK_PRE
 136:../CANopen/stack/301/CO_SDOserver.c ****                     /* Optional signal to RTOS, which can resume task, which
 137:../CANopen/stack/301/CO_SDOserver.c ****                      * handles SDO server processing. */
 138:../CANopen/stack/301/CO_SDOserver.c ****                     if (SDO->pFunctSignalPre != NULL) {
 139:../CANopen/stack/301/CO_SDOserver.c ****                         SDO->pFunctSignalPre(SDO->functSignalObjectPre);
 140:../CANopen/stack/301/CO_SDOserver.c ****                     }
 141:../CANopen/stack/301/CO_SDOserver.c **** #endif
 142:../CANopen/stack/301/CO_SDOserver.c ****                 }
 143:../CANopen/stack/301/CO_SDOserver.c ****             }
 144:../CANopen/stack/301/CO_SDOserver.c ****         }
 145:../CANopen/stack/301/CO_SDOserver.c ****         else if (SDO->state == CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_RSP) {
 146:../CANopen/stack/301/CO_SDOserver.c ****             /* ignore subsequent server messages, if response was requested */
 147:../CANopen/stack/301/CO_SDOserver.c ****         }
 148:../CANopen/stack/301/CO_SDOserver.c **** #endif /* (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK */
 149:../CANopen/stack/301/CO_SDOserver.c ****         else {
 150:../CANopen/stack/301/CO_SDOserver.c ****             /* copy data and set 'new message' flag, data will be processed in
 151:../CANopen/stack/301/CO_SDOserver.c ****              * CO_SDOserver_process() */
 152:../CANopen/stack/301/CO_SDOserver.c ****             memcpy(SDO->CANrxData, data, DLC);
 480              	 .loc 3 152 0
 481 0038 7B69     	 ldr r3,[r7,#20]
 482 003a 03F13C02 	 add r2,r3,#60
 483 003e FB7C     	 ldrb r3,[r7,#19]
 484 0040 1046     	 mov r0,r2
 485 0042 F968     	 ldr r1,[r7,#12]
 486 0044 1A46     	 mov r2,r3
 487 0046 FFF7FEFF 	 bl memcpy
 153:../CANopen/stack/301/CO_SDOserver.c ****             CO_FLAG_SET(SDO->CANrxNew);
 488              	 .loc 3 153 0
 489 004a 7B69     	 ldr r3,[r7,#20]
 490 004c 0122     	 movs r2,#1
 491 004e 9A63     	 str r2,[r3,#56]
 492              	.L22:
 154:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_CALLBACK_PRE
 155:../CANopen/stack/301/CO_SDOserver.c ****             /* Optional signal to RTOS, which can resume task, which handles
 156:../CANopen/stack/301/CO_SDOserver.c ****             * SDO server processing. */
 157:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->pFunctSignalPre != NULL) {
 158:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->pFunctSignalPre(SDO->functSignalObjectPre);
 159:../CANopen/stack/301/CO_SDOserver.c ****             }
 160:../CANopen/stack/301/CO_SDOserver.c **** #endif
 161:../CANopen/stack/301/CO_SDOserver.c ****         }
 162:../CANopen/stack/301/CO_SDOserver.c ****     }
 163:../CANopen/stack/301/CO_SDOserver.c **** }
 493              	 .loc 3 163 0
 494 0050 1837     	 adds r7,r7,#24
 495              	.LCFI47:
 496              	 .cfi_def_cfa_offset 8
 497 0052 BD46     	 mov sp,r7
 498              	.LCFI48:
 499              	 .cfi_def_cfa_register 13
 500              	 
 501 0054 80BD     	 pop {r7,pc}
 502              	 .cfi_endproc
 503              	.LFE33:
 505 0056 00BF     	 .section .text.CO_SDOserver_init_canRxTx,"ax",%progbits
 506              	 .align 2
 507              	 .thumb
 508              	 .thumb_func
 510              	CO_SDOserver_init_canRxTx:
 511              	.LFB34:
 164:../CANopen/stack/301/CO_SDOserver.c **** 
 165:../CANopen/stack/301/CO_SDOserver.c **** 
 166:../CANopen/stack/301/CO_SDOserver.c **** /* helper for configuring CANrx and CANtx *************************************/
 167:../CANopen/stack/301/CO_SDOserver.c **** static CO_ReturnError_t CO_SDOserver_init_canRxTx(CO_SDOserver_t *SDO,
 168:../CANopen/stack/301/CO_SDOserver.c ****                                                   CO_CANmodule_t *CANdevRx,
 169:../CANopen/stack/301/CO_SDOserver.c ****                                                   uint16_t CANdevRxIdx,
 170:../CANopen/stack/301/CO_SDOserver.c ****                                                   uint16_t CANdevTxIdx,
 171:../CANopen/stack/301/CO_SDOserver.c ****                                                   uint32_t COB_IDClientToServer,
 172:../CANopen/stack/301/CO_SDOserver.c ****                                                   uint32_t COB_IDServerToClient)
 173:../CANopen/stack/301/CO_SDOserver.c **** {
 512              	 .loc 3 173 0
 513              	 .cfi_startproc
 514              	 
 515              	 
 516 0000 80B5     	 push {r7,lr}
 517              	.LCFI49:
 518              	 .cfi_def_cfa_offset 8
 519              	 .cfi_offset 7,-8
 520              	 .cfi_offset 14,-4
 521 0002 8AB0     	 sub sp,sp,#40
 522              	.LCFI50:
 523              	 .cfi_def_cfa_offset 48
 524 0004 04AF     	 add r7,sp,#16
 525              	.LCFI51:
 526              	 .cfi_def_cfa 7,32
 527 0006 F860     	 str r0,[r7,#12]
 528 0008 B960     	 str r1,[r7,#8]
 529 000a 1146     	 mov r1,r2
 530 000c 1A46     	 mov r2,r3
 531 000e 0B46     	 mov r3,r1
 532 0010 FB80     	 strh r3,[r7,#6]
 533 0012 1346     	 mov r3,r2
 534 0014 BB80     	 strh r3,[r7,#4]
 174:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_OD_DYNAMIC
 175:../CANopen/stack/301/CO_SDOserver.c ****     /* proceed only, if parameters change */
 176:../CANopen/stack/301/CO_SDOserver.c ****     if (COB_IDClientToServer == SDO->COB_IDClientToServer
 535              	 .loc 3 176 0
 536 0016 FB68     	 ldr r3,[r7,#12]
 537 0018 DA6C     	 ldr r2,[r3,#76]
 538 001a 3B6A     	 ldr r3,[r7,#32]
 539 001c 9A42     	 cmp r2,r3
 540 001e 06D1     	 bne .L26
 177:../CANopen/stack/301/CO_SDOserver.c ****         && COB_IDServerToClient == SDO->COB_IDServerToClient
 541              	 .loc 3 177 0
 542 0020 FB68     	 ldr r3,[r7,#12]
 543 0022 1A6D     	 ldr r2,[r3,#80]
 544 0024 7B6A     	 ldr r3,[r7,#36]
 545 0026 9A42     	 cmp r2,r3
 546 0028 01D1     	 bne .L26
 178:../CANopen/stack/301/CO_SDOserver.c ****     ) {
 179:../CANopen/stack/301/CO_SDOserver.c ****         return CO_ERROR_NO;
 547              	 .loc 3 179 0
 548 002a 0023     	 movs r3,#0
 549 002c 4DE0     	 b .L27
 550              	.L26:
 180:../CANopen/stack/301/CO_SDOserver.c ****     }
 181:../CANopen/stack/301/CO_SDOserver.c ****     /* store variables */
 182:../CANopen/stack/301/CO_SDOserver.c ****     SDO->COB_IDClientToServer = COB_IDClientToServer;
 551              	 .loc 3 182 0
 552 002e FB68     	 ldr r3,[r7,#12]
 553 0030 3A6A     	 ldr r2,[r7,#32]
 554 0032 DA64     	 str r2,[r3,#76]
 183:../CANopen/stack/301/CO_SDOserver.c ****     SDO->COB_IDServerToClient = COB_IDServerToClient;
 555              	 .loc 3 183 0
 556 0034 FB68     	 ldr r3,[r7,#12]
 557 0036 7A6A     	 ldr r2,[r7,#36]
 558 0038 1A65     	 str r2,[r3,#80]
 184:../CANopen/stack/301/CO_SDOserver.c **** #endif
 185:../CANopen/stack/301/CO_SDOserver.c **** 
 186:../CANopen/stack/301/CO_SDOserver.c ****     /* verify valid bit */
 187:../CANopen/stack/301/CO_SDOserver.c ****     uint16_t idC2S = ((COB_IDClientToServer & 0x80000000L) == 0) ?
 559              	 .loc 3 187 0
 560 003a 3B6A     	 ldr r3,[r7,#32]
 561 003c 002B     	 cmp r3,#0
 562 003e 02DB     	 blt .L28
 563              	 .loc 3 187 0 is_stmt 0 discriminator 1
 564 0040 3B6A     	 ldr r3,[r7,#32]
 565 0042 9BB2     	 uxth r3,r3
 566 0044 00E0     	 b .L29
 567              	.L28:
 568              	 .loc 3 187 0 discriminator 2
 569 0046 0023     	 movs r3,#0
 570              	.L29:
 571              	 .loc 3 187 0 discriminator 4
 572 0048 FB82     	 strh r3,[r7,#22]
 188:../CANopen/stack/301/CO_SDOserver.c ****                      (uint16_t)COB_IDClientToServer : 0;
 189:../CANopen/stack/301/CO_SDOserver.c ****     uint16_t idS2C = ((COB_IDServerToClient & 0x80000000L) == 0) ?
 573              	 .loc 3 189 0 is_stmt 1 discriminator 4
 574 004a 7B6A     	 ldr r3,[r7,#36]
 575 004c 002B     	 cmp r3,#0
 576 004e 02DB     	 blt .L30
 577              	 .loc 3 189 0 is_stmt 0 discriminator 1
 578 0050 7B6A     	 ldr r3,[r7,#36]
 579 0052 9BB2     	 uxth r3,r3
 580 0054 00E0     	 b .L31
 581              	.L30:
 582              	 .loc 3 189 0 discriminator 2
 583 0056 0023     	 movs r3,#0
 584              	.L31:
 585              	 .loc 3 189 0 discriminator 4
 586 0058 BB82     	 strh r3,[r7,#20]
 190:../CANopen/stack/301/CO_SDOserver.c ****                      (uint16_t)COB_IDServerToClient : 0;
 191:../CANopen/stack/301/CO_SDOserver.c ****     if (idC2S != 0 && idS2C != 0) {
 587              	 .loc 3 191 0 is_stmt 1 discriminator 4
 588 005a FB8A     	 ldrh r3,[r7,#22]
 589 005c 002B     	 cmp r3,#0
 590 005e 06D0     	 beq .L32
 591              	 .loc 3 191 0 is_stmt 0 discriminator 1
 592 0060 BB8A     	 ldrh r3,[r7,#20]
 593 0062 002B     	 cmp r3,#0
 594 0064 03D0     	 beq .L32
 192:../CANopen/stack/301/CO_SDOserver.c ****         SDO->valid = true;
 595              	 .loc 3 192 0 is_stmt 1
 596 0066 FB68     	 ldr r3,[r7,#12]
 597 0068 0122     	 movs r2,#1
 598 006a 1A61     	 str r2,[r3,#16]
 599 006c 06E0     	 b .L33
 600              	.L32:
 193:../CANopen/stack/301/CO_SDOserver.c ****     }
 194:../CANopen/stack/301/CO_SDOserver.c ****     else {
 195:../CANopen/stack/301/CO_SDOserver.c ****         idC2S = 0;
 601              	 .loc 3 195 0
 602 006e 0023     	 movs r3,#0
 603 0070 FB82     	 strh r3,[r7,#22]
 196:../CANopen/stack/301/CO_SDOserver.c ****         idS2C = 0;
 604              	 .loc 3 196 0
 605 0072 0023     	 movs r3,#0
 606 0074 BB82     	 strh r3,[r7,#20]
 197:../CANopen/stack/301/CO_SDOserver.c ****         SDO->valid = false;
 607              	 .loc 3 197 0
 608 0076 FB68     	 ldr r3,[r7,#12]
 609 0078 0022     	 movs r2,#0
 610 007a 1A61     	 str r2,[r3,#16]
 611              	.L33:
 198:../CANopen/stack/301/CO_SDOserver.c ****     }
 199:../CANopen/stack/301/CO_SDOserver.c **** 
 200:../CANopen/stack/301/CO_SDOserver.c ****     /* configure SDO server CAN reception */
 201:../CANopen/stack/301/CO_SDOserver.c ****     CO_ReturnError_t ret = CO_CANrxBufferInit(
 612              	 .loc 3 201 0
 613 007c F988     	 ldrh r1,[r7,#6]
 614 007e FA8A     	 ldrh r2,[r7,#22]
 615 0080 0023     	 movs r3,#0
 616 0082 0093     	 str r3,[sp]
 617 0084 FB68     	 ldr r3,[r7,#12]
 618 0086 0193     	 str r3,[sp,#4]
 619 0088 124B     	 ldr r3,.L35
 620 008a 0293     	 str r3,[sp,#8]
 621 008c B868     	 ldr r0,[r7,#8]
 622 008e 40F2FF73 	 movw r3,#2047
 623 0092 FFF7FEFF 	 bl CO_CANrxBufferInit
 624 0096 0346     	 mov r3,r0
 625 0098 FB74     	 strb r3,[r7,#19]
 202:../CANopen/stack/301/CO_SDOserver.c ****             CANdevRx,               /* CAN device */
 203:../CANopen/stack/301/CO_SDOserver.c ****             CANdevRxIdx,            /* rx buffer index */
 204:../CANopen/stack/301/CO_SDOserver.c ****             idC2S,                  /* CAN identifier */
 205:../CANopen/stack/301/CO_SDOserver.c ****             0x7FF,                  /* mask */
 206:../CANopen/stack/301/CO_SDOserver.c ****             0,                      /* rtr */
 207:../CANopen/stack/301/CO_SDOserver.c ****             (void*)SDO,             /* object passed to receive function */
 208:../CANopen/stack/301/CO_SDOserver.c ****             CO_SDO_receive);        /* this function will process rx msg */
 209:../CANopen/stack/301/CO_SDOserver.c **** 
 210:../CANopen/stack/301/CO_SDOserver.c ****     /* configure SDO server CAN transmission */
 211:../CANopen/stack/301/CO_SDOserver.c ****     SDO->CANtxBuff = CO_CANtxBufferInit(
 626              	 .loc 3 211 0
 627 009a FB68     	 ldr r3,[r7,#12]
 628 009c 1868     	 ldr r0,[r3]
 629 009e B988     	 ldrh r1,[r7,#4]
 630 00a0 BA8A     	 ldrh r2,[r7,#20]
 631 00a2 0823     	 movs r3,#8
 632 00a4 0093     	 str r3,[sp]
 633 00a6 0023     	 movs r3,#0
 634 00a8 0193     	 str r3,[sp,#4]
 635 00aa 0023     	 movs r3,#0
 636 00ac FFF7FEFF 	 bl CO_CANtxBufferInit
 637 00b0 0246     	 mov r2,r0
 638 00b2 FB68     	 ldr r3,[r7,#12]
 639 00b4 5A60     	 str r2,[r3,#4]
 212:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANdevTx,          /* CAN device */
 213:../CANopen/stack/301/CO_SDOserver.c ****             CANdevTxIdx,            /* index of buffer inside CAN module */
 214:../CANopen/stack/301/CO_SDOserver.c ****             idS2C,                  /* CAN identifier */
 215:../CANopen/stack/301/CO_SDOserver.c ****             0,                      /* rtr */
 216:../CANopen/stack/301/CO_SDOserver.c ****             8,                      /* number of data bytes */
 217:../CANopen/stack/301/CO_SDOserver.c ****             0);                     /* synchronous message flag bit */
 218:../CANopen/stack/301/CO_SDOserver.c **** 
 219:../CANopen/stack/301/CO_SDOserver.c ****     if (SDO->CANtxBuff == NULL) {
 640              	 .loc 3 219 0
 641 00b6 FB68     	 ldr r3,[r7,#12]
 642 00b8 5B68     	 ldr r3,[r3,#4]
 643 00ba 002B     	 cmp r3,#0
 644 00bc 04D1     	 bne .L34
 220:../CANopen/stack/301/CO_SDOserver.c ****         ret = CO_ERROR_ILLEGAL_ARGUMENT;
 645              	 .loc 3 220 0
 646 00be FF23     	 movs r3,#255
 647 00c0 FB74     	 strb r3,[r7,#19]
 221:../CANopen/stack/301/CO_SDOserver.c ****         SDO->valid = false;
 648              	 .loc 3 221 0
 649 00c2 FB68     	 ldr r3,[r7,#12]
 650 00c4 0022     	 movs r2,#0
 651 00c6 1A61     	 str r2,[r3,#16]
 652              	.L34:
 222:../CANopen/stack/301/CO_SDOserver.c ****     }
 223:../CANopen/stack/301/CO_SDOserver.c **** 
 224:../CANopen/stack/301/CO_SDOserver.c ****     return ret;
 653              	 .loc 3 224 0
 654 00c8 FB7C     	 ldrb r3,[r7,#19]
 655              	.L27:
 656 00ca 5BB2     	 sxtb r3,r3
 225:../CANopen/stack/301/CO_SDOserver.c **** }
 657              	 .loc 3 225 0
 658 00cc 1846     	 mov r0,r3
 659 00ce 1837     	 adds r7,r7,#24
 660              	.LCFI52:
 661              	 .cfi_def_cfa_offset 8
 662 00d0 BD46     	 mov sp,r7
 663              	.LCFI53:
 664              	 .cfi_def_cfa_register 13
 665              	 
 666 00d2 80BD     	 pop {r7,pc}
 667              	.L36:
 668              	 .align 2
 669              	.L35:
 670 00d4 00000000 	 .word CO_SDO_receive
 671              	 .cfi_endproc
 672              	.LFE34:
 674              	 .section .text.OD_write_1201_additional,"ax",%progbits
 675              	 .align 2
 676              	 .thumb
 677              	 .thumb_func
 679              	OD_write_1201_additional:
 680              	.LFB35:
 226:../CANopen/stack/301/CO_SDOserver.c **** 
 227:../CANopen/stack/301/CO_SDOserver.c **** 
 228:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_OD_DYNAMIC
 229:../CANopen/stack/301/CO_SDOserver.c **** /*
 230:../CANopen/stack/301/CO_SDOserver.c ****  * Custom function for writing OD object _SDO server parameter_, additional
 231:../CANopen/stack/301/CO_SDOserver.c ****  * channels
 232:../CANopen/stack/301/CO_SDOserver.c ****  *
 233:../CANopen/stack/301/CO_SDOserver.c ****  * For more information see file CO_ODinterface.h, OD_IO_t.
 234:../CANopen/stack/301/CO_SDOserver.c ****  */
 235:../CANopen/stack/301/CO_SDOserver.c **** static ODR_t OD_write_1201_additional(OD_stream_t *stream, const void *buf,
 236:../CANopen/stack/301/CO_SDOserver.c ****                                       OD_size_t count, OD_size_t *countWritten)
 237:../CANopen/stack/301/CO_SDOserver.c **** {
 681              	 .loc 3 237 0
 682              	 .cfi_startproc
 683              	 
 684              	 
 685 0000 B0B5     	 push {r4,r5,r7,lr}
 686              	.LCFI54:
 687              	 .cfi_def_cfa_offset 16
 688              	 .cfi_offset 4,-16
 689              	 .cfi_offset 5,-12
 690              	 .cfi_offset 7,-8
 691              	 .cfi_offset 14,-4
 692 0002 8EB0     	 sub sp,sp,#56
 693              	.LCFI55:
 694              	 .cfi_def_cfa_offset 72
 695 0004 02AF     	 add r7,sp,#8
 696              	.LCFI56:
 697              	 .cfi_def_cfa 7,64
 698 0006 F860     	 str r0,[r7,#12]
 699 0008 B960     	 str r1,[r7,#8]
 700 000a 7A60     	 str r2,[r7,#4]
 701 000c 3B60     	 str r3,[r7]
 238:../CANopen/stack/301/CO_SDOserver.c ****     /* "count" is already verified in *_init() function */
 239:../CANopen/stack/301/CO_SDOserver.c ****     if (stream == NULL || buf == NULL || countWritten == NULL) {
 702              	 .loc 3 239 0
 703 000e FB68     	 ldr r3,[r7,#12]
 704 0010 002B     	 cmp r3,#0
 705 0012 05D0     	 beq .L38
 706              	 .loc 3 239 0 is_stmt 0 discriminator 1
 707 0014 BB68     	 ldr r3,[r7,#8]
 708 0016 002B     	 cmp r3,#0
 709 0018 02D0     	 beq .L38
 710              	 .loc 3 239 0 discriminator 2
 711 001a 3B68     	 ldr r3,[r7]
 712 001c 002B     	 cmp r3,#0
 713 001e 01D1     	 bne .L39
 714              	.L38:
 240:../CANopen/stack/301/CO_SDOserver.c ****         return ODR_DEV_INCOMPAT;
 715              	 .loc 3 240 0 is_stmt 1
 716 0020 0923     	 movs r3,#9
 717 0022 F7E0     	 b .L40
 718              	.L39:
 241:../CANopen/stack/301/CO_SDOserver.c ****     }
 242:../CANopen/stack/301/CO_SDOserver.c **** 
 243:../CANopen/stack/301/CO_SDOserver.c ****     CO_SDOserver_t *SDO = (CO_SDOserver_t *)stream->object;
 719              	 .loc 3 243 0
 720 0024 FB68     	 ldr r3,[r7,#12]
 721 0026 5B68     	 ldr r3,[r3,#4]
 722 0028 FB62     	 str r3,[r7,#44]
 244:../CANopen/stack/301/CO_SDOserver.c **** 
 245:../CANopen/stack/301/CO_SDOserver.c ****     switch (stream->subIndex) {
 723              	 .loc 3 245 0
 724 002a FB68     	 ldr r3,[r7,#12]
 725 002c 5B7C     	 ldrb r3,[r3,#17]
 726 002e 032B     	 cmp r3,#3
 727 0030 00F2E780 	 bhi .L41
 728 0034 01A2     	 adr r2,.L43
 729 0036 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 730 003a 00BF     	 .p2align 2
 731              	.L43:
 732 003c 4D000000 	 .word .L42+1
 733 0040 51000000 	 .word .L44+1
 734 0044 17010000 	 .word .L45+1
 735 0048 DB010000 	 .word .L46+1
 736              	 .p2align 1
 737              	.L42:
 246:../CANopen/stack/301/CO_SDOserver.c ****         case 0: /* Highest sub-index supported */
 247:../CANopen/stack/301/CO_SDOserver.c ****             return ODR_READONLY;
 738              	 .loc 3 247 0
 739 004c 0423     	 movs r3,#4
 740 004e E1E0     	 b .L40
 741              	.L44:
 742              	.LBB2:
 248:../CANopen/stack/301/CO_SDOserver.c **** 
 249:../CANopen/stack/301/CO_SDOserver.c ****         case 1: { /* COB-ID client -> server */
 250:../CANopen/stack/301/CO_SDOserver.c ****             uint32_t COB_ID = CO_getUint32(buf);
 743              	 .loc 3 250 0
 744 0050 B868     	 ldr r0,[r7,#8]
 745 0052 FFF7FEFF 	 bl CO_getUint32
 746 0056 B862     	 str r0,[r7,#40]
 251:../CANopen/stack/301/CO_SDOserver.c ****             uint16_t CAN_ID = (uint16_t)(COB_ID & 0x7FF);
 747              	 .loc 3 251 0
 748 0058 BB6A     	 ldr r3,[r7,#40]
 749 005a 9BB2     	 uxth r3,r3
 750 005c C3F30A03 	 ubfx r3,r3,#0,#11
 751 0060 FB84     	 strh r3,[r7,#38]
 252:../CANopen/stack/301/CO_SDOserver.c ****             uint16_t CAN_ID_cur = (uint16_t)(SDO->COB_IDClientToServer & 0x7FF);
 752              	 .loc 3 252 0
 753 0062 FB6A     	 ldr r3,[r7,#44]
 754 0064 DB6C     	 ldr r3,[r3,#76]
 755 0066 9BB2     	 uxth r3,r3
 756 0068 C3F30A03 	 ubfx r3,r3,#0,#11
 757 006c BB84     	 strh r3,[r7,#36]
 253:../CANopen/stack/301/CO_SDOserver.c ****             bool_t valid = (COB_ID & 0x80000000) == 0;
 758              	 .loc 3 253 0
 759 006e BB6A     	 ldr r3,[r7,#40]
 760 0070 DB43     	 mvns r3,r3
 761 0072 DB0F     	 lsrs r3,r3,#31
 762 0074 DBB2     	 uxtb r3,r3
 763 0076 3B62     	 str r3,[r7,#32]
 254:../CANopen/stack/301/CO_SDOserver.c **** 
 255:../CANopen/stack/301/CO_SDOserver.c ****             /* SDO client must not be valid when changing COB_ID */
 256:../CANopen/stack/301/CO_SDOserver.c ****             if ((COB_ID & 0x3FFFF800) != 0
 764              	 .loc 3 256 0
 765 0078 BA6A     	 ldr r2,[r7,#40]
 766 007a 694B     	 ldr r3,.L65
 767 007c 1340     	 ands r3,r3,r2
 768 007e 002B     	 cmp r3,#0
 769 0080 34D1     	 bne .L47
 257:../CANopen/stack/301/CO_SDOserver.c ****                 || (valid && SDO->valid && CAN_ID != CAN_ID_cur)
 770              	 .loc 3 257 0
 771 0082 3B6A     	 ldr r3,[r7,#32]
 772 0084 002B     	 cmp r3,#0
 773 0086 07D0     	 beq .L48
 774              	 .loc 3 257 0 is_stmt 0 discriminator 1
 775 0088 FB6A     	 ldr r3,[r7,#44]
 776 008a 1B69     	 ldr r3,[r3,#16]
 777 008c 002B     	 cmp r3,#0
 778 008e 03D0     	 beq .L48
 779              	 .loc 3 257 0 discriminator 2
 780 0090 FA8C     	 ldrh r2,[r7,#38]
 781 0092 BB8C     	 ldrh r3,[r7,#36]
 782 0094 9A42     	 cmp r2,r3
 783 0096 29D1     	 bne .L47
 784              	.L48:
 258:../CANopen/stack/301/CO_SDOserver.c ****                 || (valid && CO_IS_RESTRICTED_CAN_ID(CAN_ID))
 785              	 .loc 3 258 0 is_stmt 1
 786 0098 3B6A     	 ldr r3,[r7,#32]
 787 009a 002B     	 cmp r3,#0
 788 009c 28D0     	 beq .L49
 789              	 .loc 3 258 0 is_stmt 0 discriminator 1
 790 009e FB8C     	 ldrh r3,[r7,#38]
 791 00a0 7F2B     	 cmp r3,#127
 792 00a2 23D9     	 bls .L47
 793              	 .loc 3 258 0 discriminator 2
 794 00a4 FB8C     	 ldrh r3,[r7,#38]
 795 00a6 B3F5807F 	 cmp r3,#256
 796 00aa 03D9     	 bls .L50
 797              	 .loc 3 258 0 discriminator 3
 798 00ac FB8C     	 ldrh r3,[r7,#38]
 799 00ae B3F5C07F 	 cmp r3,#384
 800 00b2 1BD9     	 bls .L47
 801              	.L50:
 802              	 .loc 3 258 0 discriminator 5
 803 00b4 FB8C     	 ldrh r3,[r7,#38]
 804 00b6 B3F5B06F 	 cmp r3,#1408
 805 00ba 03D9     	 bls .L51
 806              	 .loc 3 258 0 discriminator 6
 807 00bc FB8C     	 ldrh r3,[r7,#38]
 808 00be B3F5C06F 	 cmp r3,#1536
 809 00c2 13D3     	 bcc .L47
 810              	.L51:
 811              	 .loc 3 258 0 discriminator 8
 812 00c4 FB8C     	 ldrh r3,[r7,#38]
 813 00c6 B3F5C06F 	 cmp r3,#1536
 814 00ca 03D9     	 bls .L52
 815              	 .loc 3 258 0 discriminator 9
 816 00cc FB8C     	 ldrh r3,[r7,#38]
 817 00ce B3F5D06F 	 cmp r3,#1664
 818 00d2 0BD3     	 bcc .L47
 819              	.L52:
 820              	 .loc 3 258 0 discriminator 11
 821 00d4 FB8C     	 ldrh r3,[r7,#38]
 822 00d6 B3F5DC6F 	 cmp r3,#1760
 823 00da 03D3     	 bcc .L53
 824              	 .loc 3 258 0 discriminator 12
 825 00dc FB8C     	 ldrh r3,[r7,#38]
 826 00de B3F5E06F 	 cmp r3,#1792
 827 00e2 03D3     	 bcc .L47
 828              	.L53:
 829              	 .loc 3 258 0 discriminator 14
 830 00e4 FB8C     	 ldrh r3,[r7,#38]
 831 00e6 B3F5E06F 	 cmp r3,#1792
 832 00ea 01D9     	 bls .L49
 833              	.L47:
 259:../CANopen/stack/301/CO_SDOserver.c ****             ) {
 260:../CANopen/stack/301/CO_SDOserver.c ****                 return ODR_INVALID_VALUE;
 834              	 .loc 3 260 0 is_stmt 1
 835 00ec 0F23     	 movs r3,#15
 836 00ee 91E0     	 b .L40
 837              	.L49:
 261:../CANopen/stack/301/CO_SDOserver.c ****             }
 262:../CANopen/stack/301/CO_SDOserver.c ****             CO_SDOserver_init_canRxTx(SDO,
 838              	 .loc 3 262 0
 839 00f0 FB6A     	 ldr r3,[r7,#44]
 840 00f2 596C     	 ldr r1,[r3,#68]
 841 00f4 FB6A     	 ldr r3,[r7,#44]
 842 00f6 B3F84850 	 ldrh r5,[r3,#72]
 843 00fa FB6A     	 ldr r3,[r7,#44]
 844 00fc B3F84A40 	 ldrh r4,[r3,#74]
 845 0100 FB6A     	 ldr r3,[r7,#44]
 846 0102 1B6D     	 ldr r3,[r3,#80]
 847 0104 BA6A     	 ldr r2,[r7,#40]
 848 0106 0092     	 str r2,[sp]
 849 0108 0193     	 str r3,[sp,#4]
 850 010a F86A     	 ldr r0,[r7,#44]
 851 010c 2A46     	 mov r2,r5
 852 010e 2346     	 mov r3,r4
 853 0110 FFF7FEFF 	 bl CO_SDOserver_init_canRxTx
 263:../CANopen/stack/301/CO_SDOserver.c ****                                       SDO->CANdevRx,
 264:../CANopen/stack/301/CO_SDOserver.c ****                                       SDO->CANdevRxIdx,
 265:../CANopen/stack/301/CO_SDOserver.c ****                                       SDO->CANdevTxIdx,
 266:../CANopen/stack/301/CO_SDOserver.c ****                                       COB_ID,
 267:../CANopen/stack/301/CO_SDOserver.c ****                                       SDO->COB_IDServerToClient);
 268:../CANopen/stack/301/CO_SDOserver.c ****             break;
 854              	 .loc 3 268 0
 855 0114 77E0     	 b .L54
 856              	.L45:
 857              	.LBE2:
 858              	.LBB3:
 269:../CANopen/stack/301/CO_SDOserver.c ****         }
 270:../CANopen/stack/301/CO_SDOserver.c **** 
 271:../CANopen/stack/301/CO_SDOserver.c ****         case 2: { /* COB-ID server -> client */
 272:../CANopen/stack/301/CO_SDOserver.c ****             uint32_t COB_ID = CO_getUint32(buf);
 859              	 .loc 3 272 0
 860 0116 B868     	 ldr r0,[r7,#8]
 861 0118 FFF7FEFF 	 bl CO_getUint32
 862 011c F861     	 str r0,[r7,#28]
 273:../CANopen/stack/301/CO_SDOserver.c ****             uint16_t CAN_ID = (uint16_t)(COB_ID & 0x7FF);
 863              	 .loc 3 273 0
 864 011e FB69     	 ldr r3,[r7,#28]
 865 0120 9BB2     	 uxth r3,r3
 866 0122 C3F30A03 	 ubfx r3,r3,#0,#11
 867 0126 7B83     	 strh r3,[r7,#26]
 274:../CANopen/stack/301/CO_SDOserver.c ****             uint16_t CAN_ID_cur = (uint16_t)(SDO->COB_IDServerToClient & 0x7FF);
 868              	 .loc 3 274 0
 869 0128 FB6A     	 ldr r3,[r7,#44]
 870 012a 1B6D     	 ldr r3,[r3,#80]
 871 012c 9BB2     	 uxth r3,r3
 872 012e C3F30A03 	 ubfx r3,r3,#0,#11
 873 0132 3B83     	 strh r3,[r7,#24]
 275:../CANopen/stack/301/CO_SDOserver.c ****             bool_t valid = (COB_ID & 0x80000000) == 0;
 874              	 .loc 3 275 0
 875 0134 FB69     	 ldr r3,[r7,#28]
 876 0136 DB43     	 mvns r3,r3
 877 0138 DB0F     	 lsrs r3,r3,#31
 878 013a DBB2     	 uxtb r3,r3
 879 013c 7B61     	 str r3,[r7,#20]
 276:../CANopen/stack/301/CO_SDOserver.c **** 
 277:../CANopen/stack/301/CO_SDOserver.c ****             /* SDO client must not be valid when changing COB_ID */
 278:../CANopen/stack/301/CO_SDOserver.c ****             if ((COB_ID & 0x3FFFF800) != 0
 880              	 .loc 3 278 0
 881 013e FA69     	 ldr r2,[r7,#28]
 882 0140 374B     	 ldr r3,.L65
 883 0142 1340     	 ands r3,r3,r2
 884 0144 002B     	 cmp r3,#0
 885 0146 34D1     	 bne .L55
 279:../CANopen/stack/301/CO_SDOserver.c ****                 || (valid && SDO->valid && CAN_ID != CAN_ID_cur)
 886              	 .loc 3 279 0
 887 0148 7B69     	 ldr r3,[r7,#20]
 888 014a 002B     	 cmp r3,#0
 889 014c 07D0     	 beq .L56
 890              	 .loc 3 279 0 is_stmt 0 discriminator 1
 891 014e FB6A     	 ldr r3,[r7,#44]
 892 0150 1B69     	 ldr r3,[r3,#16]
 893 0152 002B     	 cmp r3,#0
 894 0154 03D0     	 beq .L56
 895              	 .loc 3 279 0 discriminator 2
 896 0156 7A8B     	 ldrh r2,[r7,#26]
 897 0158 3B8B     	 ldrh r3,[r7,#24]
 898 015a 9A42     	 cmp r2,r3
 899 015c 29D1     	 bne .L55
 900              	.L56:
 280:../CANopen/stack/301/CO_SDOserver.c ****                 || (valid && CO_IS_RESTRICTED_CAN_ID(CAN_ID))
 901              	 .loc 3 280 0 is_stmt 1
 902 015e 7B69     	 ldr r3,[r7,#20]
 903 0160 002B     	 cmp r3,#0
 904 0162 28D0     	 beq .L57
 905              	 .loc 3 280 0 is_stmt 0 discriminator 1
 906 0164 7B8B     	 ldrh r3,[r7,#26]
 907 0166 7F2B     	 cmp r3,#127
 908 0168 23D9     	 bls .L55
 909              	 .loc 3 280 0 discriminator 2
 910 016a 7B8B     	 ldrh r3,[r7,#26]
 911 016c B3F5807F 	 cmp r3,#256
 912 0170 03D9     	 bls .L58
 913              	 .loc 3 280 0 discriminator 3
 914 0172 7B8B     	 ldrh r3,[r7,#26]
 915 0174 B3F5C07F 	 cmp r3,#384
 916 0178 1BD9     	 bls .L55
 917              	.L58:
 918              	 .loc 3 280 0 discriminator 5
 919 017a 7B8B     	 ldrh r3,[r7,#26]
 920 017c B3F5B06F 	 cmp r3,#1408
 921 0180 03D9     	 bls .L59
 922              	 .loc 3 280 0 discriminator 6
 923 0182 7B8B     	 ldrh r3,[r7,#26]
 924 0184 B3F5C06F 	 cmp r3,#1536
 925 0188 13D3     	 bcc .L55
 926              	.L59:
 927              	 .loc 3 280 0 discriminator 8
 928 018a 7B8B     	 ldrh r3,[r7,#26]
 929 018c B3F5C06F 	 cmp r3,#1536
 930 0190 03D9     	 bls .L60
 931              	 .loc 3 280 0 discriminator 9
 932 0192 7B8B     	 ldrh r3,[r7,#26]
 933 0194 B3F5D06F 	 cmp r3,#1664
 934 0198 0BD3     	 bcc .L55
 935              	.L60:
 936              	 .loc 3 280 0 discriminator 11
 937 019a 7B8B     	 ldrh r3,[r7,#26]
 938 019c B3F5DC6F 	 cmp r3,#1760
 939 01a0 03D3     	 bcc .L61
 940              	 .loc 3 280 0 discriminator 12
 941 01a2 7B8B     	 ldrh r3,[r7,#26]
 942 01a4 B3F5E06F 	 cmp r3,#1792
 943 01a8 03D3     	 bcc .L55
 944              	.L61:
 945              	 .loc 3 280 0 discriminator 14
 946 01aa 7B8B     	 ldrh r3,[r7,#26]
 947 01ac B3F5E06F 	 cmp r3,#1792
 948 01b0 01D9     	 bls .L57
 949              	.L55:
 281:../CANopen/stack/301/CO_SDOserver.c ****             ) {
 282:../CANopen/stack/301/CO_SDOserver.c ****                 return ODR_INVALID_VALUE;
 950              	 .loc 3 282 0 is_stmt 1
 951 01b2 0F23     	 movs r3,#15
 952 01b4 2EE0     	 b .L40
 953              	.L57:
 283:../CANopen/stack/301/CO_SDOserver.c ****             }
 284:../CANopen/stack/301/CO_SDOserver.c ****             CO_SDOserver_init_canRxTx(SDO,
 954              	 .loc 3 284 0
 955 01b6 FB6A     	 ldr r3,[r7,#44]
 956 01b8 596C     	 ldr r1,[r3,#68]
 957 01ba FB6A     	 ldr r3,[r7,#44]
 958 01bc B3F84820 	 ldrh r2,[r3,#72]
 959 01c0 FB6A     	 ldr r3,[r7,#44]
 960 01c2 B3F84A40 	 ldrh r4,[r3,#74]
 961 01c6 FB6A     	 ldr r3,[r7,#44]
 962 01c8 DB6C     	 ldr r3,[r3,#76]
 963 01ca 0093     	 str r3,[sp]
 964 01cc FB69     	 ldr r3,[r7,#28]
 965 01ce 0193     	 str r3,[sp,#4]
 966 01d0 F86A     	 ldr r0,[r7,#44]
 967 01d2 2346     	 mov r3,r4
 968 01d4 FFF7FEFF 	 bl CO_SDOserver_init_canRxTx
 285:../CANopen/stack/301/CO_SDOserver.c ****                                       SDO->CANdevRx,
 286:../CANopen/stack/301/CO_SDOserver.c ****                                       SDO->CANdevRxIdx,
 287:../CANopen/stack/301/CO_SDOserver.c ****                                       SDO->CANdevTxIdx,
 288:../CANopen/stack/301/CO_SDOserver.c ****                                       SDO->COB_IDClientToServer,
 289:../CANopen/stack/301/CO_SDOserver.c ****                                       COB_ID);
 290:../CANopen/stack/301/CO_SDOserver.c ****             break;
 969              	 .loc 3 290 0
 970 01d8 15E0     	 b .L54
 971              	.L46:
 972              	.LBE3:
 973              	.LBB4:
 291:../CANopen/stack/301/CO_SDOserver.c ****         }
 292:../CANopen/stack/301/CO_SDOserver.c **** 
 293:../CANopen/stack/301/CO_SDOserver.c ****         case 3: { /* Node-ID of the SDO server */
 294:../CANopen/stack/301/CO_SDOserver.c ****             if (count != 1) {
 974              	 .loc 3 294 0
 975 01da 7B68     	 ldr r3,[r7,#4]
 976 01dc 012B     	 cmp r3,#1
 977 01de 01D0     	 beq .L62
 295:../CANopen/stack/301/CO_SDOserver.c ****                 return ODR_TYPE_MISMATCH;
 978              	 .loc 3 295 0
 979 01e0 0B23     	 movs r3,#11
 980 01e2 17E0     	 b .L40
 981              	.L62:
 296:../CANopen/stack/301/CO_SDOserver.c ****             }
 297:../CANopen/stack/301/CO_SDOserver.c ****             uint8_t nodeId = CO_getUint8(buf);
 982              	 .loc 3 297 0
 983 01e4 B868     	 ldr r0,[r7,#8]
 984 01e6 FFF7FEFF 	 bl CO_getUint8
 985 01ea 0346     	 mov r3,r0
 986 01ec FB74     	 strb r3,[r7,#19]
 298:../CANopen/stack/301/CO_SDOserver.c ****             if (nodeId < 1 || nodeId > 127) {
 987              	 .loc 3 298 0
 988 01ee FB7C     	 ldrb r3,[r7,#19]
 989 01f0 002B     	 cmp r3,#0
 990 01f2 03D0     	 beq .L63
 991              	 .loc 3 298 0 is_stmt 0 discriminator 1
 992 01f4 FB7C     	 ldrb r3,[r7,#19]
 993 01f6 5BB2     	 sxtb r3,r3
 994 01f8 002B     	 cmp r3,#0
 995 01fa 01DA     	 bge .L64
 996              	.L63:
 299:../CANopen/stack/301/CO_SDOserver.c ****                 return ODR_INVALID_VALUE;
 997              	 .loc 3 299 0 is_stmt 1
 998 01fc 0F23     	 movs r3,#15
 999 01fe 09E0     	 b .L40
 1000              	.L64:
 300:../CANopen/stack/301/CO_SDOserver.c ****             }
 301:../CANopen/stack/301/CO_SDOserver.c ****             break;
 1001              	 .loc 3 301 0
 1002 0200 01E0     	 b .L54
 1003              	.L41:
 1004              	.LBE4:
 302:../CANopen/stack/301/CO_SDOserver.c ****         }
 303:../CANopen/stack/301/CO_SDOserver.c **** 
 304:../CANopen/stack/301/CO_SDOserver.c ****         default:
 305:../CANopen/stack/301/CO_SDOserver.c ****             return ODR_SUB_NOT_EXIST;
 1005              	 .loc 3 305 0
 1006 0202 0E23     	 movs r3,#14
 1007 0204 06E0     	 b .L40
 1008              	.L54:
 306:../CANopen/stack/301/CO_SDOserver.c ****     }
 307:../CANopen/stack/301/CO_SDOserver.c **** 
 308:../CANopen/stack/301/CO_SDOserver.c ****     /* write value to the original location in the Object Dictionary */
 309:../CANopen/stack/301/CO_SDOserver.c ****     return OD_writeOriginal(stream, buf, count, countWritten);
 1009              	 .loc 3 309 0
 1010 0206 F868     	 ldr r0,[r7,#12]
 1011 0208 B968     	 ldr r1,[r7,#8]
 1012 020a 7A68     	 ldr r2,[r7,#4]
 1013 020c 3B68     	 ldr r3,[r7]
 1014 020e FFF7FEFF 	 bl OD_writeOriginal
 1015 0212 0346     	 mov r3,r0
 1016              	.L40:
 1017 0214 5BB2     	 sxtb r3,r3
 310:../CANopen/stack/301/CO_SDOserver.c **** }
 1018              	 .loc 3 310 0
 1019 0216 1846     	 mov r0,r3
 1020 0218 3037     	 adds r7,r7,#48
 1021              	.LCFI57:
 1022              	 .cfi_def_cfa_offset 16
 1023 021a BD46     	 mov sp,r7
 1024              	.LCFI58:
 1025              	 .cfi_def_cfa_register 13
 1026              	 
 1027 021c B0BD     	 pop {r4,r5,r7,pc}
 1028              	.L66:
 1029 021e 00BF     	 .align 2
 1030              	.L65:
 1031 0220 00F8FF3F 	 .word 1073739776
 1032              	 .cfi_endproc
 1033              	.LFE35:
 1035              	 .section .text.CO_SDOserver_init,"ax",%progbits
 1036              	 .align 2
 1037              	 .global CO_SDOserver_init
 1038              	 .thumb
 1039              	 .thumb_func
 1041              	CO_SDOserver_init:
 1042              	.LFB36:
 311:../CANopen/stack/301/CO_SDOserver.c **** #endif /* (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_OD_DYNAMIC */
 312:../CANopen/stack/301/CO_SDOserver.c **** 
 313:../CANopen/stack/301/CO_SDOserver.c **** 
 314:../CANopen/stack/301/CO_SDOserver.c **** /******************************************************************************/
 315:../CANopen/stack/301/CO_SDOserver.c **** CO_ReturnError_t CO_SDOserver_init(CO_SDOserver_t *SDO,
 316:../CANopen/stack/301/CO_SDOserver.c ****                                    OD_t *OD,
 317:../CANopen/stack/301/CO_SDOserver.c ****                                    OD_entry_t *OD_1200_SDOsrvPar,
 318:../CANopen/stack/301/CO_SDOserver.c ****                                    uint8_t nodeId,
 319:../CANopen/stack/301/CO_SDOserver.c ****                                    uint16_t SDOtimeoutTime_ms,
 320:../CANopen/stack/301/CO_SDOserver.c ****                                    CO_CANmodule_t *CANdevRx,
 321:../CANopen/stack/301/CO_SDOserver.c ****                                    uint16_t CANdevRxIdx,
 322:../CANopen/stack/301/CO_SDOserver.c ****                                    CO_CANmodule_t *CANdevTx,
 323:../CANopen/stack/301/CO_SDOserver.c ****                                    uint16_t CANdevTxIdx,
 324:../CANopen/stack/301/CO_SDOserver.c ****                                    uint32_t *errInfo)
 325:../CANopen/stack/301/CO_SDOserver.c **** {
 1043              	 .loc 3 325 0
 1044              	 .cfi_startproc
 1045              	 
 1046              	 
 1047 0000 B0B5     	 push {r4,r5,r7,lr}
 1048              	.LCFI59:
 1049              	 .cfi_def_cfa_offset 16
 1050              	 .cfi_offset 4,-16
 1051              	 .cfi_offset 5,-12
 1052              	 .cfi_offset 7,-8
 1053              	 .cfi_offset 14,-4
 1054 0002 8CB0     	 sub sp,sp,#48
 1055              	.LCFI60:
 1056              	 .cfi_def_cfa_offset 64
 1057 0004 02AF     	 add r7,sp,#8
 1058              	.LCFI61:
 1059              	 .cfi_def_cfa 7,56
 1060 0006 F860     	 str r0,[r7,#12]
 1061 0008 B960     	 str r1,[r7,#8]
 1062 000a 7A60     	 str r2,[r7,#4]
 1063 000c FB70     	 strb r3,[r7,#3]
 326:../CANopen/stack/301/CO_SDOserver.c ****     /* verify arguments */
 327:../CANopen/stack/301/CO_SDOserver.c ****     if (SDO == NULL || OD == NULL || CANdevRx == NULL || CANdevTx == NULL) {
 1064              	 .loc 3 327 0
 1065 000e FB68     	 ldr r3,[r7,#12]
 1066 0010 002B     	 cmp r3,#0
 1067 0012 08D0     	 beq .L68
 1068              	 .loc 3 327 0 is_stmt 0 discriminator 1
 1069 0014 BB68     	 ldr r3,[r7,#8]
 1070 0016 002B     	 cmp r3,#0
 1071 0018 05D0     	 beq .L68
 1072              	 .loc 3 327 0 discriminator 2
 1073 001a FB6B     	 ldr r3,[r7,#60]
 1074 001c 002B     	 cmp r3,#0
 1075 001e 02D0     	 beq .L68
 1076              	 .loc 3 327 0 discriminator 3
 1077 0020 7B6C     	 ldr r3,[r7,#68]
 1078 0022 002B     	 cmp r3,#0
 1079 0024 01D1     	 bne .L69
 1080              	.L68:
 328:../CANopen/stack/301/CO_SDOserver.c ****         return CO_ERROR_ILLEGAL_ARGUMENT;
 1081              	 .loc 3 328 0 is_stmt 1
 1082 0026 FF23     	 movs r3,#255
 1083 0028 F7E0     	 b .L70
 1084              	.L69:
 329:../CANopen/stack/301/CO_SDOserver.c ****     }
 330:../CANopen/stack/301/CO_SDOserver.c **** 
 331:../CANopen/stack/301/CO_SDOserver.c ****     /* Configure object variables */
 332:../CANopen/stack/301/CO_SDOserver.c ****     SDO->OD = OD;
 1085              	 .loc 3 332 0
 1086 002a FB68     	 ldr r3,[r7,#12]
 1087 002c BA68     	 ldr r2,[r7,#8]
 1088 002e 9A60     	 str r2,[r3,#8]
 333:../CANopen/stack/301/CO_SDOserver.c ****     SDO->nodeId = nodeId;
 1089              	 .loc 3 333 0
 1090 0030 FB68     	 ldr r3,[r7,#12]
 1091 0032 FA78     	 ldrb r2,[r7,#3]
 1092 0034 1A73     	 strb r2,[r3,#12]
 334:../CANopen/stack/301/CO_SDOserver.c **** #if ((CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED)
 335:../CANopen/stack/301/CO_SDOserver.c ****     SDO->SDOtimeoutTime_us = (uint32_t)SDOtimeoutTime_ms * 1000;
 1093              	 .loc 3 335 0
 1094 0036 3B8F     	 ldrh r3,[r7,#56]
 1095 0038 4FF47A72 	 mov r2,#1000
 1096 003c 02FB03F2 	 mul r2,r2,r3
 1097 0040 FB68     	 ldr r3,[r7,#12]
 1098 0042 5A67     	 str r2,[r3,#116]
 336:../CANopen/stack/301/CO_SDOserver.c **** #endif
 337:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK
 338:../CANopen/stack/301/CO_SDOserver.c ****     SDO->block_SDOtimeoutTime_us = (uint32_t)SDOtimeoutTime_ms * 700;
 339:../CANopen/stack/301/CO_SDOserver.c **** #endif
 340:../CANopen/stack/301/CO_SDOserver.c ****     SDO->state = CO_SDO_ST_IDLE;
 1099              	 .loc 3 340 0
 1100 0044 FB68     	 ldr r3,[r7,#12]
 1101 0046 0022     	 movs r2,#0
 1102 0048 1A75     	 strb r2,[r3,#20]
 341:../CANopen/stack/301/CO_SDOserver.c **** 
 342:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_CALLBACK_PRE
 343:../CANopen/stack/301/CO_SDOserver.c ****     SDO->pFunctSignalPre = NULL;
 344:../CANopen/stack/301/CO_SDOserver.c ****     SDO->functSignalObjectPre = NULL;
 345:../CANopen/stack/301/CO_SDOserver.c **** #endif
 346:../CANopen/stack/301/CO_SDOserver.c **** 
 347:../CANopen/stack/301/CO_SDOserver.c ****     /* configure CAN identifiers and SDO server parameters if available */
 348:../CANopen/stack/301/CO_SDOserver.c ****     uint16_t CanId_ClientToServer, CanId_ServerToClient;
 349:../CANopen/stack/301/CO_SDOserver.c **** 
 350:../CANopen/stack/301/CO_SDOserver.c ****     if (OD_1200_SDOsrvPar == NULL) {
 1103              	 .loc 3 350 0
 1104 004a 7B68     	 ldr r3,[r7,#4]
 1105 004c 002B     	 cmp r3,#0
 1106 004e 16D1     	 bne .L71
 351:../CANopen/stack/301/CO_SDOserver.c ****         /* configure default SDO channel */
 352:../CANopen/stack/301/CO_SDOserver.c ****         if (nodeId < 1 || nodeId > 127) return CO_ERROR_ILLEGAL_ARGUMENT;
 1107              	 .loc 3 352 0
 1108 0050 FB78     	 ldrb r3,[r7,#3]
 1109 0052 002B     	 cmp r3,#0
 1110 0054 03D0     	 beq .L72
 1111              	 .loc 3 352 0 is_stmt 0 discriminator 2
 1112 0056 FB78     	 ldrb r3,[r7,#3]
 1113 0058 5BB2     	 sxtb r3,r3
 1114 005a 002B     	 cmp r3,#0
 1115 005c 01DA     	 bge .L73
 1116              	.L72:
 1117              	 .loc 3 352 0 discriminator 3
 1118 005e FF23     	 movs r3,#255
 1119 0060 DBE0     	 b .L70
 1120              	.L73:
 353:../CANopen/stack/301/CO_SDOserver.c **** 
 354:../CANopen/stack/301/CO_SDOserver.c ****         CanId_ClientToServer = CO_CAN_ID_SDO_CLI + nodeId;
 1121              	 .loc 3 354 0 is_stmt 1
 1122 0062 FB78     	 ldrb r3,[r7,#3]
 1123 0064 9BB2     	 uxth r3,r3
 1124 0066 03F5C063 	 add r3,r3,#1536
 1125 006a FB84     	 strh r3,[r7,#38]
 355:../CANopen/stack/301/CO_SDOserver.c ****         CanId_ServerToClient = CO_CAN_ID_SDO_SRV + nodeId;
 1126              	 .loc 3 355 0
 1127 006c FB78     	 ldrb r3,[r7,#3]
 1128 006e 9BB2     	 uxth r3,r3
 1129 0070 03F5B063 	 add r3,r3,#1408
 1130 0074 BB84     	 strh r3,[r7,#36]
 356:../CANopen/stack/301/CO_SDOserver.c ****         SDO->valid = true;
 1131              	 .loc 3 356 0
 1132 0076 FB68     	 ldr r3,[r7,#12]
 1133 0078 0122     	 movs r2,#1
 1134 007a 1A61     	 str r2,[r3,#16]
 1135 007c A5E0     	 b .L74
 1136              	.L71:
 1137              	.LBB5:
 357:../CANopen/stack/301/CO_SDOserver.c ****     }
 358:../CANopen/stack/301/CO_SDOserver.c ****     else {
 359:../CANopen/stack/301/CO_SDOserver.c ****         uint16_t OD_SDOsrvParIdx = OD_getIndex(OD_1200_SDOsrvPar);
 1138              	 .loc 3 359 0
 1139 007e 7868     	 ldr r0,[r7,#4]
 1140 0080 FFF7FEFF 	 bl OD_getIndex
 1141 0084 0346     	 mov r3,r0
 1142 0086 7B84     	 strh r3,[r7,#34]
 360:../CANopen/stack/301/CO_SDOserver.c **** 
 361:../CANopen/stack/301/CO_SDOserver.c ****         if (OD_SDOsrvParIdx == OD_H1200_SDO_SERVER_1_PARAM) {
 1143              	 .loc 3 361 0
 1144 0088 7B8C     	 ldrh r3,[r7,#34]
 1145 008a B3F5905F 	 cmp r3,#4608
 1146 008e 24D1     	 bne .L75
 362:../CANopen/stack/301/CO_SDOserver.c ****             /* configure default SDO channel and SDO server parameters for it */
 363:../CANopen/stack/301/CO_SDOserver.c ****             if (nodeId < 1 || nodeId > 127) return CO_ERROR_ILLEGAL_ARGUMENT;
 1147              	 .loc 3 363 0
 1148 0090 FB78     	 ldrb r3,[r7,#3]
 1149 0092 002B     	 cmp r3,#0
 1150 0094 03D0     	 beq .L76
 1151              	 .loc 3 363 0 is_stmt 0 discriminator 2
 1152 0096 FB78     	 ldrb r3,[r7,#3]
 1153 0098 5BB2     	 sxtb r3,r3
 1154 009a 002B     	 cmp r3,#0
 1155 009c 01DA     	 bge .L77
 1156              	.L76:
 1157              	 .loc 3 363 0 discriminator 3
 1158 009e FF23     	 movs r3,#255
 1159 00a0 BBE0     	 b .L70
 1160              	.L77:
 364:../CANopen/stack/301/CO_SDOserver.c **** 
 365:../CANopen/stack/301/CO_SDOserver.c ****             CanId_ClientToServer = CO_CAN_ID_SDO_CLI + nodeId;
 1161              	 .loc 3 365 0 is_stmt 1
 1162 00a2 FB78     	 ldrb r3,[r7,#3]
 1163 00a4 9BB2     	 uxth r3,r3
 1164 00a6 03F5C063 	 add r3,r3,#1536
 1165 00aa FB84     	 strh r3,[r7,#38]
 366:../CANopen/stack/301/CO_SDOserver.c ****             CanId_ServerToClient = CO_CAN_ID_SDO_SRV + nodeId;
 1166              	 .loc 3 366 0
 1167 00ac FB78     	 ldrb r3,[r7,#3]
 1168 00ae 9BB2     	 uxth r3,r3
 1169 00b0 03F5B063 	 add r3,r3,#1408
 1170 00b4 BB84     	 strh r3,[r7,#36]
 367:../CANopen/stack/301/CO_SDOserver.c ****             SDO->valid = true;
 1171              	 .loc 3 367 0
 1172 00b6 FB68     	 ldr r3,[r7,#12]
 1173 00b8 0122     	 movs r2,#1
 1174 00ba 1A61     	 str r2,[r3,#16]
 368:../CANopen/stack/301/CO_SDOserver.c **** 
 369:../CANopen/stack/301/CO_SDOserver.c ****             OD_set_u32(OD_1200_SDOsrvPar, 1, CanId_ClientToServer, true);
 1175              	 .loc 3 369 0
 1176 00bc FB8C     	 ldrh r3,[r7,#38]
 1177 00be 7868     	 ldr r0,[r7,#4]
 1178 00c0 0121     	 movs r1,#1
 1179 00c2 1A46     	 mov r2,r3
 1180 00c4 0123     	 movs r3,#1
 1181 00c6 FFF7FEFF 	 bl OD_set_u32
 370:../CANopen/stack/301/CO_SDOserver.c ****             OD_set_u32(OD_1200_SDOsrvPar, 2, CanId_ServerToClient, true);
 1182              	 .loc 3 370 0
 1183 00ca BB8C     	 ldrh r3,[r7,#36]
 1184 00cc 7868     	 ldr r0,[r7,#4]
 1185 00ce 0221     	 movs r1,#2
 1186 00d0 1A46     	 mov r2,r3
 1187 00d2 0123     	 movs r3,#1
 1188 00d4 FFF7FEFF 	 bl OD_set_u32
 1189 00d8 77E0     	 b .L74
 1190              	.L75:
 371:../CANopen/stack/301/CO_SDOserver.c ****         }
 372:../CANopen/stack/301/CO_SDOserver.c ****         else if (OD_SDOsrvParIdx > OD_H1200_SDO_SERVER_1_PARAM
 1191              	 .loc 3 372 0
 1192 00da 7B8C     	 ldrh r3,[r7,#34]
 1193 00dc B3F5905F 	 cmp r3,#4608
 1194 00e0 71D9     	 bls .L78
 373:../CANopen/stack/301/CO_SDOserver.c ****                 && OD_SDOsrvParIdx <= (OD_H1200_SDO_SERVER_1_PARAM + 0x7F)
 1195              	 .loc 3 373 0
 1196 00e2 7B8C     	 ldrh r3,[r7,#34]
 1197 00e4 B3F5945F 	 cmp r3,#4736
 1198 00e8 6DD2     	 bcs .L78
 1199              	.LBB6:
 374:../CANopen/stack/301/CO_SDOserver.c ****         ) {
 375:../CANopen/stack/301/CO_SDOserver.c ****             /* configure additional SDO channel and SDO server parameters for it */
 376:../CANopen/stack/301/CO_SDOserver.c ****             uint8_t maxSubIndex;
 377:../CANopen/stack/301/CO_SDOserver.c ****             uint32_t COB_IDClientToServer32, COB_IDServerToClient32;
 378:../CANopen/stack/301/CO_SDOserver.c **** 
 379:../CANopen/stack/301/CO_SDOserver.c ****             /* get and verify parameters from Object Dictionary (initial values) */
 380:../CANopen/stack/301/CO_SDOserver.c ****             ODR_t odRet0 = OD_get_u8(OD_1200_SDOsrvPar, 0, &maxSubIndex, true);
 1200              	 .loc 3 380 0
 1201 00ea 07F11D03 	 add r3,r7,#29
 1202 00ee 7868     	 ldr r0,[r7,#4]
 1203 00f0 0021     	 movs r1,#0
 1204 00f2 1A46     	 mov r2,r3
 1205 00f4 0123     	 movs r3,#1
 1206 00f6 FFF7FEFF 	 bl OD_get_u8
 1207 00fa 0346     	 mov r3,r0
 1208 00fc 87F82130 	 strb r3,[r7,#33]
 381:../CANopen/stack/301/CO_SDOserver.c ****             ODR_t odRet1 = OD_get_u32(OD_1200_SDOsrvPar, 1,
 1209              	 .loc 3 381 0
 1210 0100 07F11803 	 add r3,r7,#24
 1211 0104 7868     	 ldr r0,[r7,#4]
 1212 0106 0121     	 movs r1,#1
 1213 0108 1A46     	 mov r2,r3
 1214 010a 0123     	 movs r3,#1
 1215 010c FFF7FEFF 	 bl OD_get_u32
 1216 0110 0346     	 mov r3,r0
 1217 0112 87F82030 	 strb r3,[r7,#32]
 382:../CANopen/stack/301/CO_SDOserver.c ****                                     &COB_IDClientToServer32, true);
 383:../CANopen/stack/301/CO_SDOserver.c ****             ODR_t odRet2 = OD_get_u32(OD_1200_SDOsrvPar, 2,
 1218              	 .loc 3 383 0
 1219 0116 07F11403 	 add r3,r7,#20
 1220 011a 7868     	 ldr r0,[r7,#4]
 1221 011c 0221     	 movs r1,#2
 1222 011e 1A46     	 mov r2,r3
 1223 0120 0123     	 movs r3,#1
 1224 0122 FFF7FEFF 	 bl OD_get_u32
 1225 0126 0346     	 mov r3,r0
 1226 0128 FB77     	 strb r3,[r7,#31]
 384:../CANopen/stack/301/CO_SDOserver.c ****                                     &COB_IDServerToClient32, true);
 385:../CANopen/stack/301/CO_SDOserver.c **** 
 386:../CANopen/stack/301/CO_SDOserver.c ****             if (odRet0 != ODR_OK || (maxSubIndex != 2 && maxSubIndex != 3)
 1227              	 .loc 3 386 0
 1228 012a 97F92130 	 ldrsb r3,[r7,#33]
 1229 012e 002B     	 cmp r3,#0
 1230 0130 0DD1     	 bne .L79
 1231              	 .loc 3 386 0 is_stmt 0 discriminator 1
 1232 0132 7B7F     	 ldrb r3,[r7,#29]
 1233 0134 022B     	 cmp r3,#2
 1234 0136 02D0     	 beq .L80
 1235              	 .loc 3 386 0 discriminator 2
 1236 0138 7B7F     	 ldrb r3,[r7,#29]
 1237 013a 032B     	 cmp r3,#3
 1238 013c 07D1     	 bne .L79
 1239              	.L80:
 387:../CANopen/stack/301/CO_SDOserver.c ****                 || odRet1 != ODR_OK || odRet2 != ODR_OK
 1240              	 .loc 3 387 0 is_stmt 1
 1241 013e 97F92030 	 ldrsb r3,[r7,#32]
 1242 0142 002B     	 cmp r3,#0
 1243 0144 03D1     	 bne .L79
 1244              	 .loc 3 387 0 is_stmt 0 discriminator 1
 1245 0146 97F91F30 	 ldrsb r3,[r7,#31]
 1246 014a 002B     	 cmp r3,#0
 1247 014c 07D0     	 beq .L81
 1248              	.L79:
 388:../CANopen/stack/301/CO_SDOserver.c ****             ) {
 389:../CANopen/stack/301/CO_SDOserver.c ****                 if (errInfo != NULL) *errInfo = OD_SDOsrvParIdx;
 1249              	 .loc 3 389 0 is_stmt 1
 1250 014e FB6C     	 ldr r3,[r7,#76]
 1251 0150 002B     	 cmp r3,#0
 1252 0152 02D0     	 beq .L82
 1253              	 .loc 3 389 0 is_stmt 0 discriminator 1
 1254 0154 7A8C     	 ldrh r2,[r7,#34]
 1255 0156 FB6C     	 ldr r3,[r7,#76]
 1256 0158 1A60     	 str r2,[r3]
 1257              	.L82:
 390:../CANopen/stack/301/CO_SDOserver.c ****                 return CO_ERROR_OD_PARAMETERS;
 1258              	 .loc 3 390 0 is_stmt 1
 1259 015a F423     	 movs r3,#244
 1260 015c 5DE0     	 b .L70
 1261              	.L81:
 391:../CANopen/stack/301/CO_SDOserver.c ****             }
 392:../CANopen/stack/301/CO_SDOserver.c **** 
 393:../CANopen/stack/301/CO_SDOserver.c **** 
 394:../CANopen/stack/301/CO_SDOserver.c ****             CanId_ClientToServer = ((COB_IDClientToServer32 & 0x80000000) == 0)
 1262              	 .loc 3 394 0
 1263 015e BB69     	 ldr r3,[r7,#24]
 1264 0160 002B     	 cmp r3,#0
 1265 0162 05DB     	 blt .L84
 1266              	 .loc 3 394 0 is_stmt 0 discriminator 1
 1267 0164 BB69     	 ldr r3,[r7,#24]
 1268 0166 9BB2     	 uxth r3,r3
 1269 0168 C3F30A03 	 ubfx r3,r3,#0,#11
 1270 016c 9BB2     	 uxth r3,r3
 1271 016e 00E0     	 b .L85
 1272              	.L84:
 1273              	 .loc 3 394 0 discriminator 2
 1274 0170 0023     	 movs r3,#0
 1275              	.L85:
 1276              	 .loc 3 394 0 discriminator 4
 1277 0172 FB84     	 strh r3,[r7,#38]
 395:../CANopen/stack/301/CO_SDOserver.c ****                                 ? (uint16_t)(COB_IDClientToServer32 & 0x7FF) : 0;
 396:../CANopen/stack/301/CO_SDOserver.c ****             CanId_ServerToClient = ((COB_IDServerToClient32 & 0x80000000) == 0)
 1278              	 .loc 3 396 0 is_stmt 1 discriminator 4
 1279 0174 7B69     	 ldr r3,[r7,#20]
 1280 0176 002B     	 cmp r3,#0
 1281 0178 05DB     	 blt .L86
 1282              	 .loc 3 396 0 is_stmt 0 discriminator 1
 1283 017a 7B69     	 ldr r3,[r7,#20]
 1284 017c 9BB2     	 uxth r3,r3
 1285 017e C3F30A03 	 ubfx r3,r3,#0,#11
 1286 0182 9BB2     	 uxth r3,r3
 1287 0184 00E0     	 b .L87
 1288              	.L86:
 1289              	 .loc 3 396 0 discriminator 2
 1290 0186 0023     	 movs r3,#0
 1291              	.L87:
 1292              	 .loc 3 396 0 discriminator 4
 1293 0188 BB84     	 strh r3,[r7,#36]
 397:../CANopen/stack/301/CO_SDOserver.c ****                                 ? (uint16_t)(COB_IDServerToClient32 & 0x7FF) : 0;
 398:../CANopen/stack/301/CO_SDOserver.c **** 
 399:../CANopen/stack/301/CO_SDOserver.c ****     #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_OD_DYNAMIC
 400:../CANopen/stack/301/CO_SDOserver.c ****             SDO->OD_1200_extension.object = SDO;
 1294              	 .loc 3 400 0 is_stmt 1 discriminator 4
 1295 018a FB68     	 ldr r3,[r7,#12]
 1296 018c FA68     	 ldr r2,[r7,#12]
 1297 018e 5A65     	 str r2,[r3,#84]
 401:../CANopen/stack/301/CO_SDOserver.c ****             SDO->OD_1200_extension.read = OD_readOriginal;
 1298              	 .loc 3 401 0 discriminator 4
 1299 0190 FB68     	 ldr r3,[r7,#12]
 1300 0192 244A     	 ldr r2,.L90
 1301 0194 9A65     	 str r2,[r3,#88]
 402:../CANopen/stack/301/CO_SDOserver.c ****             SDO->OD_1200_extension.write = OD_write_1201_additional;
 1302              	 .loc 3 402 0 discriminator 4
 1303 0196 FB68     	 ldr r3,[r7,#12]
 1304 0198 234A     	 ldr r2,.L90+4
 1305 019a DA65     	 str r2,[r3,#92]
 403:../CANopen/stack/301/CO_SDOserver.c ****             ODR_t odRetE = OD_extension_init(OD_1200_SDOsrvPar,
 1306              	 .loc 3 403 0 discriminator 4
 1307 019c FB68     	 ldr r3,[r7,#12]
 1308 019e 5433     	 adds r3,r3,#84
 1309 01a0 7868     	 ldr r0,[r7,#4]
 1310 01a2 1946     	 mov r1,r3
 1311 01a4 FFF7FEFF 	 bl OD_extension_init
 1312 01a8 0346     	 mov r3,r0
 1313 01aa BB77     	 strb r3,[r7,#30]
 404:../CANopen/stack/301/CO_SDOserver.c ****                                             &SDO->OD_1200_extension);
 405:../CANopen/stack/301/CO_SDOserver.c ****             if (odRetE != ODR_OK) {
 1314              	 .loc 3 405 0 discriminator 4
 1315 01ac 97F91E30 	 ldrsb r3,[r7,#30]
 1316 01b0 002B     	 cmp r3,#0
 1317 01b2 07D0     	 beq .L88
 406:../CANopen/stack/301/CO_SDOserver.c ****                 if (errInfo != NULL) *errInfo = OD_SDOsrvParIdx;
 1318              	 .loc 3 406 0
 1319 01b4 FB6C     	 ldr r3,[r7,#76]
 1320 01b6 002B     	 cmp r3,#0
 1321 01b8 02D0     	 beq .L89
 1322              	 .loc 3 406 0 is_stmt 0 discriminator 1
 1323 01ba 7A8C     	 ldrh r2,[r7,#34]
 1324 01bc FB6C     	 ldr r3,[r7,#76]
 1325 01be 1A60     	 str r2,[r3]
 1326              	.L89:
 407:../CANopen/stack/301/CO_SDOserver.c ****                 return CO_ERROR_OD_PARAMETERS;
 1327              	 .loc 3 407 0 is_stmt 1
 1328 01c0 F423     	 movs r3,#244
 1329 01c2 2AE0     	 b .L70
 1330              	.L88:
 1331              	.LBE6:
 374:../CANopen/stack/301/CO_SDOserver.c ****             /* configure additional SDO channel and SDO server parameters for it */
 1332              	 .loc 3 374 0
 1333 01c4 01E0     	 b .L74
 1334              	.L78:
 408:../CANopen/stack/301/CO_SDOserver.c ****             }
 409:../CANopen/stack/301/CO_SDOserver.c ****     #endif
 410:../CANopen/stack/301/CO_SDOserver.c ****         }
 411:../CANopen/stack/301/CO_SDOserver.c ****         else {
 412:../CANopen/stack/301/CO_SDOserver.c ****             return CO_ERROR_ILLEGAL_ARGUMENT;
 1335              	 .loc 3 412 0
 1336 01c6 FF23     	 movs r3,#255
 1337 01c8 27E0     	 b .L70
 1338              	.L74:
 1339              	.LBE5:
 413:../CANopen/stack/301/CO_SDOserver.c ****         }
 414:../CANopen/stack/301/CO_SDOserver.c ****     }
 415:../CANopen/stack/301/CO_SDOserver.c ****     CO_FLAG_CLEAR(SDO->CANrxNew);
 1340              	 .loc 3 415 0
 1341 01ca FB68     	 ldr r3,[r7,#12]
 1342 01cc 0022     	 movs r2,#0
 1343 01ce 9A63     	 str r2,[r3,#56]
 416:../CANopen/stack/301/CO_SDOserver.c **** 
 417:../CANopen/stack/301/CO_SDOserver.c ****     /* store the parameters and configure CANrx and CANtx */
 418:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_OD_DYNAMIC
 419:../CANopen/stack/301/CO_SDOserver.c ****     SDO->CANdevRx = CANdevRx;
 1344              	 .loc 3 419 0
 1345 01d0 FB68     	 ldr r3,[r7,#12]
 1346 01d2 FA6B     	 ldr r2,[r7,#60]
 1347 01d4 5A64     	 str r2,[r3,#68]
 420:../CANopen/stack/301/CO_SDOserver.c ****     SDO->CANdevRxIdx = CANdevRxIdx;
 1348              	 .loc 3 420 0
 1349 01d6 FB68     	 ldr r3,[r7,#12]
 1350 01d8 B7F84020 	 ldrh r2,[r7,#64]
 1351 01dc A3F84820 	 strh r2,[r3,#72]
 421:../CANopen/stack/301/CO_SDOserver.c ****     SDO->CANdevTxIdx = CANdevTxIdx;
 1352              	 .loc 3 421 0
 1353 01e0 FB68     	 ldr r3,[r7,#12]
 1354 01e2 B7F84820 	 ldrh r2,[r7,#72]
 1355 01e6 A3F84A20 	 strh r2,[r3,#74]
 422:../CANopen/stack/301/CO_SDOserver.c ****     /* set to zero to make sure CO_SDOserver_init_canRxTx() will reconfig CAN */
 423:../CANopen/stack/301/CO_SDOserver.c ****     SDO->COB_IDClientToServer = 0;
 1356              	 .loc 3 423 0
 1357 01ea FB68     	 ldr r3,[r7,#12]
 1358 01ec 0022     	 movs r2,#0
 1359 01ee DA64     	 str r2,[r3,#76]
 424:../CANopen/stack/301/CO_SDOserver.c ****     SDO->COB_IDServerToClient = 0;
 1360              	 .loc 3 424 0
 1361 01f0 FB68     	 ldr r3,[r7,#12]
 1362 01f2 0022     	 movs r2,#0
 1363 01f4 1A65     	 str r2,[r3,#80]
 425:../CANopen/stack/301/CO_SDOserver.c **** #endif
 426:../CANopen/stack/301/CO_SDOserver.c ****     SDO->CANdevTx = CANdevTx;
 1364              	 .loc 3 426 0
 1365 01f6 FB68     	 ldr r3,[r7,#12]
 1366 01f8 7A6C     	 ldr r2,[r7,#68]
 1367 01fa 1A60     	 str r2,[r3]
 427:../CANopen/stack/301/CO_SDOserver.c **** 
 428:../CANopen/stack/301/CO_SDOserver.c ****     return CO_SDOserver_init_canRxTx(SDO,
 1368              	 .loc 3 428 0
 1369 01fc FA8C     	 ldrh r2,[r7,#38]
 1370 01fe BB8C     	 ldrh r3,[r7,#36]
 1371 0200 B7F84050 	 ldrh r5,[r7,#64]
 1372 0204 B7F84840 	 ldrh r4,[r7,#72]
 1373 0208 0092     	 str r2,[sp]
 1374 020a 0193     	 str r3,[sp,#4]
 1375 020c F868     	 ldr r0,[r7,#12]
 1376 020e F96B     	 ldr r1,[r7,#60]
 1377 0210 2A46     	 mov r2,r5
 1378 0212 2346     	 mov r3,r4
 1379 0214 FFF7FEFF 	 bl CO_SDOserver_init_canRxTx
 1380 0218 0346     	 mov r3,r0
 1381              	.L70:
 1382 021a 5BB2     	 sxtb r3,r3
 429:../CANopen/stack/301/CO_SDOserver.c ****                                      CANdevRx,
 430:../CANopen/stack/301/CO_SDOserver.c ****                                      CANdevRxIdx,
 431:../CANopen/stack/301/CO_SDOserver.c ****                                      CANdevTxIdx,
 432:../CANopen/stack/301/CO_SDOserver.c ****                                      CanId_ClientToServer,
 433:../CANopen/stack/301/CO_SDOserver.c ****                                      CanId_ServerToClient);
 434:../CANopen/stack/301/CO_SDOserver.c **** }
 1383              	 .loc 3 434 0
 1384 021c 1846     	 mov r0,r3
 1385 021e 2837     	 adds r7,r7,#40
 1386              	.LCFI62:
 1387              	 .cfi_def_cfa_offset 16
 1388 0220 BD46     	 mov sp,r7
 1389              	.LCFI63:
 1390              	 .cfi_def_cfa_register 13
 1391              	 
 1392 0222 B0BD     	 pop {r4,r5,r7,pc}
 1393              	.L91:
 1394              	 .align 2
 1395              	.L90:
 1396 0224 00000000 	 .word OD_readOriginal
 1397 0228 00000000 	 .word OD_write_1201_additional
 1398              	 .cfi_endproc
 1399              	.LFE36:
 1401              	 .section .text.validateAndWriteToOD,"ax",%progbits
 1402              	 .align 2
 1403              	 .thumb
 1404              	 .thumb_func
 1406              	validateAndWriteToOD:
 1407              	.LFB37:
 435:../CANopen/stack/301/CO_SDOserver.c **** 
 436:../CANopen/stack/301/CO_SDOserver.c **** 
 437:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_CALLBACK_PRE
 438:../CANopen/stack/301/CO_SDOserver.c **** /******************************************************************************/
 439:../CANopen/stack/301/CO_SDOserver.c **** void CO_SDOserver_initCallbackPre(CO_SDOserver_t *SDO,
 440:../CANopen/stack/301/CO_SDOserver.c ****                                   void *object,
 441:../CANopen/stack/301/CO_SDOserver.c ****                                   void (*pFunctSignalPre)(void *object))
 442:../CANopen/stack/301/CO_SDOserver.c **** {
 443:../CANopen/stack/301/CO_SDOserver.c ****     if (SDO != NULL) {
 444:../CANopen/stack/301/CO_SDOserver.c ****         SDO->functSignalObjectPre = object;
 445:../CANopen/stack/301/CO_SDOserver.c ****         SDO->pFunctSignalPre = pFunctSignalPre;
 446:../CANopen/stack/301/CO_SDOserver.c ****     }
 447:../CANopen/stack/301/CO_SDOserver.c **** }
 448:../CANopen/stack/301/CO_SDOserver.c **** #endif
 449:../CANopen/stack/301/CO_SDOserver.c **** 
 450:../CANopen/stack/301/CO_SDOserver.c **** 
 451:../CANopen/stack/301/CO_SDOserver.c **** #ifdef CO_BIG_ENDIAN
 452:../CANopen/stack/301/CO_SDOserver.c **** static inline void reverseBytes(void *start, OD_size_t size) {
 453:../CANopen/stack/301/CO_SDOserver.c ****     uint8_t *lo = (uint8_t *)start;
 454:../CANopen/stack/301/CO_SDOserver.c ****     uint8_t *hi = (uint8_t *)start + size - 1;
 455:../CANopen/stack/301/CO_SDOserver.c ****     while (lo < hi) {
 456:../CANopen/stack/301/CO_SDOserver.c ****         uint8_t swap = *lo;
 457:../CANopen/stack/301/CO_SDOserver.c ****         *lo++ = *hi;
 458:../CANopen/stack/301/CO_SDOserver.c ****         *hi-- = swap;
 459:../CANopen/stack/301/CO_SDOserver.c ****     }
 460:../CANopen/stack/301/CO_SDOserver.c **** }
 461:../CANopen/stack/301/CO_SDOserver.c **** #endif
 462:../CANopen/stack/301/CO_SDOserver.c **** 
 463:../CANopen/stack/301/CO_SDOserver.c **** 
 464:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
 465:../CANopen/stack/301/CO_SDOserver.c **** /** Helper function for writing data to Object dictionary. Function swaps data
 466:../CANopen/stack/301/CO_SDOserver.c ****  * if necessary, calcualtes (and verifies CRC) writes data to OD and verifies
 467:../CANopen/stack/301/CO_SDOserver.c ****  * data lengths.
 468:../CANopen/stack/301/CO_SDOserver.c ****  *
 469:../CANopen/stack/301/CO_SDOserver.c ****  * @param SDO SDO server
 470:../CANopen/stack/301/CO_SDOserver.c ****  * @param [out] abortCode SDO abort code in case of error
 471:../CANopen/stack/301/CO_SDOserver.c ****  * @param crcOperation 0=none, 1=calculate, 2=calculate and compare
 472:../CANopen/stack/301/CO_SDOserver.c ****  * @parma crcClient crc checksum to campare with
 473:../CANopen/stack/301/CO_SDOserver.c ****  *
 474:../CANopen/stack/301/CO_SDOserver.c ****  * Returns true on success, otherwise write also abortCode and sets state to
 475:../CANopen/stack/301/CO_SDOserver.c ****  * CO_SDO_ST_ABORT */
 476:../CANopen/stack/301/CO_SDOserver.c **** static bool_t validateAndWriteToOD(CO_SDOserver_t *SDO,
 477:../CANopen/stack/301/CO_SDOserver.c ****                                    CO_SDO_abortCode_t *abortCode,
 478:../CANopen/stack/301/CO_SDOserver.c ****                                    uint8_t crcOperation,
 479:../CANopen/stack/301/CO_SDOserver.c ****                                    uint16_t crcClient)
 480:../CANopen/stack/301/CO_SDOserver.c **** {
 1408              	 .loc 3 480 0
 1409              	 .cfi_startproc
 1410              	 
 1411              	 
 1412 0000 90B5     	 push {r4,r7,lr}
 1413              	.LCFI64:
 1414              	 .cfi_def_cfa_offset 12
 1415              	 .cfi_offset 4,-12
 1416              	 .cfi_offset 7,-8
 1417              	 .cfi_offset 14,-4
 1418 0002 8BB0     	 sub sp,sp,#44
 1419              	.LCFI65:
 1420              	 .cfi_def_cfa_offset 56
 1421 0004 00AF     	 add r7,sp,#0
 1422              	.LCFI66:
 1423              	 .cfi_def_cfa_register 7
 1424 0006 F860     	 str r0,[r7,#12]
 1425 0008 B960     	 str r1,[r7,#8]
 1426 000a 1146     	 mov r1,r2
 1427 000c 1A46     	 mov r2,r3
 1428 000e 0B46     	 mov r3,r1
 1429 0010 FB71     	 strb r3,[r7,#7]
 1430 0012 1346     	 mov r3,r2
 1431 0014 BB80     	 strh r3,[r7,#4]
 481:../CANopen/stack/301/CO_SDOserver.c ****     OD_size_t bufOffsetWrOrig = SDO->bufOffsetWr;
 1432              	 .loc 3 481 0
 1433 0016 FB68     	 ldr r3,[r7,#12]
 1434 0018 D3F8A030 	 ldr r3,[r3,#160]
 1435 001c 7B62     	 str r3,[r7,#36]
 482:../CANopen/stack/301/CO_SDOserver.c **** 
 483:../CANopen/stack/301/CO_SDOserver.c ****     if (SDO->finished) {
 1436              	 .loc 3 483 0
 1437 001e FB68     	 ldr r3,[r7,#12]
 1438 0020 1B6F     	 ldr r3,[r3,#112]
 1439 0022 002B     	 cmp r3,#0
 1440 0024 7DD0     	 beq .L93
 1441              	.LBB7:
 484:../CANopen/stack/301/CO_SDOserver.c ****         /* Verify if size of data downloaded matches size indicated. */
 485:../CANopen/stack/301/CO_SDOserver.c ****         if (SDO->sizeInd > 0 && SDO->sizeTran != SDO->sizeInd) {
 1442              	 .loc 3 485 0
 1443 0026 FB68     	 ldr r3,[r7,#12]
 1444 0028 5B6E     	 ldr r3,[r3,#100]
 1445 002a 002B     	 cmp r3,#0
 1446 002c 15D0     	 beq .L94
 1447              	 .loc 3 485 0 is_stmt 0 discriminator 1
 1448 002e FB68     	 ldr r3,[r7,#12]
 1449 0030 9A6E     	 ldr r2,[r3,#104]
 1450 0032 FB68     	 ldr r3,[r7,#12]
 1451 0034 5B6E     	 ldr r3,[r3,#100]
 1452 0036 9A42     	 cmp r2,r3
 1453 0038 0FD0     	 beq .L94
 486:../CANopen/stack/301/CO_SDOserver.c ****             *abortCode = (SDO->sizeTran > SDO->sizeInd) ?
 1454              	 .loc 3 486 0 is_stmt 1
 1455 003a FB68     	 ldr r3,[r7,#12]
 1456 003c 9A6E     	 ldr r2,[r3,#104]
 1457 003e FB68     	 ldr r3,[r7,#12]
 1458 0040 5B6E     	 ldr r3,[r3,#100]
 1459 0042 9A42     	 cmp r2,r3
 1460 0044 01D9     	 bls .L95
 1461              	 .loc 3 486 0 is_stmt 0 discriminator 1
 1462 0046 6C4A     	 ldr r2,.L111
 1463 0048 00E0     	 b .L96
 1464              	.L95:
 1465              	 .loc 3 486 0 discriminator 2
 1466 004a 6C4A     	 ldr r2,.L111+4
 1467              	.L96:
 1468              	 .loc 3 486 0 discriminator 4
 1469 004c BB68     	 ldr r3,[r7,#8]
 1470 004e 1A60     	 str r2,[r3]
 487:../CANopen/stack/301/CO_SDOserver.c ****                          CO_SDO_AB_DATA_LONG : CO_SDO_AB_DATA_SHORT;
 488:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_ABORT;
 1471              	 .loc 3 488 0 is_stmt 1 discriminator 4
 1472 0050 FB68     	 ldr r3,[r7,#12]
 1473 0052 0122     	 movs r2,#1
 1474 0054 1A75     	 strb r2,[r3,#20]
 489:../CANopen/stack/301/CO_SDOserver.c ****             return false;
 1475              	 .loc 3 489 0 discriminator 4
 1476 0056 0023     	 movs r3,#0
 1477 0058 C9E0     	 b .L110
 1478              	.L94:
 490:../CANopen/stack/301/CO_SDOserver.c ****         }
 491:../CANopen/stack/301/CO_SDOserver.c **** 
 492:../CANopen/stack/301/CO_SDOserver.c **** #ifdef CO_BIG_ENDIAN
 493:../CANopen/stack/301/CO_SDOserver.c ****         /* swap int16_t .. uint64_t data if necessary */
 494:../CANopen/stack/301/CO_SDOserver.c ****         if ((SDO->OD_IO.stream.attribute & ODA_MB) != 0) {
 495:../CANopen/stack/301/CO_SDOserver.c ****             reverseBytes(SDO->buf, SDO->bufOffsetWr);
 496:../CANopen/stack/301/CO_SDOserver.c ****         }
 497:../CANopen/stack/301/CO_SDOserver.c **** #endif
 498:../CANopen/stack/301/CO_SDOserver.c **** 
 499:../CANopen/stack/301/CO_SDOserver.c ****         OD_size_t sizeInOd = SDO->OD_IO.stream.dataLength;
 1479              	 .loc 3 499 0
 1480 005a FB68     	 ldr r3,[r7,#12]
 1481 005c 1B6A     	 ldr r3,[r3,#32]
 1482 005e 3B62     	 str r3,[r7,#32]
 500:../CANopen/stack/301/CO_SDOserver.c **** 
 501:../CANopen/stack/301/CO_SDOserver.c ****         /* If dataType is string, then size of data downloaded may be
 502:../CANopen/stack/301/CO_SDOserver.c ****          * shorter than size of OD data buffer. If so, add two zero bytes
 503:../CANopen/stack/301/CO_SDOserver.c ****          * to terminate (unicode) string. Shorten also OD data size,
 504:../CANopen/stack/301/CO_SDOserver.c ****          * (temporary, send information about EOF into OD_IO.write) */
 505:../CANopen/stack/301/CO_SDOserver.c ****         if ((SDO->OD_IO.stream.attribute & ODA_STR) != 0
 1483              	 .loc 3 505 0
 1484 0060 FB68     	 ldr r3,[r7,#12]
 1485 0062 93F82830 	 ldrb r3,[r3,#40]
 1486 0066 DBB2     	 uxtb r3,r3
 1487 0068 5BB2     	 sxtb r3,r3
 1488 006a 002B     	 cmp r3,#0
 1489 006c 3CDA     	 bge .L98
 506:../CANopen/stack/301/CO_SDOserver.c ****             && (sizeInOd == 0 || SDO->sizeTran < sizeInOd)
 1490              	 .loc 3 506 0
 1491 006e 3B6A     	 ldr r3,[r7,#32]
 1492 0070 002B     	 cmp r3,#0
 1493 0072 04D0     	 beq .L99
 1494              	 .loc 3 506 0 is_stmt 0 discriminator 1
 1495 0074 FB68     	 ldr r3,[r7,#12]
 1496 0076 9A6E     	 ldr r2,[r3,#104]
 1497 0078 3B6A     	 ldr r3,[r7,#32]
 1498 007a 9A42     	 cmp r2,r3
 1499 007c 34D2     	 bcs .L98
 1500              	.L99:
 507:../CANopen/stack/301/CO_SDOserver.c ****             && (SDO->bufOffsetWr + 2) <= CO_CONFIG_SDO_SRV_BUFFER_SIZE
 1501              	 .loc 3 507 0 is_stmt 1
 1502 007e FB68     	 ldr r3,[r7,#12]
 1503 0080 D3F8A030 	 ldr r3,[r3,#160]
 1504 0084 0233     	 adds r3,r3,#2
 1505 0086 202B     	 cmp r3,#32
 1506 0088 2ED8     	 bhi .L98
 508:../CANopen/stack/301/CO_SDOserver.c ****         ) {
 509:../CANopen/stack/301/CO_SDOserver.c ****             SDO->buf[SDO->bufOffsetWr++] = 0;
 1507              	 .loc 3 509 0
 1508 008a FB68     	 ldr r3,[r7,#12]
 1509 008c D3F8A030 	 ldr r3,[r3,#160]
 1510 0090 591C     	 adds r1,r3,#1
 1511 0092 FA68     	 ldr r2,[r7,#12]
 1512 0094 C2F8A010 	 str r1,[r2,#160]
 1513 0098 FA68     	 ldr r2,[r7,#12]
 1514 009a 1344     	 add r3,r3,r2
 1515 009c 0022     	 movs r2,#0
 1516 009e 83F87C20 	 strb r2,[r3,#124]
 510:../CANopen/stack/301/CO_SDOserver.c ****             SDO->sizeTran++;
 1517              	 .loc 3 510 0
 1518 00a2 FB68     	 ldr r3,[r7,#12]
 1519 00a4 9B6E     	 ldr r3,[r3,#104]
 1520 00a6 5A1C     	 adds r2,r3,#1
 1521 00a8 FB68     	 ldr r3,[r7,#12]
 1522 00aa 9A66     	 str r2,[r3,#104]
 511:../CANopen/stack/301/CO_SDOserver.c ****             if (sizeInOd == 0 || SDO->sizeTran < sizeInOd) {
 1523              	 .loc 3 511 0
 1524 00ac 3B6A     	 ldr r3,[r7,#32]
 1525 00ae 002B     	 cmp r3,#0
 1526 00b0 04D0     	 beq .L100
 1527              	 .loc 3 511 0 is_stmt 0 discriminator 1
 1528 00b2 FB68     	 ldr r3,[r7,#12]
 1529 00b4 9A6E     	 ldr r2,[r3,#104]
 1530 00b6 3B6A     	 ldr r3,[r7,#32]
 1531 00b8 9A42     	 cmp r2,r3
 1532 00ba 10D2     	 bcs .L101
 1533              	.L100:
 512:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->buf[SDO->bufOffsetWr++] = 0;
 1534              	 .loc 3 512 0 is_stmt 1
 1535 00bc FB68     	 ldr r3,[r7,#12]
 1536 00be D3F8A030 	 ldr r3,[r3,#160]
 1537 00c2 591C     	 adds r1,r3,#1
 1538 00c4 FA68     	 ldr r2,[r7,#12]
 1539 00c6 C2F8A010 	 str r1,[r2,#160]
 1540 00ca FA68     	 ldr r2,[r7,#12]
 1541 00cc 1344     	 add r3,r3,r2
 1542 00ce 0022     	 movs r2,#0
 1543 00d0 83F87C20 	 strb r2,[r3,#124]
 513:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->sizeTran++;
 1544              	 .loc 3 513 0
 1545 00d4 FB68     	 ldr r3,[r7,#12]
 1546 00d6 9B6E     	 ldr r3,[r3,#104]
 1547 00d8 5A1C     	 adds r2,r3,#1
 1548 00da FB68     	 ldr r3,[r7,#12]
 1549 00dc 9A66     	 str r2,[r3,#104]
 1550              	.L101:
 514:../CANopen/stack/301/CO_SDOserver.c ****             }
 515:../CANopen/stack/301/CO_SDOserver.c ****             SDO->OD_IO.stream.dataLength = SDO->sizeTran;
 1551              	 .loc 3 515 0
 1552 00de FB68     	 ldr r3,[r7,#12]
 1553 00e0 9A6E     	 ldr r2,[r3,#104]
 1554 00e2 FB68     	 ldr r3,[r7,#12]
 1555 00e4 1A62     	 str r2,[r3,#32]
 1556 00e6 1BE0     	 b .L102
 1557              	.L98:
 516:../CANopen/stack/301/CO_SDOserver.c ****         }
 517:../CANopen/stack/301/CO_SDOserver.c ****         /* Indicate OD data size, if not indicated. Can be used for EOF check.*/
 518:../CANopen/stack/301/CO_SDOserver.c ****         else if (sizeInOd == 0) {
 1558              	 .loc 3 518 0
 1559 00e8 3B6A     	 ldr r3,[r7,#32]
 1560 00ea 002B     	 cmp r3,#0
 1561 00ec 04D1     	 bne .L103
 519:../CANopen/stack/301/CO_SDOserver.c ****             SDO->OD_IO.stream.dataLength = SDO->sizeTran;
 1562              	 .loc 3 519 0
 1563 00ee FB68     	 ldr r3,[r7,#12]
 1564 00f0 9A6E     	 ldr r2,[r3,#104]
 1565 00f2 FB68     	 ldr r3,[r7,#12]
 1566 00f4 1A62     	 str r2,[r3,#32]
 1567 00f6 13E0     	 b .L102
 1568              	.L103:
 520:../CANopen/stack/301/CO_SDOserver.c ****         }
 521:../CANopen/stack/301/CO_SDOserver.c ****         /* Verify if size of data downloaded matches data size in OD. */
 522:../CANopen/stack/301/CO_SDOserver.c ****         else if (SDO->sizeTran != sizeInOd) {
 1569              	 .loc 3 522 0
 1570 00f8 FB68     	 ldr r3,[r7,#12]
 1571 00fa 9A6E     	 ldr r2,[r3,#104]
 1572 00fc 3B6A     	 ldr r3,[r7,#32]
 1573 00fe 9A42     	 cmp r2,r3
 1574 0100 0ED0     	 beq .L102
 523:../CANopen/stack/301/CO_SDOserver.c ****             *abortCode = (SDO->sizeTran > sizeInOd) ?
 1575              	 .loc 3 523 0
 1576 0102 FB68     	 ldr r3,[r7,#12]
 1577 0104 9A6E     	 ldr r2,[r3,#104]
 1578 0106 3B6A     	 ldr r3,[r7,#32]
 1579 0108 9A42     	 cmp r2,r3
 1580 010a 01D9     	 bls .L104
 1581              	 .loc 3 523 0 is_stmt 0 discriminator 1
 1582 010c 3A4A     	 ldr r2,.L111
 1583 010e 00E0     	 b .L105
 1584              	.L104:
 1585              	 .loc 3 523 0 discriminator 2
 1586 0110 3A4A     	 ldr r2,.L111+4
 1587              	.L105:
 1588              	 .loc 3 523 0 discriminator 4
 1589 0112 BB68     	 ldr r3,[r7,#8]
 1590 0114 1A60     	 str r2,[r3]
 524:../CANopen/stack/301/CO_SDOserver.c ****                          CO_SDO_AB_DATA_LONG : CO_SDO_AB_DATA_SHORT;
 525:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_ABORT;
 1591              	 .loc 3 525 0 is_stmt 1 discriminator 4
 1592 0116 FB68     	 ldr r3,[r7,#12]
 1593 0118 0122     	 movs r2,#1
 1594 011a 1A75     	 strb r2,[r3,#20]
 526:../CANopen/stack/301/CO_SDOserver.c ****             return false;
 1595              	 .loc 3 526 0 discriminator 4
 1596 011c 0023     	 movs r3,#0
 1597 011e 66E0     	 b .L110
 1598              	.L102:
 1599              	.LBE7:
 1600 0120 11E0     	 b .L106
 1601              	.L93:
 527:../CANopen/stack/301/CO_SDOserver.c ****         }
 528:../CANopen/stack/301/CO_SDOserver.c ****     }
 529:../CANopen/stack/301/CO_SDOserver.c ****     else {
 530:../CANopen/stack/301/CO_SDOserver.c ****         /* Verify if size of data downloaded is not too large. */
 531:../CANopen/stack/301/CO_SDOserver.c ****         if (SDO->sizeInd > 0 && SDO->sizeTran > SDO->sizeInd) {
 1602              	 .loc 3 531 0
 1603 0122 FB68     	 ldr r3,[r7,#12]
 1604 0124 5B6E     	 ldr r3,[r3,#100]
 1605 0126 002B     	 cmp r3,#0
 1606 0128 0DD0     	 beq .L106
 1607              	 .loc 3 531 0 is_stmt 0 discriminator 1
 1608 012a FB68     	 ldr r3,[r7,#12]
 1609 012c 9A6E     	 ldr r2,[r3,#104]
 1610 012e FB68     	 ldr r3,[r7,#12]
 1611 0130 5B6E     	 ldr r3,[r3,#100]
 1612 0132 9A42     	 cmp r2,r3
 1613 0134 07D9     	 bls .L106
 532:../CANopen/stack/301/CO_SDOserver.c ****             *abortCode = CO_SDO_AB_DATA_LONG;
 1614              	 .loc 3 532 0 is_stmt 1
 1615 0136 BB68     	 ldr r3,[r7,#8]
 1616 0138 2F4A     	 ldr r2,.L111
 1617 013a 1A60     	 str r2,[r3]
 533:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_ABORT;
 1618              	 .loc 3 533 0
 1619 013c FB68     	 ldr r3,[r7,#12]
 1620 013e 0122     	 movs r2,#1
 1621 0140 1A75     	 strb r2,[r3,#20]
 534:../CANopen/stack/301/CO_SDOserver.c ****             return false;
 1622              	 .loc 3 534 0
 1623 0142 0023     	 movs r3,#0
 1624 0144 53E0     	 b .L110
 1625              	.L106:
 535:../CANopen/stack/301/CO_SDOserver.c ****         }
 536:../CANopen/stack/301/CO_SDOserver.c ****     }
 537:../CANopen/stack/301/CO_SDOserver.c **** 
 538:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK
 539:../CANopen/stack/301/CO_SDOserver.c ****     /* calculate crc on current data */
 540:../CANopen/stack/301/CO_SDOserver.c ****     if (SDO->block_crcEnabled && crcOperation > 0) {
 541:../CANopen/stack/301/CO_SDOserver.c ****         SDO->block_crc = crc16_ccitt(SDO->buf, bufOffsetWrOrig, SDO->block_crc);
 542:../CANopen/stack/301/CO_SDOserver.c ****         if (crcOperation == 2 && crcClient != SDO->block_crc) {
 543:../CANopen/stack/301/CO_SDOserver.c ****             *abortCode = CO_SDO_AB_CRC;
 544:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_ABORT;
 545:../CANopen/stack/301/CO_SDOserver.c ****             return false;
 546:../CANopen/stack/301/CO_SDOserver.c ****         }
 547:../CANopen/stack/301/CO_SDOserver.c ****     }
 548:../CANopen/stack/301/CO_SDOserver.c **** #endif
 549:../CANopen/stack/301/CO_SDOserver.c ****     /* may be unused */
 550:../CANopen/stack/301/CO_SDOserver.c ****     (void) crcOperation; (void) crcClient; (void) bufOffsetWrOrig;
 551:../CANopen/stack/301/CO_SDOserver.c **** 
 552:../CANopen/stack/301/CO_SDOserver.c ****     /* write data */
 553:../CANopen/stack/301/CO_SDOserver.c ****     OD_size_t countWritten = 0;
 1626              	 .loc 3 553 0
 1627 0146 0023     	 movs r3,#0
 1628 0148 7B61     	 str r3,[r7,#20]
 554:../CANopen/stack/301/CO_SDOserver.c ****     bool_t lock = OD_mappable(&SDO->OD_IO.stream);
 1629              	 .loc 3 554 0
 1630 014a FB68     	 ldr r3,[r7,#12]
 1631 014c 1833     	 adds r3,r3,#24
 1632 014e 1846     	 mov r0,r3
 1633 0150 FFF7FEFF 	 bl OD_mappable
 1634 0154 F861     	 str r0,[r7,#28]
 555:../CANopen/stack/301/CO_SDOserver.c **** 
 556:../CANopen/stack/301/CO_SDOserver.c ****     if (lock) { CO_LOCK_OD(SDO->CANdevTx); }
 557:../CANopen/stack/301/CO_SDOserver.c ****     ODR_t odRet = SDO->OD_IO.write(&SDO->OD_IO.stream, SDO->buf,
 1635              	 .loc 3 557 0
 1636 0156 FB68     	 ldr r3,[r7,#12]
 1637 0158 1C6B     	 ldr r4,[r3,#48]
 1638 015a FB68     	 ldr r3,[r7,#12]
 1639 015c 03F11800 	 add r0,r3,#24
 1640 0160 FB68     	 ldr r3,[r7,#12]
 1641 0162 03F17C01 	 add r1,r3,#124
 1642 0166 FB68     	 ldr r3,[r7,#12]
 1643 0168 D3F8A020 	 ldr r2,[r3,#160]
 1644 016c 07F11403 	 add r3,r7,#20
 1645 0170 A047     	 blx r4
 1646 0172 0346     	 mov r3,r0
 1647 0174 FB76     	 strb r3,[r7,#27]
 558:../CANopen/stack/301/CO_SDOserver.c ****                                    SDO->bufOffsetWr, &countWritten);
 559:../CANopen/stack/301/CO_SDOserver.c ****     if (lock) { CO_UNLOCK_OD(SDO->CANdevTx); }
 560:../CANopen/stack/301/CO_SDOserver.c **** 
 561:../CANopen/stack/301/CO_SDOserver.c ****     SDO->bufOffsetWr = 0;
 1648              	 .loc 3 561 0
 1649 0176 FB68     	 ldr r3,[r7,#12]
 1650 0178 0022     	 movs r2,#0
 1651 017a C3F8A020 	 str r2,[r3,#160]
 562:../CANopen/stack/301/CO_SDOserver.c **** 
 563:../CANopen/stack/301/CO_SDOserver.c ****     /* verify write error value */
 564:../CANopen/stack/301/CO_SDOserver.c ****     if (odRet != ODR_OK && odRet != ODR_PARTIAL) {
 1652              	 .loc 3 564 0
 1653 017e 97F91B30 	 ldrsb r3,[r7,#27]
 1654 0182 002B     	 cmp r3,#0
 1655 0184 11D0     	 beq .L107
 1656              	 .loc 3 564 0 is_stmt 0 discriminator 1
 1657 0186 97F91B30 	 ldrsb r3,[r7,#27]
 1658 018a B3F1FF3F 	 cmp r3,#-1
 1659 018e 0CD0     	 beq .L107
 565:../CANopen/stack/301/CO_SDOserver.c ****         *abortCode = (CO_SDO_abortCode_t)OD_getSDOabCode(odRet);
 1660              	 .loc 3 565 0 is_stmt 1
 1661 0190 97F91B30 	 ldrsb r3,[r7,#27]
 1662 0194 1846     	 mov r0,r3
 1663 0196 FFF7FEFF 	 bl OD_getSDOabCode
 1664 019a 0246     	 mov r2,r0
 1665 019c BB68     	 ldr r3,[r7,#8]
 1666 019e 1A60     	 str r2,[r3]
 566:../CANopen/stack/301/CO_SDOserver.c ****         SDO->state = CO_SDO_ST_ABORT;
 1667              	 .loc 3 566 0
 1668 01a0 FB68     	 ldr r3,[r7,#12]
 1669 01a2 0122     	 movs r2,#1
 1670 01a4 1A75     	 strb r2,[r3,#20]
 567:../CANopen/stack/301/CO_SDOserver.c ****         return false;
 1671              	 .loc 3 567 0
 1672 01a6 0023     	 movs r3,#0
 1673 01a8 21E0     	 b .L110
 1674              	.L107:
 568:../CANopen/stack/301/CO_SDOserver.c ****     }
 569:../CANopen/stack/301/CO_SDOserver.c ****     else if (SDO->finished && odRet == ODR_PARTIAL) {
 1675              	 .loc 3 569 0
 1676 01aa FB68     	 ldr r3,[r7,#12]
 1677 01ac 1B6F     	 ldr r3,[r3,#112]
 1678 01ae 002B     	 cmp r3,#0
 1679 01b0 0CD0     	 beq .L108
 1680              	 .loc 3 569 0 is_stmt 0 discriminator 1
 1681 01b2 97F91B30 	 ldrsb r3,[r7,#27]
 1682 01b6 B3F1FF3F 	 cmp r3,#-1
 1683 01ba 07D1     	 bne .L108
 570:../CANopen/stack/301/CO_SDOserver.c ****         /* OD variable was not written completely, but SDO download finished */
 571:../CANopen/stack/301/CO_SDOserver.c ****         *abortCode = CO_SDO_AB_DATA_SHORT;
 1684              	 .loc 3 571 0 is_stmt 1
 1685 01bc BB68     	 ldr r3,[r7,#8]
 1686 01be 0F4A     	 ldr r2,.L111+4
 1687 01c0 1A60     	 str r2,[r3]
 572:../CANopen/stack/301/CO_SDOserver.c ****         SDO->state = CO_SDO_ST_ABORT;
 1688              	 .loc 3 572 0
 1689 01c2 FB68     	 ldr r3,[r7,#12]
 1690 01c4 0122     	 movs r2,#1
 1691 01c6 1A75     	 strb r2,[r3,#20]
 573:../CANopen/stack/301/CO_SDOserver.c ****         return false;
 1692              	 .loc 3 573 0
 1693 01c8 0023     	 movs r3,#0
 1694 01ca 10E0     	 b .L110
 1695              	.L108:
 574:../CANopen/stack/301/CO_SDOserver.c ****     }
 575:../CANopen/stack/301/CO_SDOserver.c ****     else if (!SDO->finished && odRet == ODR_OK) {
 1696              	 .loc 3 575 0
 1697 01cc FB68     	 ldr r3,[r7,#12]
 1698 01ce 1B6F     	 ldr r3,[r3,#112]
 1699 01d0 002B     	 cmp r3,#0
 1700 01d2 0BD1     	 bne .L109
 1701              	 .loc 3 575 0 is_stmt 0 discriminator 1
 1702 01d4 97F91B30 	 ldrsb r3,[r7,#27]
 1703 01d8 002B     	 cmp r3,#0
 1704 01da 07D1     	 bne .L109
 576:../CANopen/stack/301/CO_SDOserver.c ****         /* OD variable was written completely, but SDO download still has data*/
 577:../CANopen/stack/301/CO_SDOserver.c ****         *abortCode = CO_SDO_AB_DATA_LONG;
 1705              	 .loc 3 577 0 is_stmt 1
 1706 01dc BB68     	 ldr r3,[r7,#8]
 1707 01de 064A     	 ldr r2,.L111
 1708 01e0 1A60     	 str r2,[r3]
 578:../CANopen/stack/301/CO_SDOserver.c ****         SDO->state = CO_SDO_ST_ABORT;
 1709              	 .loc 3 578 0
 1710 01e2 FB68     	 ldr r3,[r7,#12]
 1711 01e4 0122     	 movs r2,#1
 1712 01e6 1A75     	 strb r2,[r3,#20]
 579:../CANopen/stack/301/CO_SDOserver.c ****         return false;
 1713              	 .loc 3 579 0
 1714 01e8 0023     	 movs r3,#0
 1715 01ea 00E0     	 b .L110
 1716              	.L109:
 580:../CANopen/stack/301/CO_SDOserver.c ****     }
 581:../CANopen/stack/301/CO_SDOserver.c **** 
 582:../CANopen/stack/301/CO_SDOserver.c ****     return true;
 1717              	 .loc 3 582 0
 1718 01ec 0123     	 movs r3,#1
 1719              	.L110:
 583:../CANopen/stack/301/CO_SDOserver.c **** }
 1720              	 .loc 3 583 0 discriminator 1
 1721 01ee 1846     	 mov r0,r3
 1722 01f0 2C37     	 adds r7,r7,#44
 1723              	.LCFI67:
 1724              	 .cfi_def_cfa_offset 12
 1725 01f2 BD46     	 mov sp,r7
 1726              	.LCFI68:
 1727              	 .cfi_def_cfa_register 13
 1728              	 
 1729 01f4 90BD     	 pop {r4,r7,pc}
 1730              	.L112:
 1731 01f6 00BF     	 .align 2
 1732              	.L111:
 1733 01f8 12000706 	 .word 101122066
 1734 01fc 13000706 	 .word 101122067
 1735              	 .cfi_endproc
 1736              	.LFE37:
 1738              	 .section .text.readFromOd,"ax",%progbits
 1739              	 .align 2
 1740              	 .thumb
 1741              	 .thumb_func
 1743              	readFromOd:
 1744              	.LFB38:
 584:../CANopen/stack/301/CO_SDOserver.c **** 
 585:../CANopen/stack/301/CO_SDOserver.c **** 
 586:../CANopen/stack/301/CO_SDOserver.c **** /** Helper function for reading data from Object dictionary. Function also swaps
 587:../CANopen/stack/301/CO_SDOserver.c ****  * data if necessary and calcualtes CRC.
 588:../CANopen/stack/301/CO_SDOserver.c ****  *
 589:../CANopen/stack/301/CO_SDOserver.c ****  * @param SDO SDO server
 590:../CANopen/stack/301/CO_SDOserver.c ****  * @param [out] abortCode SDO abort code in case of error
 591:../CANopen/stack/301/CO_SDOserver.c ****  * @parma countMinimum if data size in buffer is less than countMinimum, then
 592:../CANopen/stack/301/CO_SDOserver.c ****  * buffer is refilled from OD variable
 593:../CANopen/stack/301/CO_SDOserver.c ****  * @param calculateCrc if true, crc is calculated
 594:../CANopen/stack/301/CO_SDOserver.c ****  *
 595:../CANopen/stack/301/CO_SDOserver.c ****  * Returns true on success, otherwise write also abortCode and sets state to
 596:../CANopen/stack/301/CO_SDOserver.c ****  * CO_SDO_ST_ABORT */
 597:../CANopen/stack/301/CO_SDOserver.c **** static bool_t readFromOd(CO_SDOserver_t *SDO,
 598:../CANopen/stack/301/CO_SDOserver.c ****                          CO_SDO_abortCode_t *abortCode,
 599:../CANopen/stack/301/CO_SDOserver.c ****                          OD_size_t countMinimum,
 600:../CANopen/stack/301/CO_SDOserver.c ****                          bool_t calculateCrc)
 601:../CANopen/stack/301/CO_SDOserver.c **** {
 1745              	 .loc 3 601 0
 1746              	 .cfi_startproc
 1747              	 
 1748              	 
 1749 0000 90B5     	 push {r4,r7,lr}
 1750              	.LCFI69:
 1751              	 .cfi_def_cfa_offset 12
 1752              	 .cfi_offset 4,-12
 1753              	 .cfi_offset 7,-8
 1754              	 .cfi_offset 14,-4
 1755 0002 8DB0     	 sub sp,sp,#52
 1756              	.LCFI70:
 1757              	 .cfi_def_cfa_offset 64
 1758 0004 00AF     	 add r7,sp,#0
 1759              	.LCFI71:
 1760              	 .cfi_def_cfa_register 7
 1761 0006 F860     	 str r0,[r7,#12]
 1762 0008 B960     	 str r1,[r7,#8]
 1763 000a 7A60     	 str r2,[r7,#4]
 1764 000c 3B60     	 str r3,[r7]
 602:../CANopen/stack/301/CO_SDOserver.c ****     OD_size_t countRemain = SDO->bufOffsetWr - SDO->bufOffsetRd;
 1765              	 .loc 3 602 0
 1766 000e FB68     	 ldr r3,[r7,#12]
 1767 0010 D3F8A020 	 ldr r2,[r3,#160]
 1768 0014 FB68     	 ldr r3,[r7,#12]
 1769 0016 D3F8A430 	 ldr r3,[r3,#164]
 1770 001a D31A     	 subs r3,r2,r3
 1771 001c 7B62     	 str r3,[r7,#36]
 603:../CANopen/stack/301/CO_SDOserver.c **** 
 604:../CANopen/stack/301/CO_SDOserver.c ****     if (!SDO->finished && countRemain < countMinimum) {
 1772              	 .loc 3 604 0
 1773 001e FB68     	 ldr r3,[r7,#12]
 1774 0020 1B6F     	 ldr r3,[r3,#112]
 1775 0022 002B     	 cmp r3,#0
 1776 0024 40F09F80 	 bne .L114
 1777              	 .loc 3 604 0 is_stmt 0 discriminator 1
 1778 0028 7A6A     	 ldr r2,[r7,#36]
 1779 002a 7B68     	 ldr r3,[r7,#4]
 1780 002c 9A42     	 cmp r2,r3
 1781 002e 80F09A80 	 bcs .L114
 1782              	.LBB8:
 605:../CANopen/stack/301/CO_SDOserver.c ****         /* first move remaining data to the start of the buffer */
 606:../CANopen/stack/301/CO_SDOserver.c ****         memmove(SDO->buf, SDO->buf + SDO->bufOffsetRd, countRemain);
 1783              	 .loc 3 606 0 is_stmt 1
 1784 0032 FB68     	 ldr r3,[r7,#12]
 1785 0034 03F17C01 	 add r1,r3,#124
 1786 0038 FB68     	 ldr r3,[r7,#12]
 1787 003a D3F8A430 	 ldr r3,[r3,#164]
 1788 003e 7833     	 adds r3,r3,#120
 1789 0040 FA68     	 ldr r2,[r7,#12]
 1790 0042 1344     	 add r3,r3,r2
 1791 0044 0433     	 adds r3,r3,#4
 1792 0046 0846     	 mov r0,r1
 1793 0048 1946     	 mov r1,r3
 1794 004a 7A6A     	 ldr r2,[r7,#36]
 1795 004c FFF7FEFF 	 bl memmove
 607:../CANopen/stack/301/CO_SDOserver.c ****         SDO->bufOffsetRd = 0;
 1796              	 .loc 3 607 0
 1797 0050 FB68     	 ldr r3,[r7,#12]
 1798 0052 0022     	 movs r2,#0
 1799 0054 C3F8A420 	 str r2,[r3,#164]
 608:../CANopen/stack/301/CO_SDOserver.c ****         SDO->bufOffsetWr = countRemain;
 1800              	 .loc 3 608 0
 1801 0058 FB68     	 ldr r3,[r7,#12]
 1802 005a 7A6A     	 ldr r2,[r7,#36]
 1803 005c C3F8A020 	 str r2,[r3,#160]
 609:../CANopen/stack/301/CO_SDOserver.c **** 
 610:../CANopen/stack/301/CO_SDOserver.c ****         /* Get size of free data buffer */
 611:../CANopen/stack/301/CO_SDOserver.c ****         OD_size_t countRdRequest = CO_CONFIG_SDO_SRV_BUFFER_SIZE - countRemain;
 1804              	 .loc 3 611 0
 1805 0060 7B6A     	 ldr r3,[r7,#36]
 1806 0062 C3F12003 	 rsb r3,r3,#32
 1807 0066 3B62     	 str r3,[r7,#32]
 612:../CANopen/stack/301/CO_SDOserver.c **** 
 613:../CANopen/stack/301/CO_SDOserver.c ****         /* load data from OD variable into the buffer */
 614:../CANopen/stack/301/CO_SDOserver.c ****         OD_size_t countRd = 0;
 1808              	 .loc 3 614 0
 1809 0068 0023     	 movs r3,#0
 1810 006a 7B61     	 str r3,[r7,#20]
 615:../CANopen/stack/301/CO_SDOserver.c ****         uint8_t *bufShifted = SDO->buf + countRemain;
 1811              	 .loc 3 615 0
 1812 006c 7B6A     	 ldr r3,[r7,#36]
 1813 006e 7833     	 adds r3,r3,#120
 1814 0070 FA68     	 ldr r2,[r7,#12]
 1815 0072 1344     	 add r3,r3,r2
 1816 0074 0433     	 adds r3,r3,#4
 1817 0076 FB61     	 str r3,[r7,#28]
 616:../CANopen/stack/301/CO_SDOserver.c ****         bool_t lock = OD_mappable(&SDO->OD_IO.stream);
 1818              	 .loc 3 616 0
 1819 0078 FB68     	 ldr r3,[r7,#12]
 1820 007a 1833     	 adds r3,r3,#24
 1821 007c 1846     	 mov r0,r3
 1822 007e FFF7FEFF 	 bl OD_mappable
 1823 0082 B861     	 str r0,[r7,#24]
 617:../CANopen/stack/301/CO_SDOserver.c **** 
 618:../CANopen/stack/301/CO_SDOserver.c ****         if (lock) { CO_LOCK_OD(SDO->CANdevTx); }
 619:../CANopen/stack/301/CO_SDOserver.c ****         ODR_t odRet = SDO->OD_IO.read(&SDO->OD_IO.stream, bufShifted,
 1824              	 .loc 3 619 0
 1825 0084 FB68     	 ldr r3,[r7,#12]
 1826 0086 DC6A     	 ldr r4,[r3,#44]
 1827 0088 FB68     	 ldr r3,[r7,#12]
 1828 008a 03F11802 	 add r2,r3,#24
 1829 008e 07F11403 	 add r3,r7,#20
 1830 0092 1046     	 mov r0,r2
 1831 0094 F969     	 ldr r1,[r7,#28]
 1832 0096 3A6A     	 ldr r2,[r7,#32]
 1833 0098 A047     	 blx r4
 1834 009a 0346     	 mov r3,r0
 1835 009c 87F82F30 	 strb r3,[r7,#47]
 620:../CANopen/stack/301/CO_SDOserver.c ****                                       countRdRequest, &countRd);
 621:../CANopen/stack/301/CO_SDOserver.c **** #if (C2000_PORT != 0)
 622:../CANopen/stack/301/CO_SDOserver.c ****         if((SDO->OD_IO.stream.attribute & ODA_STR) == 0) {
 623:../CANopen/stack/301/CO_SDOserver.c ****             uint8_t tempBuff[CO_CONFIG_SDO_SRV_BUFFER_SIZE + 1] = {0};
 624:../CANopen/stack/301/CO_SDOserver.c ****             for (int i = 0; i < countRd; i++) {
 625:../CANopen/stack/301/CO_SDOserver.c ****                 if((i % 2) == 0) {
 626:../CANopen/stack/301/CO_SDOserver.c ****                     tempBuff[i] = (((uint16_t *)bufShifted)[i/2]) & 0x00FF;
 627:../CANopen/stack/301/CO_SDOserver.c ****                 } else {
 628:../CANopen/stack/301/CO_SDOserver.c ****                     tempBuff[i] = ((((uint16_t *)bufShifted)[i/2]) >> 8) & 0x00FF;
 629:../CANopen/stack/301/CO_SDOserver.c ****                 }
 630:../CANopen/stack/301/CO_SDOserver.c ****             }
 631:../CANopen/stack/301/CO_SDOserver.c **** 
 632:../CANopen/stack/301/CO_SDOserver.c ****             for (int i = 0; i < countRd; i++) {
 633:../CANopen/stack/301/CO_SDOserver.c ****                 bufShifted[i] = tempBuff[i];
 634:../CANopen/stack/301/CO_SDOserver.c ****             }
 635:../CANopen/stack/301/CO_SDOserver.c ****         }
 636:../CANopen/stack/301/CO_SDOserver.c **** #endif
 637:../CANopen/stack/301/CO_SDOserver.c **** 
 638:../CANopen/stack/301/CO_SDOserver.c ****         if (lock) { CO_UNLOCK_OD(SDO->CANdevTx); }
 639:../CANopen/stack/301/CO_SDOserver.c **** 
 640:../CANopen/stack/301/CO_SDOserver.c ****         if (odRet != ODR_OK && odRet != ODR_PARTIAL) {
 1836              	 .loc 3 640 0
 1837 00a0 97F92F30 	 ldrsb r3,[r7,#47]
 1838 00a4 002B     	 cmp r3,#0
 1839 00a6 11D0     	 beq .L115
 1840              	 .loc 3 640 0 is_stmt 0 discriminator 1
 1841 00a8 97F92F30 	 ldrsb r3,[r7,#47]
 1842 00ac B3F1FF3F 	 cmp r3,#-1
 1843 00b0 0CD0     	 beq .L115
 641:../CANopen/stack/301/CO_SDOserver.c ****             *abortCode = (CO_SDO_abortCode_t)OD_getSDOabCode(odRet);
 1844              	 .loc 3 641 0 is_stmt 1
 1845 00b2 97F92F30 	 ldrsb r3,[r7,#47]
 1846 00b6 1846     	 mov r0,r3
 1847 00b8 FFF7FEFF 	 bl OD_getSDOabCode
 1848 00bc 0246     	 mov r2,r0
 1849 00be BB68     	 ldr r3,[r7,#8]
 1850 00c0 1A60     	 str r2,[r3]
 642:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_ABORT;
 1851              	 .loc 3 642 0
 1852 00c2 FB68     	 ldr r3,[r7,#12]
 1853 00c4 0122     	 movs r2,#1
 1854 00c6 1A75     	 strb r2,[r3,#20]
 643:../CANopen/stack/301/CO_SDOserver.c ****             return false;
 1855              	 .loc 3 643 0
 1856 00c8 0023     	 movs r3,#0
 1857 00ca 4DE0     	 b .L123
 1858              	.L115:
 644:../CANopen/stack/301/CO_SDOserver.c ****         }
 645:../CANopen/stack/301/CO_SDOserver.c **** 
 646:../CANopen/stack/301/CO_SDOserver.c ****         /* if data is string, send only data up to null termination */
 647:../CANopen/stack/301/CO_SDOserver.c ****         if (countRd > 0 && (SDO->OD_IO.stream.attribute & ODA_STR) != 0) {
 1859              	 .loc 3 647 0
 1860 00cc 7B69     	 ldr r3,[r7,#20]
 1861 00ce 002B     	 cmp r3,#0
 1862 00d0 23D0     	 beq .L117
 1863              	 .loc 3 647 0 is_stmt 0 discriminator 1
 1864 00d2 FB68     	 ldr r3,[r7,#12]
 1865 00d4 93F82830 	 ldrb r3,[r3,#40]
 1866 00d8 DBB2     	 uxtb r3,r3
 1867 00da 5BB2     	 sxtb r3,r3
 1868 00dc 002B     	 cmp r3,#0
 1869 00de 1CDA     	 bge .L117
 1870              	.LBB9:
 648:../CANopen/stack/301/CO_SDOserver.c ****             bufShifted[countRd] = 0; /* (SDO->buf is one byte larger) */
 1871              	 .loc 3 648 0 is_stmt 1
 1872 00e0 7B69     	 ldr r3,[r7,#20]
 1873 00e2 FA69     	 ldr r2,[r7,#28]
 1874 00e4 1344     	 add r3,r3,r2
 1875 00e6 0022     	 movs r2,#0
 1876 00e8 1A70     	 strb r2,[r3]
 649:../CANopen/stack/301/CO_SDOserver.c ****             OD_size_t countStr = (OD_size_t)strlen((char *)bufShifted);
 1877              	 .loc 3 649 0
 1878 00ea F869     	 ldr r0,[r7,#28]
 1879 00ec FFF7FEFF 	 bl strlen
 1880 00f0 B862     	 str r0,[r7,#40]
 650:../CANopen/stack/301/CO_SDOserver.c ****             if (countStr == 0) countStr = 1; /* zero length is not allowed */
 1881              	 .loc 3 650 0
 1882 00f2 BB6A     	 ldr r3,[r7,#40]
 1883 00f4 002B     	 cmp r3,#0
 1884 00f6 01D1     	 bne .L118
 1885              	 .loc 3 650 0 is_stmt 0 discriminator 1
 1886 00f8 0123     	 movs r3,#1
 1887 00fa BB62     	 str r3,[r7,#40]
 1888              	.L118:
 651:../CANopen/stack/301/CO_SDOserver.c ****             if (countStr < countRd) {
 1889              	 .loc 3 651 0 is_stmt 1
 1890 00fc 7B69     	 ldr r3,[r7,#20]
 1891 00fe BA6A     	 ldr r2,[r7,#40]
 1892 0100 9A42     	 cmp r2,r3
 1893 0102 0AD2     	 bcs .L117
 652:../CANopen/stack/301/CO_SDOserver.c ****                 /* string terminator found, read is finished, shorten data */
 653:../CANopen/stack/301/CO_SDOserver.c ****                 countRd = countStr;
 1894              	 .loc 3 653 0
 1895 0104 BB6A     	 ldr r3,[r7,#40]
 1896 0106 7B61     	 str r3,[r7,#20]
 654:../CANopen/stack/301/CO_SDOserver.c ****                 odRet = ODR_OK;
 1897              	 .loc 3 654 0
 1898 0108 0023     	 movs r3,#0
 1899 010a 87F82F30 	 strb r3,[r7,#47]
 655:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->OD_IO.stream.dataLength = SDO->sizeTran + countRd;
 1900              	 .loc 3 655 0
 1901 010e FB68     	 ldr r3,[r7,#12]
 1902 0110 9A6E     	 ldr r2,[r3,#104]
 1903 0112 7B69     	 ldr r3,[r7,#20]
 1904 0114 1A44     	 add r2,r2,r3
 1905 0116 FB68     	 ldr r3,[r7,#12]
 1906 0118 1A62     	 str r2,[r3,#32]
 1907              	.L117:
 1908              	.LBE9:
 656:../CANopen/stack/301/CO_SDOserver.c ****             }
 657:../CANopen/stack/301/CO_SDOserver.c ****         }
 658:../CANopen/stack/301/CO_SDOserver.c **** 
 659:../CANopen/stack/301/CO_SDOserver.c ****         /* partial or finished read */
 660:../CANopen/stack/301/CO_SDOserver.c ****         SDO->bufOffsetWr = countRemain + countRd;
 1909              	 .loc 3 660 0
 1910 011a 7A69     	 ldr r2,[r7,#20]
 1911 011c 7B6A     	 ldr r3,[r7,#36]
 1912 011e 1A44     	 add r2,r2,r3
 1913 0120 FB68     	 ldr r3,[r7,#12]
 1914 0122 C3F8A020 	 str r2,[r3,#160]
 661:../CANopen/stack/301/CO_SDOserver.c ****         if (SDO->bufOffsetWr == 0 || odRet == ODR_PARTIAL) {
 1915              	 .loc 3 661 0
 1916 0126 FB68     	 ldr r3,[r7,#12]
 1917 0128 D3F8A030 	 ldr r3,[r3,#160]
 1918 012c 002B     	 cmp r3,#0
 1919 012e 04D0     	 beq .L119
 1920              	 .loc 3 661 0 is_stmt 0 discriminator 1
 1921 0130 97F92F30 	 ldrsb r3,[r7,#47]
 1922 0134 B3F1FF3F 	 cmp r3,#-1
 1923 0138 12D1     	 bne .L120
 1924              	.L119:
 662:../CANopen/stack/301/CO_SDOserver.c ****             SDO->finished = false;
 1925              	 .loc 3 662 0 is_stmt 1
 1926 013a FB68     	 ldr r3,[r7,#12]
 1927 013c 0022     	 movs r2,#0
 1928 013e 1A67     	 str r2,[r3,#112]
 663:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->bufOffsetWr < countMinimum) {
 1929              	 .loc 3 663 0
 1930 0140 FB68     	 ldr r3,[r7,#12]
 1931 0142 D3F8A020 	 ldr r2,[r3,#160]
 1932 0146 7B68     	 ldr r3,[r7,#4]
 1933 0148 9A42     	 cmp r2,r3
 1934 014a 07D2     	 bcs .L121
 664:../CANopen/stack/301/CO_SDOserver.c ****                 *abortCode = CO_SDO_AB_DEVICE_INCOMPAT;
 1935              	 .loc 3 664 0
 1936 014c BB68     	 ldr r3,[r7,#8]
 1937 014e 084A     	 ldr r2,.L124
 1938 0150 1A60     	 str r2,[r3]
 665:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
 1939              	 .loc 3 665 0
 1940 0152 FB68     	 ldr r3,[r7,#12]
 1941 0154 0122     	 movs r2,#1
 1942 0156 1A75     	 strb r2,[r3,#20]
 666:../CANopen/stack/301/CO_SDOserver.c ****                 return false;
 1943              	 .loc 3 666 0
 1944 0158 0023     	 movs r3,#0
 1945 015a 05E0     	 b .L123
 1946              	.L121:
 663:../CANopen/stack/301/CO_SDOserver.c ****                 *abortCode = CO_SDO_AB_DEVICE_INCOMPAT;
 1947              	 .loc 3 663 0
 1948 015c 00BF     	 nop
 1949 015e 02E0     	 b .L114
 1950              	.L120:
 667:../CANopen/stack/301/CO_SDOserver.c ****             }
 668:../CANopen/stack/301/CO_SDOserver.c ****         }
 669:../CANopen/stack/301/CO_SDOserver.c ****         else {
 670:../CANopen/stack/301/CO_SDOserver.c ****             SDO->finished = true;
 1951              	 .loc 3 670 0
 1952 0160 FB68     	 ldr r3,[r7,#12]
 1953 0162 0122     	 movs r2,#1
 1954 0164 1A67     	 str r2,[r3,#112]
 1955              	.L114:
 1956              	.LBE8:
 671:../CANopen/stack/301/CO_SDOserver.c ****         }
 672:../CANopen/stack/301/CO_SDOserver.c **** 
 673:../CANopen/stack/301/CO_SDOserver.c **** #ifdef CO_BIG_ENDIAN
 674:../CANopen/stack/301/CO_SDOserver.c ****         /* swap data if necessary */
 675:../CANopen/stack/301/CO_SDOserver.c ****         if ((SDO->OD_IO.stream.attribute & ODA_MB) != 0) {
 676:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->finished) {
 677:../CANopen/stack/301/CO_SDOserver.c ****                 /* int16_t .. uint64_t */
 678:../CANopen/stack/301/CO_SDOserver.c ****                 reverseBytes(bufShifted, countRd);
 679:../CANopen/stack/301/CO_SDOserver.c ****             }
 680:../CANopen/stack/301/CO_SDOserver.c ****             else {
 681:../CANopen/stack/301/CO_SDOserver.c ****                 abortCode = CO_SDO_AB_PRAM_INCOMPAT;
 682:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
 683:../CANopen/stack/301/CO_SDOserver.c ****                 return false;
 684:../CANopen/stack/301/CO_SDOserver.c ****             }
 685:../CANopen/stack/301/CO_SDOserver.c ****         }
 686:../CANopen/stack/301/CO_SDOserver.c **** #endif
 687:../CANopen/stack/301/CO_SDOserver.c **** 
 688:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK
 689:../CANopen/stack/301/CO_SDOserver.c ****         /* update the crc */
 690:../CANopen/stack/301/CO_SDOserver.c ****         if (calculateCrc && SDO->block_crcEnabled) {
 691:../CANopen/stack/301/CO_SDOserver.c ****             SDO->block_crc = crc16_ccitt(bufShifted, countRd, SDO->block_crc);
 692:../CANopen/stack/301/CO_SDOserver.c ****         }
 693:../CANopen/stack/301/CO_SDOserver.c **** #endif
 694:../CANopen/stack/301/CO_SDOserver.c **** 
 695:../CANopen/stack/301/CO_SDOserver.c ****     }
 696:../CANopen/stack/301/CO_SDOserver.c ****     return true;
 1957              	 .loc 3 696 0
 1958 0166 0123     	 movs r3,#1
 1959              	.L123:
 697:../CANopen/stack/301/CO_SDOserver.c **** }
 1960              	 .loc 3 697 0
 1961 0168 1846     	 mov r0,r3
 1962 016a 3437     	 adds r7,r7,#52
 1963              	.LCFI72:
 1964              	 .cfi_def_cfa_offset 12
 1965 016c BD46     	 mov sp,r7
 1966              	.LCFI73:
 1967              	 .cfi_def_cfa_register 13
 1968              	 
 1969 016e 90BD     	 pop {r4,r7,pc}
 1970              	.L125:
 1971              	 .align 2
 1972              	.L124:
 1973 0170 47000406 	 .word 100925511
 1974              	 .cfi_endproc
 1975              	.LFE38:
 1977              	 .section .text.CO_SDOserver_process,"ax",%progbits
 1978              	 .align 2
 1979              	 .global CO_SDOserver_process
 1980              	 .thumb
 1981              	 .thumb_func
 1983              	CO_SDOserver_process:
 1984              	.LFB39:
 698:../CANopen/stack/301/CO_SDOserver.c **** #endif
 699:../CANopen/stack/301/CO_SDOserver.c **** 
 700:../CANopen/stack/301/CO_SDOserver.c **** 
 701:../CANopen/stack/301/CO_SDOserver.c **** /******************************************************************************/
 702:../CANopen/stack/301/CO_SDOserver.c **** CO_SDO_return_t CO_SDOserver_process(CO_SDOserver_t *SDO,
 703:../CANopen/stack/301/CO_SDOserver.c ****                                      bool_t NMTisPreOrOperational,
 704:../CANopen/stack/301/CO_SDOserver.c ****                                      uint32_t timeDifference_us,
 705:../CANopen/stack/301/CO_SDOserver.c ****                                      uint32_t *timerNext_us)
 706:../CANopen/stack/301/CO_SDOserver.c **** {
 1985              	 .loc 3 706 0
 1986              	 .cfi_startproc
 1987              	 
 1988              	 
 1989 0000 90B5     	 push {r4,r7,lr}
 1990              	.LCFI74:
 1991              	 .cfi_def_cfa_offset 12
 1992              	 .cfi_offset 4,-12
 1993              	 .cfi_offset 7,-8
 1994              	 .cfi_offset 14,-4
 1995 0002 9BB0     	 sub sp,sp,#108
 1996              	.LCFI75:
 1997              	 .cfi_def_cfa_offset 120
 1998 0004 00AF     	 add r7,sp,#0
 1999              	.LCFI76:
 2000              	 .cfi_def_cfa_register 7
 2001 0006 F860     	 str r0,[r7,#12]
 2002 0008 B960     	 str r1,[r7,#8]
 2003 000a 7A60     	 str r2,[r7,#4]
 2004 000c 3B60     	 str r3,[r7]
 707:../CANopen/stack/301/CO_SDOserver.c ****     if (SDO == NULL) {
 2005              	 .loc 3 707 0
 2006 000e FB68     	 ldr r3,[r7,#12]
 2007 0010 002B     	 cmp r3,#0
 2008 0012 02D1     	 bne .L127
 708:../CANopen/stack/301/CO_SDOserver.c ****         return CO_SDO_RT_wrongArguments;
 2009              	 .loc 3 708 0
 2010 0014 FE23     	 movs r3,#254
 2011 0016 00F005BD 	 b .L210
 2012              	.L127:
 709:../CANopen/stack/301/CO_SDOserver.c ****     }
 710:../CANopen/stack/301/CO_SDOserver.c **** 
 711:../CANopen/stack/301/CO_SDOserver.c ****     (void)timerNext_us; /* may be unused */
 712:../CANopen/stack/301/CO_SDOserver.c **** 
 713:../CANopen/stack/301/CO_SDOserver.c ****     CO_SDO_return_t ret = CO_SDO_RT_waitingResponse;
 2013              	 .loc 3 713 0
 2014 001a 0123     	 movs r3,#1
 2015 001c 87F86730 	 strb r3,[r7,#103]
 714:../CANopen/stack/301/CO_SDOserver.c ****     CO_SDO_abortCode_t abortCode = CO_SDO_AB_NONE;
 2016              	 .loc 3 714 0
 2017 0020 0023     	 movs r3,#0
 2018 0022 BB62     	 str r3,[r7,#40]
 715:../CANopen/stack/301/CO_SDOserver.c ****     bool_t isNew = CO_FLAG_READ(SDO->CANrxNew);
 2019              	 .loc 3 715 0
 2020 0024 FB68     	 ldr r3,[r7,#12]
 2021 0026 9B6B     	 ldr r3,[r3,#56]
 2022 0028 002B     	 cmp r3,#0
 2023 002a 14BF     	 ite ne
 2024 002c 0123     	 movne r3,#1
 2025 002e 0023     	 moveq r3,#0
 2026 0030 DBB2     	 uxtb r3,r3
 2027 0032 7B65     	 str r3,[r7,#84]
 716:../CANopen/stack/301/CO_SDOserver.c **** 
 717:../CANopen/stack/301/CO_SDOserver.c **** 
 718:../CANopen/stack/301/CO_SDOserver.c ****     if (SDO->valid && SDO->state == CO_SDO_ST_IDLE && !isNew) {
 2028              	 .loc 3 718 0
 2029 0034 FB68     	 ldr r3,[r7,#12]
 2030 0036 1B69     	 ldr r3,[r3,#16]
 2031 0038 002B     	 cmp r3,#0
 2032 003a 0BD0     	 beq .L129
 2033              	 .loc 3 718 0 is_stmt 0 discriminator 1
 2034 003c FB68     	 ldr r3,[r7,#12]
 2035 003e 1B7D     	 ldrb r3,[r3,#20]
 2036 0040 DBB2     	 uxtb r3,r3
 2037 0042 002B     	 cmp r3,#0
 2038 0044 06D1     	 bne .L129
 2039              	 .loc 3 718 0 discriminator 2
 2040 0046 7B6D     	 ldr r3,[r7,#84]
 2041 0048 002B     	 cmp r3,#0
 2042 004a 03D1     	 bne .L129
 719:../CANopen/stack/301/CO_SDOserver.c ****         /* Idle and nothing new */
 720:../CANopen/stack/301/CO_SDOserver.c ****         ret = CO_SDO_RT_ok_communicationEnd;
 2043              	 .loc 3 720 0 is_stmt 1
 2044 004c 0023     	 movs r3,#0
 2045 004e 87F86730 	 strb r3,[r7,#103]
 2046 0052 CCE2     	 b .L130
 2047              	.L129:
 721:../CANopen/stack/301/CO_SDOserver.c ****     }
 722:../CANopen/stack/301/CO_SDOserver.c ****     else if (!NMTisPreOrOperational || !SDO->valid) {
 2048              	 .loc 3 722 0
 2049 0054 BB68     	 ldr r3,[r7,#8]
 2050 0056 002B     	 cmp r3,#0
 2051 0058 03D0     	 beq .L131
 2052              	 .loc 3 722 0 is_stmt 0 discriminator 1
 2053 005a FB68     	 ldr r3,[r7,#12]
 2054 005c 1B69     	 ldr r3,[r3,#16]
 2055 005e 002B     	 cmp r3,#0
 2056 0060 09D1     	 bne .L132
 2057              	.L131:
 723:../CANopen/stack/301/CO_SDOserver.c ****         /* SDO is allowed only in operational or pre-operational NMT state
 724:../CANopen/stack/301/CO_SDOserver.c ****          * and must be valid */
 725:../CANopen/stack/301/CO_SDOserver.c ****         SDO->state = CO_SDO_ST_IDLE;
 2058              	 .loc 3 725 0 is_stmt 1
 2059 0062 FB68     	 ldr r3,[r7,#12]
 2060 0064 0022     	 movs r2,#0
 2061 0066 1A75     	 strb r2,[r3,#20]
 726:../CANopen/stack/301/CO_SDOserver.c ****         CO_FLAG_CLEAR(SDO->CANrxNew);
 2062              	 .loc 3 726 0
 2063 0068 FB68     	 ldr r3,[r7,#12]
 2064 006a 0022     	 movs r2,#0
 2065 006c 9A63     	 str r2,[r3,#56]
 727:../CANopen/stack/301/CO_SDOserver.c ****         ret = CO_SDO_RT_ok_communicationEnd;
 2066              	 .loc 3 727 0
 2067 006e 0023     	 movs r3,#0
 2068 0070 87F86730 	 strb r3,[r7,#103]
 2069 0074 BBE2     	 b .L130
 2070              	.L132:
 728:../CANopen/stack/301/CO_SDOserver.c ****     }
 729:../CANopen/stack/301/CO_SDOserver.c ****     /* CAN data received ******************************************************/
 730:../CANopen/stack/301/CO_SDOserver.c ****     else if (isNew) {
 2071              	 .loc 3 730 0
 2072 0076 7B6D     	 ldr r3,[r7,#84]
 2073 0078 002B     	 cmp r3,#0
 2074 007a 00F0B882 	 beq .L130
 731:../CANopen/stack/301/CO_SDOserver.c ****         if (SDO->state == CO_SDO_ST_IDLE) { /* new SDO communication? */
 2075              	 .loc 3 731 0
 2076 007e FB68     	 ldr r3,[r7,#12]
 2077 0080 1B7D     	 ldrb r3,[r3,#20]
 2078 0082 DBB2     	 uxtb r3,r3
 2079 0084 002B     	 cmp r3,#0
 2080 0086 40F0D380 	 bne .L133
 2081              	.LBB10:
 732:../CANopen/stack/301/CO_SDOserver.c ****             bool_t upload = false;
 2082              	 .loc 3 732 0
 2083 008a 0023     	 movs r3,#0
 2084 008c 3B66     	 str r3,[r7,#96]
 733:../CANopen/stack/301/CO_SDOserver.c **** 
 734:../CANopen/stack/301/CO_SDOserver.c ****             if ((SDO->CANrxData[0] & 0xF0) == 0x20) {
 2085              	 .loc 3 734 0
 2086 008e FB68     	 ldr r3,[r7,#12]
 2087 0090 93F83C30 	 ldrb r3,[r3,#60]
 2088 0094 03F0F003 	 and r3,r3,#240
 2089 0098 202B     	 cmp r3,#32
 2090 009a 03D1     	 bne .L134
 735:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_DOWNLOAD_INITIATE_REQ;
 2091              	 .loc 3 735 0
 2092 009c FB68     	 ldr r3,[r7,#12]
 2093 009e 1122     	 movs r2,#17
 2094 00a0 1A75     	 strb r2,[r3,#20]
 2095 00a2 0FE0     	 b .L135
 2096              	.L134:
 736:../CANopen/stack/301/CO_SDOserver.c ****             }
 737:../CANopen/stack/301/CO_SDOserver.c ****             else if (SDO->CANrxData[0] == 0x40) {
 2097              	 .loc 3 737 0
 2098 00a4 FB68     	 ldr r3,[r7,#12]
 2099 00a6 93F83C30 	 ldrb r3,[r3,#60]
 2100 00aa 402B     	 cmp r3,#64
 2101 00ac 05D1     	 bne .L136
 738:../CANopen/stack/301/CO_SDOserver.c ****                 upload = true;
 2102              	 .loc 3 738 0
 2103 00ae 0123     	 movs r3,#1
 2104 00b0 3B66     	 str r3,[r7,#96]
 739:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_UPLOAD_INITIATE_REQ;
 2105              	 .loc 3 739 0
 2106 00b2 FB68     	 ldr r3,[r7,#12]
 2107 00b4 2122     	 movs r2,#33
 2108 00b6 1A75     	 strb r2,[r3,#20]
 2109 00b8 04E0     	 b .L135
 2110              	.L136:
 740:../CANopen/stack/301/CO_SDOserver.c ****             }
 741:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK
 742:../CANopen/stack/301/CO_SDOserver.c ****             else if ((SDO->CANrxData[0] & 0xF9) == 0xC0) {
 743:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_DOWNLOAD_BLK_INITIATE_REQ;
 744:../CANopen/stack/301/CO_SDOserver.c ****             }
 745:../CANopen/stack/301/CO_SDOserver.c ****             else if ((SDO->CANrxData[0] & 0xFB) == 0xA0) {
 746:../CANopen/stack/301/CO_SDOserver.c ****                 upload = true;
 747:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_UPLOAD_BLK_INITIATE_REQ;
 748:../CANopen/stack/301/CO_SDOserver.c ****             }
 749:../CANopen/stack/301/CO_SDOserver.c **** #endif
 750:../CANopen/stack/301/CO_SDOserver.c ****             else {
 751:../CANopen/stack/301/CO_SDOserver.c ****                 abortCode = CO_SDO_AB_CMD;
 2111              	 .loc 3 751 0
 2112 00ba AD4B     	 ldr r3,.L212
 2113 00bc BB62     	 str r3,[r7,#40]
 752:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
 2114              	 .loc 3 752 0
 2115 00be FB68     	 ldr r3,[r7,#12]
 2116 00c0 0122     	 movs r2,#1
 2117 00c2 1A75     	 strb r2,[r3,#20]
 2118              	.L135:
 753:../CANopen/stack/301/CO_SDOserver.c ****             }
 754:../CANopen/stack/301/CO_SDOserver.c **** 
 755:../CANopen/stack/301/CO_SDOserver.c ****             /* if no error search object dictionary for new SDO request */
 756:../CANopen/stack/301/CO_SDOserver.c ****             if (abortCode == CO_SDO_AB_NONE) {
 2119              	 .loc 3 756 0
 2120 00c4 BB6A     	 ldr r3,[r7,#40]
 2121 00c6 002B     	 cmp r3,#0
 2122 00c8 65D1     	 bne .L137
 2123              	.LBB11:
 757:../CANopen/stack/301/CO_SDOserver.c ****                 ODR_t odRet;
 758:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->index = ((uint16_t)SDO->CANrxData[2]) << 8
 2124              	 .loc 3 758 0
 2125 00ca FB68     	 ldr r3,[r7,#12]
 2126 00cc 93F83E30 	 ldrb r3,[r3,#62]
 2127 00d0 1B02     	 lsls r3,r3,#8
 2128 00d2 9AB2     	 uxth r2,r3
 759:../CANopen/stack/301/CO_SDOserver.c ****                              | SDO->CANrxData[1];
 2129              	 .loc 3 759 0
 2130 00d4 FB68     	 ldr r3,[r7,#12]
 2131 00d6 93F83D30 	 ldrb r3,[r3,#61]
 758:../CANopen/stack/301/CO_SDOserver.c ****                              | SDO->CANrxData[1];
 2132              	 .loc 3 758 0
 2133 00da 9BB2     	 uxth r3,r3
 2134 00dc 1343     	 orrs r3,r3,r2
 2135 00de 9BB2     	 uxth r3,r3
 2136 00e0 9AB2     	 uxth r2,r3
 2137 00e2 FB68     	 ldr r3,[r7,#12]
 2138 00e4 9A86     	 strh r2,[r3,#52]
 760:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->subIndex = SDO->CANrxData[3];
 2139              	 .loc 3 760 0
 2140 00e6 FB68     	 ldr r3,[r7,#12]
 2141 00e8 93F83F20 	 ldrb r2,[r3,#63]
 2142 00ec FB68     	 ldr r3,[r7,#12]
 2143 00ee 83F83620 	 strb r2,[r3,#54]
 761:../CANopen/stack/301/CO_SDOserver.c ****                 odRet = OD_getSub(OD_find(SDO->OD, SDO->index), SDO->subIndex,
 2144              	 .loc 3 761 0
 2145 00f2 FB68     	 ldr r3,[r7,#12]
 2146 00f4 9A68     	 ldr r2,[r3,#8]
 2147 00f6 FB68     	 ldr r3,[r7,#12]
 2148 00f8 9B8E     	 ldrh r3,[r3,#52]
 2149 00fa 1046     	 mov r0,r2
 2150 00fc 1946     	 mov r1,r3
 2151 00fe FFF7FEFF 	 bl OD_find
 2152 0102 0146     	 mov r1,r0
 2153 0104 FB68     	 ldr r3,[r7,#12]
 2154 0106 93F83620 	 ldrb r2,[r3,#54]
 2155 010a FB68     	 ldr r3,[r7,#12]
 2156 010c 1833     	 adds r3,r3,#24
 2157 010e 0846     	 mov r0,r1
 2158 0110 1146     	 mov r1,r2
 2159 0112 1A46     	 mov r2,r3
 2160 0114 0023     	 movs r3,#0
 2161 0116 FFF7FEFF 	 bl OD_getSub
 2162 011a 0346     	 mov r3,r0
 2163 011c 87F85330 	 strb r3,[r7,#83]
 762:../CANopen/stack/301/CO_SDOserver.c ****                                   &SDO->OD_IO, false);
 763:../CANopen/stack/301/CO_SDOserver.c ****                 if (odRet != ODR_OK) {
 2164              	 .loc 3 763 0
 2165 0120 97F95330 	 ldrsb r3,[r7,#83]
 2166 0124 002B     	 cmp r3,#0
 2167 0126 0AD0     	 beq .L138
 764:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = (CO_SDO_abortCode_t)OD_getSDOabCode(odRet);
 2168              	 .loc 3 764 0
 2169 0128 97F95330 	 ldrsb r3,[r7,#83]
 2170 012c 1846     	 mov r0,r3
 2171 012e FFF7FEFF 	 bl OD_getSDOabCode
 2172 0132 0346     	 mov r3,r0
 2173 0134 BB62     	 str r3,[r7,#40]
 765:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
 2174              	 .loc 3 765 0
 2175 0136 FB68     	 ldr r3,[r7,#12]
 2176 0138 0122     	 movs r2,#1
 2177 013a 1A75     	 strb r2,[r3,#20]
 2178 013c 2BE0     	 b .L137
 2179              	.L138:
 766:../CANopen/stack/301/CO_SDOserver.c ****                 }
 767:../CANopen/stack/301/CO_SDOserver.c ****                 else {
 768:../CANopen/stack/301/CO_SDOserver.c ****                     /* verify read/write attributes */
 769:../CANopen/stack/301/CO_SDOserver.c ****                     if ((SDO->OD_IO.stream.attribute & ODA_SDO_RW) == 0) {
 2180              	 .loc 3 769 0
 2181 013e FB68     	 ldr r3,[r7,#12]
 2182 0140 93F82830 	 ldrb r3,[r3,#40]
 2183 0144 03F00303 	 and r3,r3,#3
 2184 0148 002B     	 cmp r3,#0
 2185 014a 05D1     	 bne .L139
 770:../CANopen/stack/301/CO_SDOserver.c ****                         abortCode = CO_SDO_AB_UNSUPPORTED_ACCESS;
 2186              	 .loc 3 770 0
 2187 014c 894B     	 ldr r3,.L212+4
 2188 014e BB62     	 str r3,[r7,#40]
 771:../CANopen/stack/301/CO_SDOserver.c ****                         SDO->state = CO_SDO_ST_ABORT;
 2189              	 .loc 3 771 0
 2190 0150 FB68     	 ldr r3,[r7,#12]
 2191 0152 0122     	 movs r2,#1
 2192 0154 1A75     	 strb r2,[r3,#20]
 2193 0156 1EE0     	 b .L137
 2194              	.L139:
 772:../CANopen/stack/301/CO_SDOserver.c ****                     }
 773:../CANopen/stack/301/CO_SDOserver.c ****                     else if (upload
 2195              	 .loc 3 773 0
 2196 0158 3B6E     	 ldr r3,[r7,#96]
 2197 015a 002B     	 cmp r3,#0
 2198 015c 0CD0     	 beq .L140
 774:../CANopen/stack/301/CO_SDOserver.c ****                              && (SDO->OD_IO.stream.attribute & ODA_SDO_R) == 0
 2199              	 .loc 3 774 0
 2200 015e FB68     	 ldr r3,[r7,#12]
 2201 0160 93F82830 	 ldrb r3,[r3,#40]
 2202 0164 03F00103 	 and r3,r3,#1
 2203 0168 002B     	 cmp r3,#0
 2204 016a 05D1     	 bne .L140
 775:../CANopen/stack/301/CO_SDOserver.c ****                     ) {
 776:../CANopen/stack/301/CO_SDOserver.c ****                         abortCode = CO_SDO_AB_WRITEONLY;
 2205              	 .loc 3 776 0
 2206 016c 824B     	 ldr r3,.L212+8
 2207 016e BB62     	 str r3,[r7,#40]
 777:../CANopen/stack/301/CO_SDOserver.c ****                         SDO->state = CO_SDO_ST_ABORT;
 2208              	 .loc 3 777 0
 2209 0170 FB68     	 ldr r3,[r7,#12]
 2210 0172 0122     	 movs r2,#1
 2211 0174 1A75     	 strb r2,[r3,#20]
 2212 0176 0EE0     	 b .L137
 2213              	.L140:
 778:../CANopen/stack/301/CO_SDOserver.c ****                     }
 779:../CANopen/stack/301/CO_SDOserver.c ****                     else if (!upload
 2214              	 .loc 3 779 0
 2215 0178 3B6E     	 ldr r3,[r7,#96]
 2216 017a 002B     	 cmp r3,#0
 2217 017c 0BD1     	 bne .L137
 780:../CANopen/stack/301/CO_SDOserver.c ****                              && (SDO->OD_IO.stream.attribute & ODA_SDO_W) == 0
 2218              	 .loc 3 780 0
 2219 017e FB68     	 ldr r3,[r7,#12]
 2220 0180 93F82830 	 ldrb r3,[r3,#40]
 2221 0184 03F00203 	 and r3,r3,#2
 2222 0188 002B     	 cmp r3,#0
 2223 018a 04D1     	 bne .L137
 781:../CANopen/stack/301/CO_SDOserver.c ****                     ) {
 782:../CANopen/stack/301/CO_SDOserver.c ****                         abortCode = CO_SDO_AB_READONLY;
 2224              	 .loc 3 782 0
 2225 018c 7B4B     	 ldr r3,.L212+12
 2226 018e BB62     	 str r3,[r7,#40]
 783:../CANopen/stack/301/CO_SDOserver.c ****                         SDO->state = CO_SDO_ST_ABORT;
 2227              	 .loc 3 783 0
 2228 0190 FB68     	 ldr r3,[r7,#12]
 2229 0192 0122     	 movs r2,#1
 2230 0194 1A75     	 strb r2,[r3,#20]
 2231              	.L137:
 2232              	.LBE11:
 784:../CANopen/stack/301/CO_SDOserver.c ****                     }
 785:../CANopen/stack/301/CO_SDOserver.c ****                 }
 786:../CANopen/stack/301/CO_SDOserver.c ****             }
 787:../CANopen/stack/301/CO_SDOserver.c **** 
 788:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
 789:../CANopen/stack/301/CO_SDOserver.c ****             /* load data from object dictionary, if upload and no error */
 790:../CANopen/stack/301/CO_SDOserver.c ****             if (upload && abortCode == CO_SDO_AB_NONE) {
 2233              	 .loc 3 790 0
 2234 0196 3B6E     	 ldr r3,[r7,#96]
 2235 0198 002B     	 cmp r3,#0
 2236 019a 49D0     	 beq .L133
 2237              	 .loc 3 790 0 is_stmt 0 discriminator 1
 2238 019c BB6A     	 ldr r3,[r7,#40]
 2239 019e 002B     	 cmp r3,#0
 2240 01a0 46D1     	 bne .L133
 791:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->bufOffsetRd = SDO->bufOffsetWr = 0;
 2241              	 .loc 3 791 0 is_stmt 1
 2242 01a2 FB68     	 ldr r3,[r7,#12]
 2243 01a4 0022     	 movs r2,#0
 2244 01a6 C3F8A020 	 str r2,[r3,#160]
 2245 01aa FB68     	 ldr r3,[r7,#12]
 2246 01ac D3F8A020 	 ldr r2,[r3,#160]
 2247 01b0 FB68     	 ldr r3,[r7,#12]
 2248 01b2 C3F8A420 	 str r2,[r3,#164]
 792:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->sizeTran = 0;
 2249              	 .loc 3 792 0
 2250 01b6 FB68     	 ldr r3,[r7,#12]
 2251 01b8 0022     	 movs r2,#0
 2252 01ba 9A66     	 str r2,[r3,#104]
 793:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->finished = false;
 2253              	 .loc 3 793 0
 2254 01bc FB68     	 ldr r3,[r7,#12]
 2255 01be 0022     	 movs r2,#0
 2256 01c0 1A67     	 str r2,[r3,#112]
 794:../CANopen/stack/301/CO_SDOserver.c **** 
 795:../CANopen/stack/301/CO_SDOserver.c ****                 if (readFromOd(SDO, &abortCode, 7, false)) {
 2257              	 .loc 3 795 0
 2258 01c2 07F12803 	 add r3,r7,#40
 2259 01c6 F868     	 ldr r0,[r7,#12]
 2260 01c8 1946     	 mov r1,r3
 2261 01ca 0722     	 movs r2,#7
 2262 01cc 0023     	 movs r3,#0
 2263 01ce FFF7FEFF 	 bl readFromOd
 2264 01d2 0346     	 mov r3,r0
 2265 01d4 002B     	 cmp r3,#0
 2266 01d6 2BD0     	 beq .L133
 796:../CANopen/stack/301/CO_SDOserver.c ****                     /* Size of variable in OD (may not be known yet) */
 797:../CANopen/stack/301/CO_SDOserver.c ****                     if (SDO->finished) {
 2267              	 .loc 3 797 0
 2268 01d8 FB68     	 ldr r3,[r7,#12]
 2269 01da 1B6F     	 ldr r3,[r3,#112]
 2270 01dc 002B     	 cmp r3,#0
 2271 01de 1AD0     	 beq .L141
 798:../CANopen/stack/301/CO_SDOserver.c ****                         /* OD variable was completely read, its size is known */
 799:../CANopen/stack/301/CO_SDOserver.c **** 
 800:../CANopen/stack/301/CO_SDOserver.c ****                         SDO->sizeInd = SDO->OD_IO.stream.dataLength;
 2272              	 .loc 3 800 0
 2273 01e0 FB68     	 ldr r3,[r7,#12]
 2274 01e2 1A6A     	 ldr r2,[r3,#32]
 2275 01e4 FB68     	 ldr r3,[r7,#12]
 2276 01e6 5A66     	 str r2,[r3,#100]
 801:../CANopen/stack/301/CO_SDOserver.c **** 
 802:../CANopen/stack/301/CO_SDOserver.c ****                         if (SDO->sizeInd == 0) {
 2277              	 .loc 3 802 0
 2278 01e8 FB68     	 ldr r3,[r7,#12]
 2279 01ea 5B6E     	 ldr r3,[r3,#100]
 2280 01ec 002B     	 cmp r3,#0
 2281 01ee 05D1     	 bne .L142
 803:../CANopen/stack/301/CO_SDOserver.c ****                             SDO->sizeInd = SDO->bufOffsetWr;
 2282              	 .loc 3 803 0
 2283 01f0 FB68     	 ldr r3,[r7,#12]
 2284 01f2 D3F8A020 	 ldr r2,[r3,#160]
 2285 01f6 FB68     	 ldr r3,[r7,#12]
 2286 01f8 5A66     	 str r2,[r3,#100]
 2287 01fa 19E0     	 b .L133
 2288              	.L142:
 804:../CANopen/stack/301/CO_SDOserver.c ****                         }
 805:../CANopen/stack/301/CO_SDOserver.c ****                         else if (SDO->sizeInd != SDO->bufOffsetWr) {
 2289              	 .loc 3 805 0
 2290 01fc FB68     	 ldr r3,[r7,#12]
 2291 01fe 5A6E     	 ldr r2,[r3,#100]
 2292 0200 FB68     	 ldr r3,[r7,#12]
 2293 0202 D3F8A030 	 ldr r3,[r3,#160]
 2294 0206 9A42     	 cmp r2,r3
 2295 0208 12D0     	 beq .L133
 806:../CANopen/stack/301/CO_SDOserver.c ****                             abortCode = CO_SDO_AB_DEVICE_INCOMPAT;
 2296              	 .loc 3 806 0
 2297 020a 5D4B     	 ldr r3,.L212+16
 2298 020c BB62     	 str r3,[r7,#40]
 807:../CANopen/stack/301/CO_SDOserver.c ****                             SDO->state = CO_SDO_ST_ABORT;
 2299              	 .loc 3 807 0
 2300 020e FB68     	 ldr r3,[r7,#12]
 2301 0210 0122     	 movs r2,#1
 2302 0212 1A75     	 strb r2,[r3,#20]
 2303 0214 0CE0     	 b .L133
 2304              	.L141:
 808:../CANopen/stack/301/CO_SDOserver.c ****                         }
 809:../CANopen/stack/301/CO_SDOserver.c ****                     }
 810:../CANopen/stack/301/CO_SDOserver.c ****                     else {
 811:../CANopen/stack/301/CO_SDOserver.c ****                         /* If data type is string, size is not known */
 812:../CANopen/stack/301/CO_SDOserver.c ****                         SDO->sizeInd = (SDO->OD_IO.stream.attribute&ODA_STR)==0
 2305              	 .loc 3 812 0
 2306 0216 FB68     	 ldr r3,[r7,#12]
 2307 0218 93F82830 	 ldrb r3,[r3,#40]
 2308 021c DBB2     	 uxtb r3,r3
 813:../CANopen/stack/301/CO_SDOserver.c ****                                      ? SDO->OD_IO.stream.dataLength
 814:../CANopen/stack/301/CO_SDOserver.c ****                                      : 0;
 2309              	 .loc 3 814 0
 2310 021e 5BB2     	 sxtb r3,r3
 2311 0220 002B     	 cmp r3,#0
 2312 0222 02DB     	 blt .L144
 2313              	 .loc 3 814 0 is_stmt 0 discriminator 1
 2314 0224 FB68     	 ldr r3,[r7,#12]
 2315 0226 1B6A     	 ldr r3,[r3,#32]
 2316 0228 00E0     	 b .L145
 2317              	.L144:
 2318              	 .loc 3 814 0 discriminator 2
 2319 022a 0023     	 movs r3,#0
 2320              	.L145:
 812:../CANopen/stack/301/CO_SDOserver.c ****                                      ? SDO->OD_IO.stream.dataLength
 2321              	 .loc 3 812 0 is_stmt 1
 2322 022c FA68     	 ldr r2,[r7,#12]
 2323 022e 5366     	 str r3,[r2,#100]
 2324              	.L133:
 2325              	.LBE10:
 815:../CANopen/stack/301/CO_SDOserver.c ****                     }
 816:../CANopen/stack/301/CO_SDOserver.c ****                 }
 817:../CANopen/stack/301/CO_SDOserver.c ****             }
 818:../CANopen/stack/301/CO_SDOserver.c **** #endif /* (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED */
 819:../CANopen/stack/301/CO_SDOserver.c ****         } /* (SDO->state == CO_SDO_ST_IDLE) */
 820:../CANopen/stack/301/CO_SDOserver.c **** 
 821:../CANopen/stack/301/CO_SDOserver.c ****         if (SDO->state != CO_SDO_ST_IDLE && SDO->state != CO_SDO_ST_ABORT)
 2326              	 .loc 3 821 0
 2327 0230 FB68     	 ldr r3,[r7,#12]
 2328 0232 1B7D     	 ldrb r3,[r3,#20]
 2329 0234 DBB2     	 uxtb r3,r3
 2330 0236 002B     	 cmp r3,#0
 2331 0238 00F0D181 	 beq .L146
 2332              	 .loc 3 821 0 is_stmt 0 discriminator 1
 2333 023c FB68     	 ldr r3,[r7,#12]
 2334 023e 1B7D     	 ldrb r3,[r3,#20]
 2335 0240 DBB2     	 uxtb r3,r3
 2336 0242 012B     	 cmp r3,#1
 2337 0244 00F0CB81 	 beq .L146
 822:../CANopen/stack/301/CO_SDOserver.c ****         switch (SDO->state) {
 2338              	 .loc 3 822 0 is_stmt 1
 2339 0248 FB68     	 ldr r3,[r7,#12]
 2340 024a 1B7D     	 ldrb r3,[r3,#20]
 2341 024c DBB2     	 uxtb r3,r3
 2342 024e 113B     	 subs r3,r3,#17
 2343 0250 122B     	 cmp r3,#18
 2344 0252 00F2BF81 	 bhi .L147
 2345 0256 01A2     	 adr r2,.L149
 2346 0258 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 2347              	 .p2align 2
 2348              	.L149:
 2349 025c A9020000 	 .word .L148+1
 2350 0260 D5050000 	 .word .L147+1
 2351 0264 77040000 	 .word .L150+1
 2352 0268 D5050000 	 .word .L147+1
 2353 026c D5050000 	 .word .L147+1
 2354 0270 D5050000 	 .word .L147+1
 2355 0274 D5050000 	 .word .L147+1
 2356 0278 D5050000 	 .word .L147+1
 2357 027c D5050000 	 .word .L147+1
 2358 0280 D5050000 	 .word .L147+1
 2359 0284 D5050000 	 .word .L147+1
 2360 0288 D5050000 	 .word .L147+1
 2361 028c D5050000 	 .word .L147+1
 2362 0290 D5050000 	 .word .L147+1
 2363 0294 D5050000 	 .word .L147+1
 2364 0298 D5050000 	 .word .L147+1
 2365 029c 73050000 	 .word .L151+1
 2366 02a0 D5050000 	 .word .L147+1
 2367 02a4 7B050000 	 .word .L152+1
 2368              	 .p2align 1
 2369              	.L148:
 823:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_DOWNLOAD_INITIATE_REQ: {
 824:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->CANrxData[0] & 0x02) {
 2370              	 .loc 3 824 0
 2371 02a8 FB68     	 ldr r3,[r7,#12]
 2372 02aa 93F83C30 	 ldrb r3,[r3,#60]
 2373 02ae 03F00203 	 and r3,r3,#2
 2374 02b2 002B     	 cmp r3,#0
 2375 02b4 00F09D80 	 beq .L153
 2376              	.LBB12:
 825:../CANopen/stack/301/CO_SDOserver.c ****                 /* Expedited transfer, max 4 bytes of data */
 826:../CANopen/stack/301/CO_SDOserver.c **** 
 827:../CANopen/stack/301/CO_SDOserver.c ****                 /* Size of OD variable (>0 if indicated) */
 828:../CANopen/stack/301/CO_SDOserver.c ****                 OD_size_t sizeInOd = SDO->OD_IO.stream.dataLength;
 2377              	 .loc 3 828 0
 2378 02b8 FB68     	 ldr r3,[r7,#12]
 2379 02ba 1B6A     	 ldr r3,[r3,#32]
 2380 02bc FB64     	 str r3,[r7,#76]
 829:../CANopen/stack/301/CO_SDOserver.c **** 
 830:../CANopen/stack/301/CO_SDOserver.c ****                 /* Get SDO data size (indicated by SDO client or get from OD) */
 831:../CANopen/stack/301/CO_SDOserver.c ****                 OD_size_t dataSizeToWrite = 4;
 2381              	 .loc 3 831 0
 2382 02be 0423     	 movs r3,#4
 2383 02c0 FB65     	 str r3,[r7,#92]
 832:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->CANrxData[0] & 0x01)
 2384              	 .loc 3 832 0
 2385 02c2 FB68     	 ldr r3,[r7,#12]
 2386 02c4 93F83C30 	 ldrb r3,[r3,#60]
 2387 02c8 03F00103 	 and r3,r3,#1
 2388 02cc 002B     	 cmp r3,#0
 2389 02ce 0AD0     	 beq .L154
 833:../CANopen/stack/301/CO_SDOserver.c ****                     dataSizeToWrite -= (SDO->CANrxData[0] >> 2) & 0x03;
 2390              	 .loc 3 833 0
 2391 02d0 FB68     	 ldr r3,[r7,#12]
 2392 02d2 93F83C30 	 ldrb r3,[r3,#60]
 2393 02d6 9B08     	 lsrs r3,r3,#2
 2394 02d8 DBB2     	 uxtb r3,r3
 2395 02da 03F00303 	 and r3,r3,#3
 2396 02de FA6D     	 ldr r2,[r7,#92]
 2397 02e0 D31A     	 subs r3,r2,r3
 2398 02e2 FB65     	 str r3,[r7,#92]
 2399 02e4 07E0     	 b .L155
 2400              	.L154:
 834:../CANopen/stack/301/CO_SDOserver.c ****                 else if (sizeInOd > 0 && sizeInOd < 4)
 2401              	 .loc 3 834 0
 2402 02e6 FB6C     	 ldr r3,[r7,#76]
 2403 02e8 002B     	 cmp r3,#0
 2404 02ea 04D0     	 beq .L155
 2405              	 .loc 3 834 0 is_stmt 0 discriminator 1
 2406 02ec FB6C     	 ldr r3,[r7,#76]
 2407 02ee 032B     	 cmp r3,#3
 2408 02f0 01D8     	 bhi .L155
 835:../CANopen/stack/301/CO_SDOserver.c ****                     dataSizeToWrite = sizeInOd;
 2409              	 .loc 3 835 0 is_stmt 1
 2410 02f2 FB6C     	 ldr r3,[r7,#76]
 2411 02f4 FB65     	 str r3,[r7,#92]
 2412              	.L155:
 836:../CANopen/stack/301/CO_SDOserver.c **** 
 837:../CANopen/stack/301/CO_SDOserver.c ****                 /* copy data to the temp buffer, swap data if necessary */
 838:../CANopen/stack/301/CO_SDOserver.c ****                 uint8_t buf[6] = {0};
 2413              	 .loc 3 838 0
 2414 02f6 0023     	 movs r3,#0
 2415 02f8 3B62     	 str r3,[r7,#32]
 2416 02fa 0023     	 movs r3,#0
 2417 02fc BB84     	 strh r3,[r7,#36]
 839:../CANopen/stack/301/CO_SDOserver.c ****                 memcpy(buf, &SDO->CANrxData[4], dataSizeToWrite);
 2418              	 .loc 3 839 0
 2419 02fe FB68     	 ldr r3,[r7,#12]
 2420 0300 4033     	 adds r3,r3,#64
 2421 0302 07F12002 	 add r2,r7,#32
 2422 0306 1046     	 mov r0,r2
 2423 0308 1946     	 mov r1,r3
 2424 030a FA6D     	 ldr r2,[r7,#92]
 2425 030c FFF7FEFF 	 bl memcpy
 840:../CANopen/stack/301/CO_SDOserver.c **** #ifdef CO_BIG_ENDIAN
 841:../CANopen/stack/301/CO_SDOserver.c ****                 if ((SDO->OD_IO.stream.attribute & ODA_MB) != 0) {
 842:../CANopen/stack/301/CO_SDOserver.c ****                     reverseBytes(buf, dataSizeToWrite);
 843:../CANopen/stack/301/CO_SDOserver.c ****                 }
 844:../CANopen/stack/301/CO_SDOserver.c **** #endif
 845:../CANopen/stack/301/CO_SDOserver.c **** 
 846:../CANopen/stack/301/CO_SDOserver.c ****                 /* If dataType is string, then size of data downloaded may be
 847:../CANopen/stack/301/CO_SDOserver.c ****                  * shorter as size of OD data buffer. If so, add two zero bytes
 848:../CANopen/stack/301/CO_SDOserver.c ****                  * to terminate (unicode) string. Shorten also OD data size,
 849:../CANopen/stack/301/CO_SDOserver.c ****                  * (temporary, send information about EOF into OD_IO.write) */
 850:../CANopen/stack/301/CO_SDOserver.c ****                 if ((SDO->OD_IO.stream.attribute & ODA_STR) != 0
 2426              	 .loc 3 850 0
 2427 0310 FB68     	 ldr r3,[r7,#12]
 2428 0312 93F82830 	 ldrb r3,[r3,#40]
 2429 0316 DBB2     	 uxtb r3,r3
 2430 0318 5BB2     	 sxtb r3,r3
 2431 031a 002B     	 cmp r3,#0
 2432 031c 17DA     	 bge .L156
 851:../CANopen/stack/301/CO_SDOserver.c ****                     && (sizeInOd == 0 || dataSizeToWrite < sizeInOd)
 2433              	 .loc 3 851 0
 2434 031e FB6C     	 ldr r3,[r7,#76]
 2435 0320 002B     	 cmp r3,#0
 2436 0322 03D0     	 beq .L157
 2437              	 .loc 3 851 0 is_stmt 0 discriminator 1
 2438 0324 FA6D     	 ldr r2,[r7,#92]
 2439 0326 FB6C     	 ldr r3,[r7,#76]
 2440 0328 9A42     	 cmp r2,r3
 2441 032a 10D2     	 bcs .L156
 2442              	.L157:
 2443              	.LBB13:
 852:../CANopen/stack/301/CO_SDOserver.c ****                 ) {
 853:../CANopen/stack/301/CO_SDOserver.c ****                     OD_size_t delta = sizeInOd - dataSizeToWrite;
 2444              	 .loc 3 853 0 is_stmt 1
 2445 032c FA6C     	 ldr r2,[r7,#76]
 2446 032e FB6D     	 ldr r3,[r7,#92]
 2447 0330 D31A     	 subs r3,r2,r3
 2448 0332 BB64     	 str r3,[r7,#72]
 854:../CANopen/stack/301/CO_SDOserver.c ****                     dataSizeToWrite += delta == 1 ? 1 : 2;
 2449              	 .loc 3 854 0
 2450 0334 BB6C     	 ldr r3,[r7,#72]
 2451 0336 012B     	 cmp r3,#1
 2452 0338 01D1     	 bne .L158
 2453              	 .loc 3 854 0 is_stmt 0 discriminator 1
 2454 033a 0123     	 movs r3,#1
 2455 033c 00E0     	 b .L159
 2456              	.L158:
 2457              	 .loc 3 854 0 discriminator 2
 2458 033e 0223     	 movs r3,#2
 2459              	.L159:
 2460              	 .loc 3 854 0 discriminator 4
 2461 0340 FA6D     	 ldr r2,[r7,#92]
 2462 0342 1344     	 add r3,r3,r2
 2463 0344 FB65     	 str r3,[r7,#92]
 855:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->OD_IO.stream.dataLength = dataSizeToWrite;
 2464              	 .loc 3 855 0 is_stmt 1 discriminator 4
 2465 0346 FB68     	 ldr r3,[r7,#12]
 2466 0348 FA6D     	 ldr r2,[r7,#92]
 2467 034a 1A62     	 str r2,[r3,#32]
 2468              	.LBE13:
 852:../CANopen/stack/301/CO_SDOserver.c ****                 ) {
 2469              	 .loc 3 852 0 discriminator 4
 2470 034c 22E0     	 b .L160
 2471              	.L156:
 856:../CANopen/stack/301/CO_SDOserver.c ****                 }
 857:../CANopen/stack/301/CO_SDOserver.c ****                 else if (sizeInOd == 0) {
 2472              	 .loc 3 857 0
 2473 034e FB6C     	 ldr r3,[r7,#76]
 2474 0350 002B     	 cmp r3,#0
 2475 0352 03D1     	 bne .L161
 858:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->OD_IO.stream.dataLength = dataSizeToWrite;
 2476              	 .loc 3 858 0
 2477 0354 FB68     	 ldr r3,[r7,#12]
 2478 0356 FA6D     	 ldr r2,[r7,#92]
 2479 0358 1A62     	 str r2,[r3,#32]
 2480 035a 1BE0     	 b .L160
 2481              	.L161:
 859:../CANopen/stack/301/CO_SDOserver.c ****                 }
 860:../CANopen/stack/301/CO_SDOserver.c ****                 /* Verify if size of data downloaded matches data size in OD. */
 861:../CANopen/stack/301/CO_SDOserver.c ****                 else if (dataSizeToWrite != sizeInOd) {
 2482              	 .loc 3 861 0
 2483 035c FA6D     	 ldr r2,[r7,#92]
 2484 035e FB6C     	 ldr r3,[r7,#76]
 2485 0360 9A42     	 cmp r2,r3
 2486 0362 17D0     	 beq .L160
 862:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = (dataSizeToWrite > sizeInOd) ?
 2487              	 .loc 3 862 0
 2488 0364 FA6D     	 ldr r2,[r7,#92]
 2489 0366 FB6C     	 ldr r3,[r7,#76]
 2490 0368 9A42     	 cmp r2,r3
 2491 036a 0DD9     	 bls .L162
 2492              	 .loc 3 862 0 is_stmt 0 discriminator 1
 2493 036c 054B     	 ldr r3,.L212+20
 2494 036e 0CE0     	 b .L163
 2495              	.L213:
 2496              	 .align 2
 2497              	.L212:
 2498 0370 01000405 	 .word 84148225
 2499 0374 00000106 	 .word 100728832
 2500 0378 01000106 	 .word 100728833
 2501 037c 02000106 	 .word 100728834
 2502 0380 47000406 	 .word 100925511
 2503 0384 12000706 	 .word 101122066
 2504              	.L162:
 2505              	 .loc 3 862 0 discriminator 2
 2506 0388 8E4B     	 ldr r3,.L214
 2507              	.L163:
 2508              	 .loc 3 862 0 discriminator 4
 2509 038a BB62     	 str r3,[r7,#40]
 863:../CANopen/stack/301/CO_SDOserver.c ****                                 CO_SDO_AB_DATA_LONG : CO_SDO_AB_DATA_SHORT;
 864:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
 2510              	 .loc 3 864 0 is_stmt 1 discriminator 4
 2511 038c FB68     	 ldr r3,[r7,#12]
 2512 038e 0122     	 movs r2,#1
 2513 0390 1A75     	 strb r2,[r3,#20]
 865:../CANopen/stack/301/CO_SDOserver.c ****                     break;
 2514              	 .loc 3 865 0 discriminator 4
 2515 0392 24E1     	 b .L146
 2516              	.L160:
 866:../CANopen/stack/301/CO_SDOserver.c ****                 }
 867:../CANopen/stack/301/CO_SDOserver.c **** 
 868:../CANopen/stack/301/CO_SDOserver.c ****                 /* Copy data */
 869:../CANopen/stack/301/CO_SDOserver.c ****                 OD_size_t countWritten = 0;
 2517              	 .loc 3 869 0
 2518 0394 0023     	 movs r3,#0
 2519 0396 FB61     	 str r3,[r7,#28]
 870:../CANopen/stack/301/CO_SDOserver.c ****                 bool_t lock = OD_mappable(&SDO->OD_IO.stream);
 2520              	 .loc 3 870 0
 2521 0398 FB68     	 ldr r3,[r7,#12]
 2522 039a 1833     	 adds r3,r3,#24
 2523 039c 1846     	 mov r0,r3
 2524 039e FFF7FEFF 	 bl OD_mappable
 2525 03a2 7864     	 str r0,[r7,#68]
 871:../CANopen/stack/301/CO_SDOserver.c **** 
 872:../CANopen/stack/301/CO_SDOserver.c ****                 if (lock) { CO_LOCK_OD(SDO->CANdevTx); }
 873:../CANopen/stack/301/CO_SDOserver.c **** #if (C2000_PORT != 0)
 874:../CANopen/stack/301/CO_SDOserver.c ****                 uint8_t bufTemp[6];
 875:../CANopen/stack/301/CO_SDOserver.c ****                 void * pbufTemp = (void *)bufTemp;
 876:../CANopen/stack/301/CO_SDOserver.c ****                 memcpy(bufTemp, buf, sizeof(buf));
 877:../CANopen/stack/301/CO_SDOserver.c ****                 if(SDO->OD_IO.write == OD_writeOriginal) {
 878:../CANopen/stack/301/CO_SDOserver.c ****                     if(dataSizeToWrite == 1) {
 879:../CANopen/stack/301/CO_SDOserver.c ****                         *((uint8_t *)pbufTemp) = CO_getUint8(buf);
 880:../CANopen/stack/301/CO_SDOserver.c ****                     } else if(dataSizeToWrite == 2) {
 881:../CANopen/stack/301/CO_SDOserver.c ****                         *((uint16_t *)pbufTemp) = CO_getUint16(buf);
 882:../CANopen/stack/301/CO_SDOserver.c ****                     } else if(dataSizeToWrite == 4) {
 883:../CANopen/stack/301/CO_SDOserver.c ****                         *((uint32_t *)pbufTemp) = CO_getUint32(buf);
 884:../CANopen/stack/301/CO_SDOserver.c ****                     }
 885:../CANopen/stack/301/CO_SDOserver.c ****                 }
 886:../CANopen/stack/301/CO_SDOserver.c ****                 ODR_t odRet = SDO->OD_IO.write(&SDO->OD_IO.stream, bufTemp,
 887:../CANopen/stack/301/CO_SDOserver.c ****                                                dataSizeToWrite, &countWritten);
 888:../CANopen/stack/301/CO_SDOserver.c **** #else
 889:../CANopen/stack/301/CO_SDOserver.c ****                 ODR_t odRet = SDO->OD_IO.write(&SDO->OD_IO.stream, buf,
 2526              	 .loc 3 889 0
 2527 03a4 FB68     	 ldr r3,[r7,#12]
 2528 03a6 1C6B     	 ldr r4,[r3,#48]
 2529 03a8 FB68     	 ldr r3,[r7,#12]
 2530 03aa 03F11801 	 add r1,r3,#24
 2531 03ae 07F12002 	 add r2,r7,#32
 2532 03b2 07F11C03 	 add r3,r7,#28
 2533 03b6 0846     	 mov r0,r1
 2534 03b8 1146     	 mov r1,r2
 2535 03ba FA6D     	 ldr r2,[r7,#92]
 2536 03bc A047     	 blx r4
 2537 03be 0346     	 mov r3,r0
 2538 03c0 87F84330 	 strb r3,[r7,#67]
 890:../CANopen/stack/301/CO_SDOserver.c ****                                                dataSizeToWrite, &countWritten);
 891:../CANopen/stack/301/CO_SDOserver.c **** #endif
 892:../CANopen/stack/301/CO_SDOserver.c ****                 if (lock) { CO_UNLOCK_OD(SDO->CANdevTx); }
 893:../CANopen/stack/301/CO_SDOserver.c **** 
 894:../CANopen/stack/301/CO_SDOserver.c ****                 if (odRet != ODR_OK) {
 2539              	 .loc 3 894 0
 2540 03c4 97F94330 	 ldrsb r3,[r7,#67]
 2541 03c8 002B     	 cmp r3,#0
 2542 03ca 0BD0     	 beq .L165
 895:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = (CO_SDO_abortCode_t)OD_getSDOabCode(odRet);
 2543              	 .loc 3 895 0
 2544 03cc 97F94330 	 ldrsb r3,[r7,#67]
 2545 03d0 1846     	 mov r0,r3
 2546 03d2 FFF7FEFF 	 bl OD_getSDOabCode
 2547 03d6 0346     	 mov r3,r0
 2548 03d8 BB62     	 str r3,[r7,#40]
 896:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
 2549              	 .loc 3 896 0
 2550 03da FB68     	 ldr r3,[r7,#12]
 2551 03dc 0122     	 movs r2,#1
 2552 03de 1A75     	 strb r2,[r3,#20]
 897:../CANopen/stack/301/CO_SDOserver.c ****                     break;
 2553              	 .loc 3 897 0
 2554 03e0 00BF     	 nop
 2555 03e2 FCE0     	 b .L146
 2556              	.L165:
 898:../CANopen/stack/301/CO_SDOserver.c ****                 }
 899:../CANopen/stack/301/CO_SDOserver.c ****                 else {
 900:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_DOWNLOAD_INITIATE_RSP;
 2557              	 .loc 3 900 0
 2558 03e4 FB68     	 ldr r3,[r7,#12]
 2559 03e6 1222     	 movs r2,#18
 2560 03e8 1A75     	 strb r2,[r3,#20]
 901:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
 902:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->finished = true;
 2561              	 .loc 3 902 0
 2562 03ea FB68     	 ldr r3,[r7,#12]
 2563 03ec 0122     	 movs r2,#1
 2564 03ee 1A67     	 str r2,[r3,#112]
 2565              	.LBE12:
 903:../CANopen/stack/301/CO_SDOserver.c **** #endif
 904:../CANopen/stack/301/CO_SDOserver.c ****                 }
 905:../CANopen/stack/301/CO_SDOserver.c ****             }
 906:../CANopen/stack/301/CO_SDOserver.c ****             else {
 907:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
 908:../CANopen/stack/301/CO_SDOserver.c ****                 /* segmented transfer, is size indicated? */
 909:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->CANrxData[0] & 0x01) {
 910:../CANopen/stack/301/CO_SDOserver.c ****                     uint32_t size;
 911:../CANopen/stack/301/CO_SDOserver.c ****                     OD_size_t sizeInOd = SDO->OD_IO.stream.dataLength;
 912:../CANopen/stack/301/CO_SDOserver.c **** 
 913:../CANopen/stack/301/CO_SDOserver.c **** #if (C2000_PORT != 0)
 914:../CANopen/stack/301/CO_SDOserver.c ****                     size = 0;
 915:../CANopen/stack/301/CO_SDOserver.c ****                     size = SDO->CANrxData[4] & 0x00FF;
 916:../CANopen/stack/301/CO_SDOserver.c ****                     size += ((uint32_t)(SDO->CANrxData[5] & 0x00FF)) << 8;
 917:../CANopen/stack/301/CO_SDOserver.c ****                     size += ((uint32_t)(SDO->CANrxData[6] & 0x00FF)) << 16;
 918:../CANopen/stack/301/CO_SDOserver.c ****                     size += ((uint32_t)(SDO->CANrxData[7] & 0x00FF)) << 24;
 919:../CANopen/stack/301/CO_SDOserver.c **** #else
 920:../CANopen/stack/301/CO_SDOserver.c ****                     memcpy(&size, &SDO->CANrxData[4], sizeof(size));
 921:../CANopen/stack/301/CO_SDOserver.c **** #endif
 922:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->sizeInd = CO_SWAP_32(size);
 923:../CANopen/stack/301/CO_SDOserver.c **** 
 924:../CANopen/stack/301/CO_SDOserver.c ****                     /* Indicated size of SDO matches sizeof OD variable? */
 925:../CANopen/stack/301/CO_SDOserver.c ****                     if (sizeInOd > 0) {
 926:../CANopen/stack/301/CO_SDOserver.c ****                         if (SDO->sizeInd > sizeInOd) {
 927:../CANopen/stack/301/CO_SDOserver.c ****                             abortCode = CO_SDO_AB_DATA_LONG;
 928:../CANopen/stack/301/CO_SDOserver.c ****                             SDO->state = CO_SDO_ST_ABORT;
 929:../CANopen/stack/301/CO_SDOserver.c ****                             break;
 930:../CANopen/stack/301/CO_SDOserver.c ****                         }
 931:../CANopen/stack/301/CO_SDOserver.c ****                         /* strings are allowed to be shorter */
 932:../CANopen/stack/301/CO_SDOserver.c ****                         else if (SDO->sizeInd < sizeInOd
 933:../CANopen/stack/301/CO_SDOserver.c ****                                  && (SDO->OD_IO.stream.attribute & ODA_STR) == 0
 934:../CANopen/stack/301/CO_SDOserver.c ****                         ) {
 935:../CANopen/stack/301/CO_SDOserver.c ****                             abortCode = CO_SDO_AB_DATA_SHORT;
 936:../CANopen/stack/301/CO_SDOserver.c ****                             SDO->state = CO_SDO_ST_ABORT;
 937:../CANopen/stack/301/CO_SDOserver.c ****                             break;
 938:../CANopen/stack/301/CO_SDOserver.c ****                         }
 939:../CANopen/stack/301/CO_SDOserver.c ****                      }
 940:../CANopen/stack/301/CO_SDOserver.c ****                 }
 941:../CANopen/stack/301/CO_SDOserver.c ****                 else {
 942:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->sizeInd = 0;
 943:../CANopen/stack/301/CO_SDOserver.c ****                 }
 944:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_DOWNLOAD_INITIATE_RSP;
 945:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->finished = false;
 946:../CANopen/stack/301/CO_SDOserver.c **** #else
 947:../CANopen/stack/301/CO_SDOserver.c ****                 abortCode = CO_SDO_AB_UNSUPPORTED_ACCESS;
 948:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
 949:../CANopen/stack/301/CO_SDOserver.c **** #endif
 950:../CANopen/stack/301/CO_SDOserver.c ****             }
 951:../CANopen/stack/301/CO_SDOserver.c ****             break;
 2566              	 .loc 3 951 0
 2567 03f0 F5E0     	 b .L146
 2568              	.L153:
 909:../CANopen/stack/301/CO_SDOserver.c ****                     uint32_t size;
 2569              	 .loc 3 909 0
 2570 03f2 FB68     	 ldr r3,[r7,#12]
 2571 03f4 93F83C30 	 ldrb r3,[r3,#60]
 2572 03f8 03F00103 	 and r3,r3,#1
 2573 03fc 002B     	 cmp r3,#0
 2574 03fe 30D0     	 beq .L167
 2575              	.LBB14:
 911:../CANopen/stack/301/CO_SDOserver.c **** 
 2576              	 .loc 3 911 0
 2577 0400 FB68     	 ldr r3,[r7,#12]
 2578 0402 1B6A     	 ldr r3,[r3,#32]
 2579 0404 FB63     	 str r3,[r7,#60]
 920:../CANopen/stack/301/CO_SDOserver.c **** #endif
 2580              	 .loc 3 920 0
 2581 0406 FB68     	 ldr r3,[r7,#12]
 2582 0408 4033     	 adds r3,r3,#64
 2583 040a 07F11802 	 add r2,r7,#24
 2584 040e 1046     	 mov r0,r2
 2585 0410 1946     	 mov r1,r3
 2586 0412 0422     	 movs r2,#4
 2587 0414 FFF7FEFF 	 bl memcpy
 922:../CANopen/stack/301/CO_SDOserver.c **** 
 2588              	 .loc 3 922 0
 2589 0418 BA69     	 ldr r2,[r7,#24]
 2590 041a FB68     	 ldr r3,[r7,#12]
 2591 041c 5A66     	 str r2,[r3,#100]
 925:../CANopen/stack/301/CO_SDOserver.c ****                         if (SDO->sizeInd > sizeInOd) {
 2592              	 .loc 3 925 0
 2593 041e FB6B     	 ldr r3,[r7,#60]
 2594 0420 002B     	 cmp r3,#0
 2595 0422 1DD0     	 beq .L168
 926:../CANopen/stack/301/CO_SDOserver.c ****                             abortCode = CO_SDO_AB_DATA_LONG;
 2596              	 .loc 3 926 0
 2597 0424 FB68     	 ldr r3,[r7,#12]
 2598 0426 5A6E     	 ldr r2,[r3,#100]
 2599 0428 FB6B     	 ldr r3,[r7,#60]
 2600 042a 9A42     	 cmp r2,r3
 2601 042c 05D9     	 bls .L169
 927:../CANopen/stack/301/CO_SDOserver.c ****                             SDO->state = CO_SDO_ST_ABORT;
 2602              	 .loc 3 927 0
 2603 042e 664B     	 ldr r3,.L214+4
 2604 0430 BB62     	 str r3,[r7,#40]
 928:../CANopen/stack/301/CO_SDOserver.c ****                             break;
 2605              	 .loc 3 928 0
 2606 0432 FB68     	 ldr r3,[r7,#12]
 2607 0434 0122     	 movs r2,#1
 2608 0436 1A75     	 strb r2,[r3,#20]
 929:../CANopen/stack/301/CO_SDOserver.c ****                         }
 2609              	 .loc 3 929 0
 2610 0438 D1E0     	 b .L146
 2611              	.L169:
 932:../CANopen/stack/301/CO_SDOserver.c ****                                  && (SDO->OD_IO.stream.attribute & ODA_STR) == 0
 2612              	 .loc 3 932 0
 2613 043a FB68     	 ldr r3,[r7,#12]
 2614 043c 5A6E     	 ldr r2,[r3,#100]
 2615 043e FB6B     	 ldr r3,[r7,#60]
 2616 0440 9A42     	 cmp r2,r3
 2617 0442 0DD2     	 bcs .L168
 933:../CANopen/stack/301/CO_SDOserver.c ****                         ) {
 2618              	 .loc 3 933 0
 2619 0444 FB68     	 ldr r3,[r7,#12]
 2620 0446 93F82830 	 ldrb r3,[r3,#40]
 2621 044a DBB2     	 uxtb r3,r3
 2622 044c 5BB2     	 sxtb r3,r3
 2623 044e 002B     	 cmp r3,#0
 2624 0450 06DB     	 blt .L168
 935:../CANopen/stack/301/CO_SDOserver.c ****                             SDO->state = CO_SDO_ST_ABORT;
 2625              	 .loc 3 935 0
 2626 0452 5C4B     	 ldr r3,.L214
 2627 0454 BB62     	 str r3,[r7,#40]
 936:../CANopen/stack/301/CO_SDOserver.c ****                             break;
 2628              	 .loc 3 936 0
 2629 0456 FB68     	 ldr r3,[r7,#12]
 2630 0458 0122     	 movs r2,#1
 2631 045a 1A75     	 strb r2,[r3,#20]
 937:../CANopen/stack/301/CO_SDOserver.c ****                         }
 2632              	 .loc 3 937 0
 2633 045c 00BF     	 nop
 2634 045e BEE0     	 b .L146
 2635              	.L168:
 2636              	.LBE14:
 2637 0460 02E0     	 b .L171
 2638              	.L167:
 942:../CANopen/stack/301/CO_SDOserver.c ****                 }
 2639              	 .loc 3 942 0
 2640 0462 FB68     	 ldr r3,[r7,#12]
 2641 0464 0022     	 movs r2,#0
 2642 0466 5A66     	 str r2,[r3,#100]
 2643              	.L171:
 944:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->finished = false;
 2644              	 .loc 3 944 0
 2645 0468 FB68     	 ldr r3,[r7,#12]
 2646 046a 1222     	 movs r2,#18
 2647 046c 1A75     	 strb r2,[r3,#20]
 945:../CANopen/stack/301/CO_SDOserver.c **** #else
 2648              	 .loc 3 945 0
 2649 046e FB68     	 ldr r3,[r7,#12]
 2650 0470 0022     	 movs r2,#0
 2651 0472 1A67     	 str r2,[r3,#112]
 2652              	 .loc 3 951 0
 2653 0474 B3E0     	 b .L146
 2654              	.L150:
 952:../CANopen/stack/301/CO_SDOserver.c ****         }
 953:../CANopen/stack/301/CO_SDOserver.c **** 
 954:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
 955:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_DOWNLOAD_SEGMENT_REQ: {
 956:../CANopen/stack/301/CO_SDOserver.c ****             if ((SDO->CANrxData[0] & 0xE0) == 0x00) {
 2655              	 .loc 3 956 0
 2656 0476 FB68     	 ldr r3,[r7,#12]
 2657 0478 93F83C30 	 ldrb r3,[r3,#60]
 2658 047c 03F0E003 	 and r3,r3,#224
 2659 0480 002B     	 cmp r3,#0
 2660 0482 70D1     	 bne .L172
 2661              	.LBB15:
 957:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->finished = (SDO->CANrxData[0] & 0x01) != 0;
 2662              	 .loc 3 957 0
 2663 0484 FB68     	 ldr r3,[r7,#12]
 2664 0486 93F83C30 	 ldrb r3,[r3,#60]
 2665 048a 03F00103 	 and r3,r3,#1
 2666 048e 002B     	 cmp r3,#0
 2667 0490 14BF     	 ite ne
 2668 0492 0123     	 movne r3,#1
 2669 0494 0023     	 moveq r3,#0
 2670 0496 DBB2     	 uxtb r3,r3
 2671 0498 1A46     	 mov r2,r3
 2672 049a FB68     	 ldr r3,[r7,#12]
 2673 049c 1A67     	 str r2,[r3,#112]
 958:../CANopen/stack/301/CO_SDOserver.c **** 
 959:../CANopen/stack/301/CO_SDOserver.c ****                 /* verify and alternate toggle bit */
 960:../CANopen/stack/301/CO_SDOserver.c ****                 uint8_t toggle = SDO->CANrxData[0] & 0x10;
 2674              	 .loc 3 960 0
 2675 049e FB68     	 ldr r3,[r7,#12]
 2676 04a0 93F83C30 	 ldrb r3,[r3,#60]
 2677 04a4 03F01003 	 and r3,r3,#16
 2678 04a8 87F83B30 	 strb r3,[r7,#59]
 961:../CANopen/stack/301/CO_SDOserver.c ****                 if (toggle != SDO->toggle) {
 2679              	 .loc 3 961 0
 2680 04ac FB68     	 ldr r3,[r7,#12]
 2681 04ae 93F86C30 	 ldrb r3,[r3,#108]
 2682 04b2 97F83B20 	 ldrb r2,[r7,#59]
 2683 04b6 9A42     	 cmp r2,r3
 2684 04b8 05D0     	 beq .L173
 962:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_TOGGLE_BIT;
 2685              	 .loc 3 962 0
 2686 04ba 444B     	 ldr r3,.L214+8
 2687 04bc BB62     	 str r3,[r7,#40]
 963:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
 2688              	 .loc 3 963 0
 2689 04be FB68     	 ldr r3,[r7,#12]
 2690 04c0 0122     	 movs r2,#1
 2691 04c2 1A75     	 strb r2,[r3,#20]
 964:../CANopen/stack/301/CO_SDOserver.c ****                     break;
 2692              	 .loc 3 964 0
 2693 04c4 8BE0     	 b .L146
 2694              	.L173:
 965:../CANopen/stack/301/CO_SDOserver.c ****                 }
 966:../CANopen/stack/301/CO_SDOserver.c **** 
 967:../CANopen/stack/301/CO_SDOserver.c ****                 /* get data size and write data to the buffer */
 968:../CANopen/stack/301/CO_SDOserver.c ****                 OD_size_t count = 7 - ((SDO->CANrxData[0] >> 1) & 0x07);
 2695              	 .loc 3 968 0
 2696 04c6 FB68     	 ldr r3,[r7,#12]
 2697 04c8 93F83C30 	 ldrb r3,[r3,#60]
 2698 04cc 5B08     	 lsrs r3,r3,#1
 2699 04ce DBB2     	 uxtb r3,r3
 2700 04d0 DB43     	 mvns r3,r3
 2701 04d2 03F00703 	 and r3,r3,#7
 2702 04d6 7B63     	 str r3,[r7,#52]
 969:../CANopen/stack/301/CO_SDOserver.c ****                 memcpy(SDO->buf + SDO->bufOffsetWr, &SDO->CANrxData[1], count);
 2703              	 .loc 3 969 0
 2704 04d8 FB68     	 ldr r3,[r7,#12]
 2705 04da D3F8A030 	 ldr r3,[r3,#160]
 2706 04de 7833     	 adds r3,r3,#120
 2707 04e0 FA68     	 ldr r2,[r7,#12]
 2708 04e2 1344     	 add r3,r3,r2
 2709 04e4 1A1D     	 adds r2,r3,#4
 2710 04e6 FB68     	 ldr r3,[r7,#12]
 2711 04e8 3D33     	 adds r3,r3,#61
 2712 04ea 1046     	 mov r0,r2
 2713 04ec 1946     	 mov r1,r3
 2714 04ee 7A6B     	 ldr r2,[r7,#52]
 2715 04f0 FFF7FEFF 	 bl memcpy
 970:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->bufOffsetWr += count;
 2716              	 .loc 3 970 0
 2717 04f4 FB68     	 ldr r3,[r7,#12]
 2718 04f6 D3F8A020 	 ldr r2,[r3,#160]
 2719 04fa 7B6B     	 ldr r3,[r7,#52]
 2720 04fc 1A44     	 add r2,r2,r3
 2721 04fe FB68     	 ldr r3,[r7,#12]
 2722 0500 C3F8A020 	 str r2,[r3,#160]
 971:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->sizeTran += count;
 2723              	 .loc 3 971 0
 2724 0504 FB68     	 ldr r3,[r7,#12]
 2725 0506 9A6E     	 ldr r2,[r3,#104]
 2726 0508 7B6B     	 ldr r3,[r7,#52]
 2727 050a 1A44     	 add r2,r2,r3
 2728 050c FB68     	 ldr r3,[r7,#12]
 2729 050e 9A66     	 str r2,[r3,#104]
 972:../CANopen/stack/301/CO_SDOserver.c **** 
 973:../CANopen/stack/301/CO_SDOserver.c ****                 /* if data size exceeds variable size, abort */
 974:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->OD_IO.stream.dataLength > 0
 2730              	 .loc 3 974 0
 2731 0510 FB68     	 ldr r3,[r7,#12]
 2732 0512 1B6A     	 ldr r3,[r3,#32]
 2733 0514 002B     	 cmp r3,#0
 2734 0516 0BD0     	 beq .L174
 975:../CANopen/stack/301/CO_SDOserver.c ****                     && SDO->sizeTran > SDO->OD_IO.stream.dataLength
 2735              	 .loc 3 975 0
 2736 0518 FB68     	 ldr r3,[r7,#12]
 2737 051a 9A6E     	 ldr r2,[r3,#104]
 2738 051c FB68     	 ldr r3,[r7,#12]
 2739 051e 1B6A     	 ldr r3,[r3,#32]
 2740 0520 9A42     	 cmp r2,r3
 2741 0522 05D9     	 bls .L174
 976:../CANopen/stack/301/CO_SDOserver.c ****                 ) {
 977:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_DATA_LONG;
 2742              	 .loc 3 977 0
 2743 0524 284B     	 ldr r3,.L214+4
 2744 0526 BB62     	 str r3,[r7,#40]
 978:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
 2745              	 .loc 3 978 0
 2746 0528 FB68     	 ldr r3,[r7,#12]
 2747 052a 0122     	 movs r2,#1
 2748 052c 1A75     	 strb r2,[r3,#20]
 979:../CANopen/stack/301/CO_SDOserver.c ****                     break;
 2749              	 .loc 3 979 0
 2750 052e 56E0     	 b .L146
 2751              	.L174:
 980:../CANopen/stack/301/CO_SDOserver.c ****                 }
 981:../CANopen/stack/301/CO_SDOserver.c **** 
 982:../CANopen/stack/301/CO_SDOserver.c ****                 /* if necessary, empty the buffer */
 983:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->finished
 2752              	 .loc 3 983 0
 2753 0530 FB68     	 ldr r3,[r7,#12]
 2754 0532 1B6F     	 ldr r3,[r3,#112]
 2755 0534 002B     	 cmp r3,#0
 2756 0536 06D1     	 bne .L175
 984:../CANopen/stack/301/CO_SDOserver.c ****                     || (CO_CONFIG_SDO_SRV_BUFFER_SIZE - SDO->bufOffsetWr)<(7+2)
 2757              	 .loc 3 984 0
 2758 0538 FB68     	 ldr r3,[r7,#12]
 2759 053a D3F8A030 	 ldr r3,[r3,#160]
 2760 053e C3F12003 	 rsb r3,r3,#32
 2761 0542 082B     	 cmp r3,#8
 2762 0544 0BD8     	 bhi .L176
 2763              	.L175:
 985:../CANopen/stack/301/CO_SDOserver.c ****                 ) {
 986:../CANopen/stack/301/CO_SDOserver.c ****                     if (!validateAndWriteToOD(SDO, &abortCode, 0, 0))
 2764              	 .loc 3 986 0
 2765 0546 07F12803 	 add r3,r7,#40
 2766 054a F868     	 ldr r0,[r7,#12]
 2767 054c 1946     	 mov r1,r3
 2768 054e 0022     	 movs r2,#0
 2769 0550 0023     	 movs r3,#0
 2770 0552 FFF7FEFF 	 bl validateAndWriteToOD
 2771 0556 0346     	 mov r3,r0
 2772 0558 002B     	 cmp r3,#0
 2773 055a 00D1     	 bne .L176
 987:../CANopen/stack/301/CO_SDOserver.c ****                         break;
 2774              	 .loc 3 987 0
 2775 055c 3FE0     	 b .L146
 2776              	.L176:
 988:../CANopen/stack/301/CO_SDOserver.c ****                 }
 989:../CANopen/stack/301/CO_SDOserver.c **** 
 990:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_DOWNLOAD_SEGMENT_RSP;
 2777              	 .loc 3 990 0
 2778 055e FB68     	 ldr r3,[r7,#12]
 2779 0560 1422     	 movs r2,#20
 2780 0562 1A75     	 strb r2,[r3,#20]
 2781              	.LBE15:
 991:../CANopen/stack/301/CO_SDOserver.c ****             }
 992:../CANopen/stack/301/CO_SDOserver.c ****             else {
 993:../CANopen/stack/301/CO_SDOserver.c ****                 abortCode = CO_SDO_AB_CMD;
 994:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
 995:../CANopen/stack/301/CO_SDOserver.c ****             }
 996:../CANopen/stack/301/CO_SDOserver.c ****             break;
 2782              	 .loc 3 996 0
 2783 0564 3BE0     	 b .L146
 2784              	.L172:
 993:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
 2785              	 .loc 3 993 0
 2786 0566 1A4B     	 ldr r3,.L214+12
 2787 0568 BB62     	 str r3,[r7,#40]
 994:../CANopen/stack/301/CO_SDOserver.c ****             }
 2788              	 .loc 3 994 0
 2789 056a FB68     	 ldr r3,[r7,#12]
 2790 056c 0122     	 movs r2,#1
 2791 056e 1A75     	 strb r2,[r3,#20]
 2792              	 .loc 3 996 0
 2793 0570 35E0     	 b .L146
 2794              	.L151:
 997:../CANopen/stack/301/CO_SDOserver.c ****         }
 998:../CANopen/stack/301/CO_SDOserver.c **** #endif /* (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED */
 999:../CANopen/stack/301/CO_SDOserver.c **** 
1000:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_UPLOAD_INITIATE_REQ: {
1001:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_UPLOAD_INITIATE_RSP;
 2795              	 .loc 3 1001 0
 2796 0572 FB68     	 ldr r3,[r7,#12]
 2797 0574 2222     	 movs r2,#34
 2798 0576 1A75     	 strb r2,[r3,#20]
1002:../CANopen/stack/301/CO_SDOserver.c ****             break;
 2799              	 .loc 3 1002 0
 2800 0578 31E0     	 b .L146
 2801              	.L152:
1003:../CANopen/stack/301/CO_SDOserver.c ****         }
1004:../CANopen/stack/301/CO_SDOserver.c **** 
1005:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
1006:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_UPLOAD_SEGMENT_REQ: {
1007:../CANopen/stack/301/CO_SDOserver.c ****             if ((SDO->CANrxData[0] & 0xEF) == 0x60) {
 2802              	 .loc 3 1007 0
 2803 057a FB68     	 ldr r3,[r7,#12]
 2804 057c 93F83C30 	 ldrb r3,[r3,#60]
 2805 0580 03F0EF03 	 and r3,r3,#239
 2806 0584 602B     	 cmp r3,#96
 2807 0586 17D1     	 bne .L178
 2808              	.LBB16:
1008:../CANopen/stack/301/CO_SDOserver.c ****                 /* verify and alternate toggle bit */
1009:../CANopen/stack/301/CO_SDOserver.c ****                 uint8_t toggle = SDO->CANrxData[0] & 0x10;
 2809              	 .loc 3 1009 0
 2810 0588 FB68     	 ldr r3,[r7,#12]
 2811 058a 93F83C30 	 ldrb r3,[r3,#60]
 2812 058e 03F01003 	 and r3,r3,#16
 2813 0592 87F83330 	 strb r3,[r7,#51]
1010:../CANopen/stack/301/CO_SDOserver.c ****                 if (toggle != SDO->toggle) {
 2814              	 .loc 3 1010 0
 2815 0596 FB68     	 ldr r3,[r7,#12]
 2816 0598 93F86C30 	 ldrb r3,[r3,#108]
 2817 059c 97F83320 	 ldrb r2,[r7,#51]
 2818 05a0 9A42     	 cmp r2,r3
 2819 05a2 05D0     	 beq .L179
1011:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_TOGGLE_BIT;
 2820              	 .loc 3 1011 0
 2821 05a4 094B     	 ldr r3,.L214+8
 2822 05a6 BB62     	 str r3,[r7,#40]
1012:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
 2823              	 .loc 3 1012 0
 2824 05a8 FB68     	 ldr r3,[r7,#12]
 2825 05aa 0122     	 movs r2,#1
 2826 05ac 1A75     	 strb r2,[r3,#20]
1013:../CANopen/stack/301/CO_SDOserver.c ****                     break;
 2827              	 .loc 3 1013 0
 2828 05ae 16E0     	 b .L146
 2829              	.L179:
1014:../CANopen/stack/301/CO_SDOserver.c ****                 }
1015:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_UPLOAD_SEGMENT_RSP;
 2830              	 .loc 3 1015 0
 2831 05b0 FB68     	 ldr r3,[r7,#12]
 2832 05b2 2422     	 movs r2,#36
 2833 05b4 1A75     	 strb r2,[r3,#20]
 2834              	.LBE16:
1016:../CANopen/stack/301/CO_SDOserver.c ****             }
1017:../CANopen/stack/301/CO_SDOserver.c ****             else {
1018:../CANopen/stack/301/CO_SDOserver.c ****                 abortCode = CO_SDO_AB_CMD;
1019:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
1020:../CANopen/stack/301/CO_SDOserver.c ****             }
1021:../CANopen/stack/301/CO_SDOserver.c ****             break;
 2835              	 .loc 3 1021 0
 2836 05b6 12E0     	 b .L146
 2837              	.L178:
1018:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
 2838              	 .loc 3 1018 0
 2839 05b8 054B     	 ldr r3,.L214+12
 2840 05ba BB62     	 str r3,[r7,#40]
1019:../CANopen/stack/301/CO_SDOserver.c ****             }
 2841              	 .loc 3 1019 0
 2842 05bc FB68     	 ldr r3,[r7,#12]
 2843 05be 0122     	 movs r2,#1
 2844 05c0 1A75     	 strb r2,[r3,#20]
 2845              	 .loc 3 1021 0
 2846 05c2 0CE0     	 b .L146
 2847              	.L215:
 2848              	 .align 2
 2849              	.L214:
 2850 05c4 13000706 	 .word 101122067
 2851 05c8 12000706 	 .word 101122066
 2852 05cc 00000305 	 .word 84082688
 2853 05d0 01000405 	 .word 84148225
 2854              	.L147:
1022:../CANopen/stack/301/CO_SDOserver.c ****         }
1023:../CANopen/stack/301/CO_SDOserver.c **** #endif /* (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED */
1024:../CANopen/stack/301/CO_SDOserver.c **** 
1025:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK
1026:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_DOWNLOAD_BLK_INITIATE_REQ: {
1027:../CANopen/stack/301/CO_SDOserver.c ****             SDO->block_crcEnabled = (SDO->CANrxData[0] & 0x04) != 0;
1028:../CANopen/stack/301/CO_SDOserver.c **** 
1029:../CANopen/stack/301/CO_SDOserver.c ****             /* is size indicated? */
1030:../CANopen/stack/301/CO_SDOserver.c ****             if ((SDO->CANrxData[0] & 0x02) != 0) {
1031:../CANopen/stack/301/CO_SDOserver.c ****                 uint32_t size;
1032:../CANopen/stack/301/CO_SDOserver.c ****                 OD_size_t sizeInOd = SDO->OD_IO.stream.dataLength;
1033:../CANopen/stack/301/CO_SDOserver.c **** 
1034:../CANopen/stack/301/CO_SDOserver.c **** #if (C2000_PORT != 0)
1035:../CANopen/stack/301/CO_SDOserver.c ****                 size = 0;
1036:../CANopen/stack/301/CO_SDOserver.c ****                 size = SDO->CANrxData[4] & 0x00FF;
1037:../CANopen/stack/301/CO_SDOserver.c ****                 size += ((uint32_t)(SDO->CANrxData[5] & 0x00FF)) << 8;
1038:../CANopen/stack/301/CO_SDOserver.c ****                 size += ((uint32_t)(SDO->CANrxData[6] & 0x00FF)) << 16;
1039:../CANopen/stack/301/CO_SDOserver.c ****                 size += ((uint32_t)(SDO->CANrxData[7] & 0x00FF)) << 24;
1040:../CANopen/stack/301/CO_SDOserver.c **** #else
1041:../CANopen/stack/301/CO_SDOserver.c ****                 memcpy(&size, &SDO->CANrxData[4], sizeof(size));
1042:../CANopen/stack/301/CO_SDOserver.c **** #endif
1043:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->sizeInd = CO_SWAP_32(size);
1044:../CANopen/stack/301/CO_SDOserver.c **** 
1045:../CANopen/stack/301/CO_SDOserver.c ****                 /* Indicated size of SDO matches sizeof OD variable? */
1046:../CANopen/stack/301/CO_SDOserver.c ****                 if (sizeInOd > 0) {
1047:../CANopen/stack/301/CO_SDOserver.c ****                     if (SDO->sizeInd > sizeInOd) {
1048:../CANopen/stack/301/CO_SDOserver.c ****                         abortCode = CO_SDO_AB_DATA_LONG;
1049:../CANopen/stack/301/CO_SDOserver.c ****                         SDO->state = CO_SDO_ST_ABORT;
1050:../CANopen/stack/301/CO_SDOserver.c ****                         break;
1051:../CANopen/stack/301/CO_SDOserver.c ****                     }
1052:../CANopen/stack/301/CO_SDOserver.c ****                     /* strings are allowed to be shorter */
1053:../CANopen/stack/301/CO_SDOserver.c ****                     else if (SDO->sizeInd < sizeInOd
1054:../CANopen/stack/301/CO_SDOserver.c ****                              && (SDO->OD_IO.stream.attribute & ODA_STR) == 0
1055:../CANopen/stack/301/CO_SDOserver.c ****                     ) {
1056:../CANopen/stack/301/CO_SDOserver.c ****                         abortCode = CO_SDO_AB_DATA_SHORT;
1057:../CANopen/stack/301/CO_SDOserver.c ****                         SDO->state = CO_SDO_ST_ABORT;
1058:../CANopen/stack/301/CO_SDOserver.c ****                         break;
1059:../CANopen/stack/301/CO_SDOserver.c ****                     }
1060:../CANopen/stack/301/CO_SDOserver.c ****                 }
1061:../CANopen/stack/301/CO_SDOserver.c ****             }
1062:../CANopen/stack/301/CO_SDOserver.c ****             else {
1063:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->sizeInd = 0;
1064:../CANopen/stack/301/CO_SDOserver.c ****             }
1065:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_DOWNLOAD_BLK_INITIATE_RSP;
1066:../CANopen/stack/301/CO_SDOserver.c ****             SDO->finished = false;
1067:../CANopen/stack/301/CO_SDOserver.c ****             break;
1068:../CANopen/stack/301/CO_SDOserver.c ****         }
1069:../CANopen/stack/301/CO_SDOserver.c **** 
1070:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_REQ: {
1071:../CANopen/stack/301/CO_SDOserver.c ****             /* data are copied directly in the receive function */
1072:../CANopen/stack/301/CO_SDOserver.c ****             break;
1073:../CANopen/stack/301/CO_SDOserver.c ****         }
1074:../CANopen/stack/301/CO_SDOserver.c **** 
1075:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_DOWNLOAD_BLK_END_REQ: {
1076:../CANopen/stack/301/CO_SDOserver.c ****             if ((SDO->CANrxData[0] & 0xE3) == 0xC1) {
1077:../CANopen/stack/301/CO_SDOserver.c ****                 /* Get number of data bytes in last segment, that do not
1078:../CANopen/stack/301/CO_SDOserver.c ****                     * contain data. Then reduce buffer. */
1079:../CANopen/stack/301/CO_SDOserver.c ****                 uint8_t noData = ((SDO->CANrxData[0] >> 2) & 0x07);
1080:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->bufOffsetWr <= noData) {
1081:../CANopen/stack/301/CO_SDOserver.c ****                     /* just in case, should never happen */
1082:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_DEVICE_INCOMPAT;
1083:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
1084:../CANopen/stack/301/CO_SDOserver.c ****                     break;
1085:../CANopen/stack/301/CO_SDOserver.c ****                 }
1086:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->sizeTran -= noData;
1087:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->bufOffsetWr -= noData;
1088:../CANopen/stack/301/CO_SDOserver.c **** 
1089:../CANopen/stack/301/CO_SDOserver.c ****                 uint16_t crcClient = 0;
1090:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->block_crcEnabled) {
1091:../CANopen/stack/301/CO_SDOserver.c ****                     crcClient = ((uint16_t) SDO->CANrxData[2]) << 8;
1092:../CANopen/stack/301/CO_SDOserver.c ****                     crcClient |= SDO->CANrxData[1];
1093:../CANopen/stack/301/CO_SDOserver.c ****                 }
1094:../CANopen/stack/301/CO_SDOserver.c **** 
1095:../CANopen/stack/301/CO_SDOserver.c ****                 if (!validateAndWriteToOD(SDO, &abortCode, 2, crcClient))
1096:../CANopen/stack/301/CO_SDOserver.c ****                     break;
1097:../CANopen/stack/301/CO_SDOserver.c **** 
1098:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_DOWNLOAD_BLK_END_RSP;
1099:../CANopen/stack/301/CO_SDOserver.c ****             }
1100:../CANopen/stack/301/CO_SDOserver.c ****             else {
1101:../CANopen/stack/301/CO_SDOserver.c ****                 abortCode = CO_SDO_AB_CMD;
1102:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
1103:../CANopen/stack/301/CO_SDOserver.c ****             }
1104:../CANopen/stack/301/CO_SDOserver.c ****             break;
1105:../CANopen/stack/301/CO_SDOserver.c ****         }
1106:../CANopen/stack/301/CO_SDOserver.c **** 
1107:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_UPLOAD_BLK_INITIATE_REQ: {
1108:../CANopen/stack/301/CO_SDOserver.c ****             /* if pst (protocol switch threshold, byte5) is larger than data
1109:../CANopen/stack/301/CO_SDOserver.c ****              * size of OD variable, then switch to segmented transfer */
1110:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->sizeInd > 0 && SDO->CANrxData[5] > 0
1111:../CANopen/stack/301/CO_SDOserver.c ****                 && SDO->CANrxData[5] >= SDO->sizeInd)
1112:../CANopen/stack/301/CO_SDOserver.c ****             {
1113:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_UPLOAD_INITIATE_RSP;
1114:../CANopen/stack/301/CO_SDOserver.c ****             }
1115:../CANopen/stack/301/CO_SDOserver.c ****             else {
1116:../CANopen/stack/301/CO_SDOserver.c ****                 /* data were already loaded from OD variable, verify crc */
1117:../CANopen/stack/301/CO_SDOserver.c ****                 if ((SDO->CANrxData[0] & 0x04) != 0) {
1118:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->block_crcEnabled = true;
1119:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->block_crc = crc16_ccitt(SDO->buf, SDO->bufOffsetWr, 0);
1120:../CANopen/stack/301/CO_SDOserver.c ****                 }
1121:../CANopen/stack/301/CO_SDOserver.c ****                 else {
1122:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->block_crcEnabled = false;
1123:../CANopen/stack/301/CO_SDOserver.c ****                 }
1124:../CANopen/stack/301/CO_SDOserver.c **** 
1125:../CANopen/stack/301/CO_SDOserver.c ****                 /* get blksize and verify it */
1126:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->block_blksize = SDO->CANrxData[4];
1127:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->block_blksize < 1 || SDO->block_blksize > 127) {
1128:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_BLOCK_SIZE;
1129:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
1130:../CANopen/stack/301/CO_SDOserver.c ****                     break;
1131:../CANopen/stack/301/CO_SDOserver.c ****                 }
1132:../CANopen/stack/301/CO_SDOserver.c **** 
1133:../CANopen/stack/301/CO_SDOserver.c ****                 /* verify, if there is enough data */
1134:../CANopen/stack/301/CO_SDOserver.c ****                 if (!SDO->finished && SDO->bufOffsetWr < SDO->block_blksize*7U){
1135:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_DEVICE_INCOMPAT;
1136:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
1137:../CANopen/stack/301/CO_SDOserver.c ****                     break;
1138:../CANopen/stack/301/CO_SDOserver.c ****                 }
1139:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_UPLOAD_BLK_INITIATE_RSP;
1140:../CANopen/stack/301/CO_SDOserver.c ****             }
1141:../CANopen/stack/301/CO_SDOserver.c ****             break;
1142:../CANopen/stack/301/CO_SDOserver.c ****         }
1143:../CANopen/stack/301/CO_SDOserver.c **** 
1144:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_UPLOAD_BLK_INITIATE_REQ2: {
1145:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->CANrxData[0] == 0xA3) {
1146:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->block_seqno = 0;
1147:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_UPLOAD_BLK_SUBBLOCK_SREQ;
1148:../CANopen/stack/301/CO_SDOserver.c ****             }
1149:../CANopen/stack/301/CO_SDOserver.c ****             else {
1150:../CANopen/stack/301/CO_SDOserver.c ****                 abortCode = CO_SDO_AB_CMD;
1151:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
1152:../CANopen/stack/301/CO_SDOserver.c ****             }
1153:../CANopen/stack/301/CO_SDOserver.c ****             break;
1154:../CANopen/stack/301/CO_SDOserver.c ****         }
1155:../CANopen/stack/301/CO_SDOserver.c **** 
1156:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_UPLOAD_BLK_SUBBLOCK_SREQ:
1157:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_UPLOAD_BLK_SUBBLOCK_CRSP: {
1158:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->CANrxData[0] == 0xA2) {
1159:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->block_blksize = SDO->CANrxData[2];
1160:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->block_blksize < 1 || SDO->block_blksize > 127) {
1161:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_BLOCK_SIZE;
1162:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
1163:../CANopen/stack/301/CO_SDOserver.c ****                     break;
1164:../CANopen/stack/301/CO_SDOserver.c ****                 }
1165:../CANopen/stack/301/CO_SDOserver.c **** 
1166:../CANopen/stack/301/CO_SDOserver.c ****                 /* check number of segments */
1167:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->CANrxData[1] < SDO->block_seqno) {
1168:../CANopen/stack/301/CO_SDOserver.c ****                     /* NOT all segments transferred successfully.
1169:../CANopen/stack/301/CO_SDOserver.c ****                      * Re-transmit data after erroneous segment. */
1170:../CANopen/stack/301/CO_SDOserver.c ****                     OD_size_t cntFailed = SDO->block_seqno - SDO->CANrxData[1];
1171:../CANopen/stack/301/CO_SDOserver.c ****                     cntFailed = cntFailed * 7 - SDO->block_noData;
1172:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->bufOffsetRd -= cntFailed;
1173:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->sizeTran -= cntFailed;
1174:../CANopen/stack/301/CO_SDOserver.c ****                 }
1175:../CANopen/stack/301/CO_SDOserver.c ****                 else if (SDO->CANrxData[1] > SDO->block_seqno) {
1176:../CANopen/stack/301/CO_SDOserver.c ****                     /* something strange from server, break transmission */
1177:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_CMD;
1178:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
1179:../CANopen/stack/301/CO_SDOserver.c ****                     break;
1180:../CANopen/stack/301/CO_SDOserver.c ****                 }
1181:../CANopen/stack/301/CO_SDOserver.c **** 
1182:../CANopen/stack/301/CO_SDOserver.c ****                 /* refill data buffer if necessary */
1183:../CANopen/stack/301/CO_SDOserver.c ****                 if (!readFromOd(SDO, &abortCode, SDO->block_blksize * 7, true))
1184:../CANopen/stack/301/CO_SDOserver.c ****                     break;
1185:../CANopen/stack/301/CO_SDOserver.c **** 
1186:../CANopen/stack/301/CO_SDOserver.c **** 
1187:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->bufOffsetWr == SDO->bufOffsetRd) {
1188:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_UPLOAD_BLK_END_SREQ;
1189:../CANopen/stack/301/CO_SDOserver.c ****                 }
1190:../CANopen/stack/301/CO_SDOserver.c ****                 else {
1191:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->block_seqno = 0;
1192:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_UPLOAD_BLK_SUBBLOCK_SREQ;
1193:../CANopen/stack/301/CO_SDOserver.c ****                 }
1194:../CANopen/stack/301/CO_SDOserver.c ****             }
1195:../CANopen/stack/301/CO_SDOserver.c ****             else {
1196:../CANopen/stack/301/CO_SDOserver.c ****                 abortCode = CO_SDO_AB_CMD;
1197:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
1198:../CANopen/stack/301/CO_SDOserver.c ****             }
1199:../CANopen/stack/301/CO_SDOserver.c ****             break;
1200:../CANopen/stack/301/CO_SDOserver.c ****         }
1201:../CANopen/stack/301/CO_SDOserver.c **** #endif /* (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK */
1202:../CANopen/stack/301/CO_SDOserver.c **** 
1203:../CANopen/stack/301/CO_SDOserver.c ****         default: {
1204:../CANopen/stack/301/CO_SDOserver.c ****             /* unknown message received */
1205:../CANopen/stack/301/CO_SDOserver.c ****             abortCode = CO_SDO_AB_CMD;
 2855              	 .loc 3 1205 0
 2856 05d4 AB4B     	 ldr r3,.L216
 2857 05d6 BB62     	 str r3,[r7,#40]
1206:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_ABORT;
 2858              	 .loc 3 1206 0
 2859 05d8 FB68     	 ldr r3,[r7,#12]
 2860 05da 0122     	 movs r2,#1
 2861 05dc 1A75     	 strb r2,[r3,#20]
 2862              	.L146:
1207:../CANopen/stack/301/CO_SDOserver.c ****         }
1208:../CANopen/stack/301/CO_SDOserver.c ****         } /* switch (SDO->state) */
1209:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
1210:../CANopen/stack/301/CO_SDOserver.c ****         SDO->timeoutTimer = 0;
 2863              	 .loc 3 1210 0
 2864 05de FB68     	 ldr r3,[r7,#12]
 2865 05e0 0022     	 movs r2,#0
 2866 05e2 9A67     	 str r2,[r3,#120]
1211:../CANopen/stack/301/CO_SDOserver.c **** #endif
1212:../CANopen/stack/301/CO_SDOserver.c ****         timeDifference_us = 0;
 2867              	 .loc 3 1212 0
 2868 05e4 0023     	 movs r3,#0
 2869 05e6 7B60     	 str r3,[r7,#4]
1213:../CANopen/stack/301/CO_SDOserver.c ****         CO_FLAG_CLEAR(SDO->CANrxNew);
 2870              	 .loc 3 1213 0
 2871 05e8 FB68     	 ldr r3,[r7,#12]
 2872 05ea 0022     	 movs r2,#0
 2873 05ec 9A63     	 str r2,[r3,#56]
 2874              	.L130:
1214:../CANopen/stack/301/CO_SDOserver.c ****     } /* if (isNew) */
1215:../CANopen/stack/301/CO_SDOserver.c **** 
1216:../CANopen/stack/301/CO_SDOserver.c ****     /* Timeout timers and transmit bufferFull flag ****************************/
1217:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
1218:../CANopen/stack/301/CO_SDOserver.c ****     if (ret == CO_SDO_RT_waitingResponse) {
 2875              	 .loc 3 1218 0
 2876 05ee 97F96730 	 ldrsb r3,[r7,#103]
 2877 05f2 012B     	 cmp r3,#1
 2878 05f4 1ED1     	 bne .L181
1219:../CANopen/stack/301/CO_SDOserver.c ****         if (SDO->timeoutTimer < SDO->SDOtimeoutTime_us) {
 2879              	 .loc 3 1219 0
 2880 05f6 FB68     	 ldr r3,[r7,#12]
 2881 05f8 9A6F     	 ldr r2,[r3,#120]
 2882 05fa FB68     	 ldr r3,[r7,#12]
 2883 05fc 5B6F     	 ldr r3,[r3,#116]
 2884 05fe 9A42     	 cmp r2,r3
 2885 0600 05D2     	 bcs .L182
1220:../CANopen/stack/301/CO_SDOserver.c ****             SDO->timeoutTimer += timeDifference_us;
 2886              	 .loc 3 1220 0
 2887 0602 FB68     	 ldr r3,[r7,#12]
 2888 0604 9A6F     	 ldr r2,[r3,#120]
 2889 0606 7B68     	 ldr r3,[r7,#4]
 2890 0608 1A44     	 add r2,r2,r3
 2891 060a FB68     	 ldr r3,[r7,#12]
 2892 060c 9A67     	 str r2,[r3,#120]
 2893              	.L182:
1221:../CANopen/stack/301/CO_SDOserver.c ****         }
1222:../CANopen/stack/301/CO_SDOserver.c ****         if (SDO->timeoutTimer >= SDO->SDOtimeoutTime_us) {
 2894              	 .loc 3 1222 0
 2895 060e FB68     	 ldr r3,[r7,#12]
 2896 0610 9A6F     	 ldr r2,[r3,#120]
 2897 0612 FB68     	 ldr r3,[r7,#12]
 2898 0614 5B6F     	 ldr r3,[r3,#116]
 2899 0616 9A42     	 cmp r2,r3
 2900 0618 04D3     	 bcc .L183
1223:../CANopen/stack/301/CO_SDOserver.c ****             abortCode = CO_SDO_AB_TIMEOUT;
 2901              	 .loc 3 1223 0
 2902 061a 9B4B     	 ldr r3,.L216+4
 2903 061c BB62     	 str r3,[r7,#40]
1224:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_ABORT;
 2904              	 .loc 3 1224 0
 2905 061e FB68     	 ldr r3,[r7,#12]
 2906 0620 0122     	 movs r2,#1
 2907 0622 1A75     	 strb r2,[r3,#20]
 2908              	.L183:
1225:../CANopen/stack/301/CO_SDOserver.c ****         }
1226:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_TIMERNEXT
1227:../CANopen/stack/301/CO_SDOserver.c ****         else if (timerNext_us != NULL) {
1228:../CANopen/stack/301/CO_SDOserver.c ****             /* check again after timeout time elapsed */
1229:../CANopen/stack/301/CO_SDOserver.c ****             uint32_t diff = SDO->SDOtimeoutTime_us - SDO->timeoutTimer;
1230:../CANopen/stack/301/CO_SDOserver.c ****             if (*timerNext_us > diff) {
1231:../CANopen/stack/301/CO_SDOserver.c ****                 *timerNext_us = diff;
1232:../CANopen/stack/301/CO_SDOserver.c ****             }
1233:../CANopen/stack/301/CO_SDOserver.c ****         }
1234:../CANopen/stack/301/CO_SDOserver.c **** #endif
1235:../CANopen/stack/301/CO_SDOserver.c **** 
1236:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK
1237:../CANopen/stack/301/CO_SDOserver.c ****         /* Timeout for sub-block transmission */
1238:../CANopen/stack/301/CO_SDOserver.c ****         if (SDO->state == CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_REQ) {
1239:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->block_timeoutTimer < SDO->block_SDOtimeoutTime_us) {
1240:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->block_timeoutTimer += timeDifference_us;
1241:../CANopen/stack/301/CO_SDOserver.c ****             }
1242:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->block_timeoutTimer >= SDO->block_SDOtimeoutTime_us) {
1243:../CANopen/stack/301/CO_SDOserver.c ****                 /* SDO->state will change, processing will continue in this
1244:../CANopen/stack/301/CO_SDOserver.c ****                  * thread. Make memory barrier here with CO_FLAG_CLEAR() call.*/
1245:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_RSP;
1246:../CANopen/stack/301/CO_SDOserver.c ****                 CO_FLAG_CLEAR(SDO->CANrxNew);
1247:../CANopen/stack/301/CO_SDOserver.c ****             }
1248:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_TIMERNEXT
1249:../CANopen/stack/301/CO_SDOserver.c ****             else if (timerNext_us != NULL) {
1250:../CANopen/stack/301/CO_SDOserver.c ****                 /* check again after timeout time elapsed */
1251:../CANopen/stack/301/CO_SDOserver.c ****                 uint32_t diff = SDO->block_SDOtimeoutTime_us -
1252:../CANopen/stack/301/CO_SDOserver.c ****                                 SDO->block_timeoutTimer;
1253:../CANopen/stack/301/CO_SDOserver.c ****                 if (*timerNext_us > diff) {
1254:../CANopen/stack/301/CO_SDOserver.c ****                     *timerNext_us = diff;
1255:../CANopen/stack/301/CO_SDOserver.c ****                 }
1256:../CANopen/stack/301/CO_SDOserver.c ****             }
1257:../CANopen/stack/301/CO_SDOserver.c **** #endif
1258:../CANopen/stack/301/CO_SDOserver.c ****         }
1259:../CANopen/stack/301/CO_SDOserver.c **** #endif /* (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK */
1260:../CANopen/stack/301/CO_SDOserver.c **** 
1261:../CANopen/stack/301/CO_SDOserver.c ****         if (SDO->CANtxBuff->bufferFull) {
 2909              	 .loc 3 1261 0
 2910 0624 FB68     	 ldr r3,[r7,#12]
 2911 0626 5B68     	 ldr r3,[r3,#4]
 2912 0628 1B69     	 ldr r3,[r3,#16]
 2913 062a 002B     	 cmp r3,#0
 2914 062c 02D0     	 beq .L181
1262:../CANopen/stack/301/CO_SDOserver.c ****             ret = CO_SDO_RT_transmittBufferFull;
 2915              	 .loc 3 1262 0
 2916 062e 0423     	 movs r3,#4
 2917 0630 87F86730 	 strb r3,[r7,#103]
 2918              	.L181:
1263:../CANopen/stack/301/CO_SDOserver.c ****         }
1264:../CANopen/stack/301/CO_SDOserver.c ****     }
1265:../CANopen/stack/301/CO_SDOserver.c **** #endif /* (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED */
1266:../CANopen/stack/301/CO_SDOserver.c **** 
1267:../CANopen/stack/301/CO_SDOserver.c ****     /* Transmit CAN data ******************************************************/
1268:../CANopen/stack/301/CO_SDOserver.c ****     if (ret == CO_SDO_RT_waitingResponse) {
 2919              	 .loc 3 1268 0
 2920 0634 97F96730 	 ldrsb r3,[r7,#103]
 2921 0638 012B     	 cmp r3,#1
 2922 063a 40F0B581 	 bne .L184
1269:../CANopen/stack/301/CO_SDOserver.c ****         /* clear response buffer */
1270:../CANopen/stack/301/CO_SDOserver.c ****         memset(SDO->CANtxBuff->data, 0, sizeof(SDO->CANtxBuff->data));
 2923              	 .loc 3 1270 0
 2924 063e FB68     	 ldr r3,[r7,#12]
 2925 0640 5B68     	 ldr r3,[r3,#4]
 2926 0642 0533     	 adds r3,r3,#5
 2927 0644 1846     	 mov r0,r3
 2928 0646 0021     	 movs r1,#0
 2929 0648 0822     	 movs r2,#8
 2930 064a FFF7FEFF 	 bl memset
1271:../CANopen/stack/301/CO_SDOserver.c **** 
1272:../CANopen/stack/301/CO_SDOserver.c ****         switch (SDO->state) {
 2931              	 .loc 3 1272 0
 2932 064e FB68     	 ldr r3,[r7,#12]
 2933 0650 1B7D     	 ldrb r3,[r3,#20]
 2934 0652 DBB2     	 uxtb r3,r3
 2935 0654 123B     	 subs r3,r3,#18
 2936 0656 122B     	 cmp r3,#18
 2937 0658 00F2A581 	 bhi .L211
 2938 065c 01A2     	 adr r2,.L187
 2939 065e 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 2940 0662 00BF     	 .p2align 2
 2941              	.L187:
 2942 0664 B1060000 	 .word .L186+1
 2943 0668 A7090000 	 .word .L211+1
 2944 066c 33070000 	 .word .L188+1
 2945 0670 A7090000 	 .word .L211+1
 2946 0674 A7090000 	 .word .L211+1
 2947 0678 A7090000 	 .word .L211+1
 2948 067c A7090000 	 .word .L211+1
 2949 0680 A7090000 	 .word .L211+1
 2950 0684 A7090000 	 .word .L211+1
 2951 0688 A7090000 	 .word .L211+1
 2952 068c A7090000 	 .word .L211+1
 2953 0690 A7090000 	 .word .L211+1
 2954 0694 A7090000 	 .word .L211+1
 2955 0698 A7090000 	 .word .L211+1
 2956 069c A7090000 	 .word .L211+1
 2957 06a0 A7090000 	 .word .L211+1
 2958 06a4 8F070000 	 .word .L189+1
 2959 06a8 A7090000 	 .word .L211+1
 2960 06ac 6D080000 	 .word .L190+1
 2961              	 .p2align 1
 2962              	.L186:
1273:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_DOWNLOAD_INITIATE_RSP: {
1274:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[0] = 0x60;
 2963              	 .loc 3 1274 0
 2964 06b0 FB68     	 ldr r3,[r7,#12]
 2965 06b2 5B68     	 ldr r3,[r3,#4]
 2966 06b4 6022     	 movs r2,#96
 2967 06b6 5A71     	 strb r2,[r3,#5]
1275:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[1] = (uint8_t)SDO->index;
 2968              	 .loc 3 1275 0
 2969 06b8 FB68     	 ldr r3,[r7,#12]
 2970 06ba 5B68     	 ldr r3,[r3,#4]
 2971 06bc FA68     	 ldr r2,[r7,#12]
 2972 06be 928E     	 ldrh r2,[r2,#52]
 2973 06c0 D2B2     	 uxtb r2,r2
 2974 06c2 9A71     	 strb r2,[r3,#6]
1276:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[2] = (uint8_t)(SDO->index >> 8);
 2975              	 .loc 3 1276 0
 2976 06c4 FB68     	 ldr r3,[r7,#12]
 2977 06c6 5B68     	 ldr r3,[r3,#4]
 2978 06c8 FA68     	 ldr r2,[r7,#12]
 2979 06ca 928E     	 ldrh r2,[r2,#52]
 2980 06cc 120A     	 lsrs r2,r2,#8
 2981 06ce 92B2     	 uxth r2,r2
 2982 06d0 D2B2     	 uxtb r2,r2
 2983 06d2 DA71     	 strb r2,[r3,#7]
1277:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[3] = SDO->subIndex;
 2984              	 .loc 3 1277 0
 2985 06d4 FB68     	 ldr r3,[r7,#12]
 2986 06d6 5B68     	 ldr r3,[r3,#4]
 2987 06d8 FA68     	 ldr r2,[r7,#12]
 2988 06da 92F83620 	 ldrb r2,[r2,#54]
 2989 06de 1A72     	 strb r2,[r3,#8]
1278:../CANopen/stack/301/CO_SDOserver.c **** 
1279:../CANopen/stack/301/CO_SDOserver.c ****             /* reset timeout timer and send message */
1280:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
1281:../CANopen/stack/301/CO_SDOserver.c ****             SDO->timeoutTimer = 0;
 2990              	 .loc 3 1281 0
 2991 06e0 FB68     	 ldr r3,[r7,#12]
 2992 06e2 0022     	 movs r2,#0
 2993 06e4 9A67     	 str r2,[r3,#120]
1282:../CANopen/stack/301/CO_SDOserver.c **** #endif
1283:../CANopen/stack/301/CO_SDOserver.c ****             CO_CANsend(SDO->CANdevTx, SDO->CANtxBuff);
 2994              	 .loc 3 1283 0
 2995 06e6 FB68     	 ldr r3,[r7,#12]
 2996 06e8 1A68     	 ldr r2,[r3]
 2997 06ea FB68     	 ldr r3,[r7,#12]
 2998 06ec 5B68     	 ldr r3,[r3,#4]
 2999 06ee 1046     	 mov r0,r2
 3000 06f0 1946     	 mov r1,r3
 3001 06f2 FFF7FEFF 	 bl CO_CANsend
1284:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
1285:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->finished) {
 3002              	 .loc 3 1285 0
 3003 06f6 FB68     	 ldr r3,[r7,#12]
 3004 06f8 1B6F     	 ldr r3,[r3,#112]
 3005 06fa 002B     	 cmp r3,#0
 3006 06fc 06D0     	 beq .L191
1286:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_IDLE;
 3007              	 .loc 3 1286 0
 3008 06fe FB68     	 ldr r3,[r7,#12]
 3009 0700 0022     	 movs r2,#0
 3010 0702 1A75     	 strb r2,[r3,#20]
1287:../CANopen/stack/301/CO_SDOserver.c ****                 ret = CO_SDO_RT_ok_communicationEnd;
 3011              	 .loc 3 1287 0
 3012 0704 0023     	 movs r3,#0
 3013 0706 87F86730 	 strb r3,[r7,#103]
1288:../CANopen/stack/301/CO_SDOserver.c ****             }
1289:../CANopen/stack/301/CO_SDOserver.c ****             else {
1290:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->toggle = 0x00;
1291:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->sizeTran = 0;
1292:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->bufOffsetWr = 0;
1293:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->bufOffsetRd = 0;
1294:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_DOWNLOAD_SEGMENT_REQ;
1295:../CANopen/stack/301/CO_SDOserver.c ****             }
1296:../CANopen/stack/301/CO_SDOserver.c **** #else
1297:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_IDLE;
1298:../CANopen/stack/301/CO_SDOserver.c ****             ret = CO_SDO_RT_ok_communicationEnd;
1299:../CANopen/stack/301/CO_SDOserver.c **** #endif
1300:../CANopen/stack/301/CO_SDOserver.c ****             break;
 3014              	 .loc 3 1300 0
 3015 070a 4DE1     	 b .L184
 3016              	.L191:
1290:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->sizeTran = 0;
 3017              	 .loc 3 1290 0
 3018 070c FB68     	 ldr r3,[r7,#12]
 3019 070e 0022     	 movs r2,#0
 3020 0710 83F86C20 	 strb r2,[r3,#108]
1291:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->bufOffsetWr = 0;
 3021              	 .loc 3 1291 0
 3022 0714 FB68     	 ldr r3,[r7,#12]
 3023 0716 0022     	 movs r2,#0
 3024 0718 9A66     	 str r2,[r3,#104]
1292:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->bufOffsetRd = 0;
 3025              	 .loc 3 1292 0
 3026 071a FB68     	 ldr r3,[r7,#12]
 3027 071c 0022     	 movs r2,#0
 3028 071e C3F8A020 	 str r2,[r3,#160]
1293:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_DOWNLOAD_SEGMENT_REQ;
 3029              	 .loc 3 1293 0
 3030 0722 FB68     	 ldr r3,[r7,#12]
 3031 0724 0022     	 movs r2,#0
 3032 0726 C3F8A420 	 str r2,[r3,#164]
1294:../CANopen/stack/301/CO_SDOserver.c ****             }
 3033              	 .loc 3 1294 0
 3034 072a FB68     	 ldr r3,[r7,#12]
 3035 072c 1322     	 movs r2,#19
 3036 072e 1A75     	 strb r2,[r3,#20]
 3037              	 .loc 3 1300 0
 3038 0730 3AE1     	 b .L184
 3039              	.L188:
1301:../CANopen/stack/301/CO_SDOserver.c ****         }
1302:../CANopen/stack/301/CO_SDOserver.c **** 
1303:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
1304:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_DOWNLOAD_SEGMENT_RSP: {
1305:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[0] = 0x20 | SDO->toggle;
 3040              	 .loc 3 1305 0
 3041 0732 FB68     	 ldr r3,[r7,#12]
 3042 0734 5B68     	 ldr r3,[r3,#4]
 3043 0736 FA68     	 ldr r2,[r7,#12]
 3044 0738 92F86C20 	 ldrb r2,[r2,#108]
 3045 073c 42F02002 	 orr r2,r2,#32
 3046 0740 D2B2     	 uxtb r2,r2
 3047 0742 5A71     	 strb r2,[r3,#5]
1306:../CANopen/stack/301/CO_SDOserver.c ****             SDO->toggle = (SDO->toggle == 0x00) ? 0x10 : 0x00;
 3048              	 .loc 3 1306 0
 3049 0744 FB68     	 ldr r3,[r7,#12]
 3050 0746 93F86C30 	 ldrb r3,[r3,#108]
 3051 074a 002B     	 cmp r3,#0
 3052 074c 01D1     	 bne .L193
 3053              	 .loc 3 1306 0 is_stmt 0 discriminator 1
 3054 074e 1022     	 movs r2,#16
 3055 0750 00E0     	 b .L194
 3056              	.L193:
 3057              	 .loc 3 1306 0 discriminator 2
 3058 0752 0022     	 movs r2,#0
 3059              	.L194:
 3060              	 .loc 3 1306 0 discriminator 4
 3061 0754 FB68     	 ldr r3,[r7,#12]
 3062 0756 83F86C20 	 strb r2,[r3,#108]
1307:../CANopen/stack/301/CO_SDOserver.c **** 
1308:../CANopen/stack/301/CO_SDOserver.c ****             /* reset timeout timer and send message */
1309:../CANopen/stack/301/CO_SDOserver.c ****             SDO->timeoutTimer = 0;
 3063              	 .loc 3 1309 0 is_stmt 1 discriminator 4
 3064 075a FB68     	 ldr r3,[r7,#12]
 3065 075c 0022     	 movs r2,#0
 3066 075e 9A67     	 str r2,[r3,#120]
1310:../CANopen/stack/301/CO_SDOserver.c ****             CO_CANsend(SDO->CANdevTx, SDO->CANtxBuff);
 3067              	 .loc 3 1310 0 discriminator 4
 3068 0760 FB68     	 ldr r3,[r7,#12]
 3069 0762 1A68     	 ldr r2,[r3]
 3070 0764 FB68     	 ldr r3,[r7,#12]
 3071 0766 5B68     	 ldr r3,[r3,#4]
 3072 0768 1046     	 mov r0,r2
 3073 076a 1946     	 mov r1,r3
 3074 076c FFF7FEFF 	 bl CO_CANsend
1311:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->finished) {
 3075              	 .loc 3 1311 0 discriminator 4
 3076 0770 FB68     	 ldr r3,[r7,#12]
 3077 0772 1B6F     	 ldr r3,[r3,#112]
 3078 0774 002B     	 cmp r3,#0
 3079 0776 06D0     	 beq .L195
1312:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_IDLE;
 3080              	 .loc 3 1312 0
 3081 0778 FB68     	 ldr r3,[r7,#12]
 3082 077a 0022     	 movs r2,#0
 3083 077c 1A75     	 strb r2,[r3,#20]
1313:../CANopen/stack/301/CO_SDOserver.c ****                 ret = CO_SDO_RT_ok_communicationEnd;
 3084              	 .loc 3 1313 0
 3085 077e 0023     	 movs r3,#0
 3086 0780 87F86730 	 strb r3,[r7,#103]
1314:../CANopen/stack/301/CO_SDOserver.c ****             }
1315:../CANopen/stack/301/CO_SDOserver.c ****             else {
1316:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_DOWNLOAD_SEGMENT_REQ;
1317:../CANopen/stack/301/CO_SDOserver.c ****             }
1318:../CANopen/stack/301/CO_SDOserver.c ****             break;
 3087              	 .loc 3 1318 0
 3088 0784 10E1     	 b .L184
 3089              	.L195:
1316:../CANopen/stack/301/CO_SDOserver.c ****             }
 3090              	 .loc 3 1316 0
 3091 0786 FB68     	 ldr r3,[r7,#12]
 3092 0788 1322     	 movs r2,#19
 3093 078a 1A75     	 strb r2,[r3,#20]
 3094              	 .loc 3 1318 0
 3095 078c 0CE1     	 b .L184
 3096              	.L189:
1319:../CANopen/stack/301/CO_SDOserver.c ****         }
1320:../CANopen/stack/301/CO_SDOserver.c **** #endif
1321:../CANopen/stack/301/CO_SDOserver.c **** 
1322:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_UPLOAD_INITIATE_RSP: {
1323:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
1324:../CANopen/stack/301/CO_SDOserver.c ****             /* data were already loaded from OD variable */
1325:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->sizeInd > 0 && SDO->sizeInd <= 4) {
 3097              	 .loc 3 1325 0
 3098 078e FB68     	 ldr r3,[r7,#12]
 3099 0790 5B6E     	 ldr r3,[r3,#100]
 3100 0792 002B     	 cmp r3,#0
 3101 0794 26D0     	 beq .L197
 3102              	 .loc 3 1325 0 is_stmt 0 discriminator 1
 3103 0796 FB68     	 ldr r3,[r7,#12]
 3104 0798 5B6E     	 ldr r3,[r3,#100]
 3105 079a 042B     	 cmp r3,#4
 3106 079c 22D8     	 bhi .L197
1326:../CANopen/stack/301/CO_SDOserver.c ****                 /* expedited transfer */
1327:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->CANtxBuff->data[0] = (uint8_t)(0x43|((4-SDO->sizeInd)<<2));
 3107              	 .loc 3 1327 0 is_stmt 1
 3108 079e FB68     	 ldr r3,[r7,#12]
 3109 07a0 5B68     	 ldr r3,[r3,#4]
 3110 07a2 FA68     	 ldr r2,[r7,#12]
 3111 07a4 526E     	 ldr r2,[r2,#100]
 3112 07a6 D2B2     	 uxtb r2,r2
 3113 07a8 C2F10402 	 rsb r2,r2,#4
 3114 07ac D2B2     	 uxtb r2,r2
 3115 07ae 9200     	 lsls r2,r2,#2
 3116 07b0 D2B2     	 uxtb r2,r2
 3117 07b2 42F04302 	 orr r2,r2,#67
 3118 07b6 D2B2     	 uxtb r2,r2
 3119 07b8 5A71     	 strb r2,[r3,#5]
1328:../CANopen/stack/301/CO_SDOserver.c ****                 memcpy(&SDO->CANtxBuff->data[4], &SDO->buf, SDO->sizeInd);
 3120              	 .loc 3 1328 0
 3121 07ba FB68     	 ldr r3,[r7,#12]
 3122 07bc 5B68     	 ldr r3,[r3,#4]
 3123 07be 03F10901 	 add r1,r3,#9
 3124 07c2 FB68     	 ldr r3,[r7,#12]
 3125 07c4 03F17C02 	 add r2,r3,#124
 3126 07c8 FB68     	 ldr r3,[r7,#12]
 3127 07ca 5B6E     	 ldr r3,[r3,#100]
 3128 07cc 0846     	 mov r0,r1
 3129 07ce 1146     	 mov r1,r2
 3130 07d0 1A46     	 mov r2,r3
 3131 07d2 FFF7FEFF 	 bl memcpy
1329:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_IDLE;
 3132              	 .loc 3 1329 0
 3133 07d6 FB68     	 ldr r3,[r7,#12]
 3134 07d8 0022     	 movs r2,#0
 3135 07da 1A75     	 strb r2,[r3,#20]
1330:../CANopen/stack/301/CO_SDOserver.c ****                 ret = CO_SDO_RT_ok_communicationEnd;
 3136              	 .loc 3 1330 0
 3137 07dc 0023     	 movs r3,#0
 3138 07de 87F86730 	 strb r3,[r7,#103]
 3139 07e2 26E0     	 b .L198
 3140              	.L197:
1331:../CANopen/stack/301/CO_SDOserver.c ****             }
1332:../CANopen/stack/301/CO_SDOserver.c ****             else {
1333:../CANopen/stack/301/CO_SDOserver.c ****                 /* data will be transferred with segmented transfer */
1334:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->sizeInd > 0) {
 3141              	 .loc 3 1334 0
 3142 07e4 FB68     	 ldr r3,[r7,#12]
 3143 07e6 5B6E     	 ldr r3,[r3,#100]
 3144 07e8 002B     	 cmp r3,#0
 3145 07ea 14D0     	 beq .L199
 3146              	.LBB17:
1335:../CANopen/stack/301/CO_SDOserver.c ****                     /* indicate data size, if known */
1336:../CANopen/stack/301/CO_SDOserver.c ****                     uint32_t sizeInd = SDO->sizeInd;
 3147              	 .loc 3 1336 0
 3148 07ec FB68     	 ldr r3,[r7,#12]
 3149 07ee 5B6E     	 ldr r3,[r3,#100]
 3150 07f0 FB62     	 str r3,[r7,#44]
1337:../CANopen/stack/301/CO_SDOserver.c ****                     uint32_t sizeIndSw = CO_SWAP_32(sizeInd);
 3151              	 .loc 3 1337 0
 3152 07f2 FB6A     	 ldr r3,[r7,#44]
 3153 07f4 7B61     	 str r3,[r7,#20]
1338:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->CANtxBuff->data[0] = 0x41;
 3154              	 .loc 3 1338 0
 3155 07f6 FB68     	 ldr r3,[r7,#12]
 3156 07f8 5B68     	 ldr r3,[r3,#4]
 3157 07fa 4122     	 movs r2,#65
 3158 07fc 5A71     	 strb r2,[r3,#5]
1339:../CANopen/stack/301/CO_SDOserver.c **** #if (C2000_PORT != 0)
1340:../CANopen/stack/301/CO_SDOserver.c ****                     for (int i = 0; i < 4; i++) {
1341:../CANopen/stack/301/CO_SDOserver.c ****                         SDO->CANtxBuff->data[i + 4] = (uint8_t)((sizeIndSw >> (8 * i)) & 0x00FF);
1342:../CANopen/stack/301/CO_SDOserver.c ****                     }
1343:../CANopen/stack/301/CO_SDOserver.c **** #else
1344:../CANopen/stack/301/CO_SDOserver.c ****                     memcpy(&SDO->CANtxBuff->data[4],
 3159              	 .loc 3 1344 0
 3160 07fe FB68     	 ldr r3,[r7,#12]
 3161 0800 5B68     	 ldr r3,[r3,#4]
 3162 0802 03F10902 	 add r2,r3,#9
 3163 0806 07F11403 	 add r3,r7,#20
 3164 080a 1046     	 mov r0,r2
 3165 080c 1946     	 mov r1,r3
 3166 080e 0422     	 movs r2,#4
 3167 0810 FFF7FEFF 	 bl memcpy
 3168              	.LBE17:
 3169 0814 03E0     	 b .L200
 3170              	.L199:
1345:../CANopen/stack/301/CO_SDOserver.c ****                            &sizeIndSw, sizeof(sizeIndSw));
1346:../CANopen/stack/301/CO_SDOserver.c **** #endif
1347:../CANopen/stack/301/CO_SDOserver.c ****                 }
1348:../CANopen/stack/301/CO_SDOserver.c ****                 else {
1349:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->CANtxBuff->data[0] = 0x40;
 3171              	 .loc 3 1349 0
 3172 0816 FB68     	 ldr r3,[r7,#12]
 3173 0818 5B68     	 ldr r3,[r3,#4]
 3174 081a 4022     	 movs r2,#64
 3175 081c 5A71     	 strb r2,[r3,#5]
 3176              	.L200:
1350:../CANopen/stack/301/CO_SDOserver.c ****                 }
1351:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->toggle = 0x00;
 3177              	 .loc 3 1351 0
 3178 081e FB68     	 ldr r3,[r7,#12]
 3179 0820 0022     	 movs r2,#0
 3180 0822 83F86C20 	 strb r2,[r3,#108]
1352:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->timeoutTimer = 0;
 3181              	 .loc 3 1352 0
 3182 0826 FB68     	 ldr r3,[r7,#12]
 3183 0828 0022     	 movs r2,#0
 3184 082a 9A67     	 str r2,[r3,#120]
1353:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_UPLOAD_SEGMENT_REQ;
 3185              	 .loc 3 1353 0
 3186 082c FB68     	 ldr r3,[r7,#12]
 3187 082e 2322     	 movs r2,#35
 3188 0830 1A75     	 strb r2,[r3,#20]
 3189              	.L198:
1354:../CANopen/stack/301/CO_SDOserver.c ****             }
1355:../CANopen/stack/301/CO_SDOserver.c **** #else /* Expedited transfer only */
1356:../CANopen/stack/301/CO_SDOserver.c ****             /* load data from OD variable */
1357:../CANopen/stack/301/CO_SDOserver.c ****             OD_size_t count = 0;
1358:../CANopen/stack/301/CO_SDOserver.c ****             bool_t lock = OD_mappable(&SDO->OD_IO.stream);
1359:../CANopen/stack/301/CO_SDOserver.c **** 
1360:../CANopen/stack/301/CO_SDOserver.c ****             if (lock) { CO_LOCK_OD(SDO->CANdevTx); }
1361:../CANopen/stack/301/CO_SDOserver.c ****             ODR_t odRet = SDO->OD_IO.read(&SDO->OD_IO.stream,
1362:../CANopen/stack/301/CO_SDOserver.c ****                                           &SDO->CANtxBuff->data[4], 4, &count);
1363:../CANopen/stack/301/CO_SDOserver.c ****             if (lock) { CO_UNLOCK_OD(SDO->CANdevTx); }
1364:../CANopen/stack/301/CO_SDOserver.c **** 
1365:../CANopen/stack/301/CO_SDOserver.c ****             /* strings are allowed to be shorter */
1366:../CANopen/stack/301/CO_SDOserver.c ****             if (odRet == ODR_PARTIAL
1367:../CANopen/stack/301/CO_SDOserver.c ****                 && (SDO->OD_IO.stream.attribute & ODA_STR) != 0
1368:../CANopen/stack/301/CO_SDOserver.c ****             ) {
1369:../CANopen/stack/301/CO_SDOserver.c ****                 odRet = ODR_OK;
1370:../CANopen/stack/301/CO_SDOserver.c ****             }
1371:../CANopen/stack/301/CO_SDOserver.c **** 
1372:../CANopen/stack/301/CO_SDOserver.c ****             if (odRet != ODR_OK || count == 0) {
1373:../CANopen/stack/301/CO_SDOserver.c ****                 abortCode = (odRet == ODR_OK) ? CO_SDO_AB_DEVICE_INCOMPAT :
1374:../CANopen/stack/301/CO_SDOserver.c ****                             (CO_SDO_abortCode_t)OD_getSDOabCode(odRet);
1375:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_ABORT;
1376:../CANopen/stack/301/CO_SDOserver.c ****                 break;
1377:../CANopen/stack/301/CO_SDOserver.c ****             }
1378:../CANopen/stack/301/CO_SDOserver.c **** 
1379:../CANopen/stack/301/CO_SDOserver.c **** #ifdef CO_BIG_ENDIAN
1380:../CANopen/stack/301/CO_SDOserver.c ****             /* swap data if necessary */
1381:../CANopen/stack/301/CO_SDOserver.c ****             if ((SDO->OD_IO.stream.attribute & ODA_MB) != 0) {
1382:../CANopen/stack/301/CO_SDOserver.c ****                 reverseBytes(buf, dataSizeToWrite);
1383:../CANopen/stack/301/CO_SDOserver.c ****             }
1384:../CANopen/stack/301/CO_SDOserver.c **** #endif
1385:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[0] = 0x43 | ((4 - count) << 2);
1386:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_IDLE;
1387:../CANopen/stack/301/CO_SDOserver.c ****             ret = CO_SDO_RT_ok_communicationEnd;
1388:../CANopen/stack/301/CO_SDOserver.c **** #endif /* (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED */
1389:../CANopen/stack/301/CO_SDOserver.c **** 
1390:../CANopen/stack/301/CO_SDOserver.c ****             /* send message */
1391:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[1] = (uint8_t)SDO->index;
 3190              	 .loc 3 1391 0
 3191 0832 FB68     	 ldr r3,[r7,#12]
 3192 0834 5B68     	 ldr r3,[r3,#4]
 3193 0836 FA68     	 ldr r2,[r7,#12]
 3194 0838 928E     	 ldrh r2,[r2,#52]
 3195 083a D2B2     	 uxtb r2,r2
 3196 083c 9A71     	 strb r2,[r3,#6]
1392:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[2] = (uint8_t)(SDO->index >> 8);
 3197              	 .loc 3 1392 0
 3198 083e FB68     	 ldr r3,[r7,#12]
 3199 0840 5B68     	 ldr r3,[r3,#4]
 3200 0842 FA68     	 ldr r2,[r7,#12]
 3201 0844 928E     	 ldrh r2,[r2,#52]
 3202 0846 120A     	 lsrs r2,r2,#8
 3203 0848 92B2     	 uxth r2,r2
 3204 084a D2B2     	 uxtb r2,r2
 3205 084c DA71     	 strb r2,[r3,#7]
1393:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[3] = SDO->subIndex;
 3206              	 .loc 3 1393 0
 3207 084e FB68     	 ldr r3,[r7,#12]
 3208 0850 5B68     	 ldr r3,[r3,#4]
 3209 0852 FA68     	 ldr r2,[r7,#12]
 3210 0854 92F83620 	 ldrb r2,[r2,#54]
 3211 0858 1A72     	 strb r2,[r3,#8]
1394:../CANopen/stack/301/CO_SDOserver.c ****             CO_CANsend(SDO->CANdevTx, SDO->CANtxBuff);
 3212              	 .loc 3 1394 0
 3213 085a FB68     	 ldr r3,[r7,#12]
 3214 085c 1A68     	 ldr r2,[r3]
 3215 085e FB68     	 ldr r3,[r7,#12]
 3216 0860 5B68     	 ldr r3,[r3,#4]
 3217 0862 1046     	 mov r0,r2
 3218 0864 1946     	 mov r1,r3
 3219 0866 FFF7FEFF 	 bl CO_CANsend
1395:../CANopen/stack/301/CO_SDOserver.c ****             break;
 3220              	 .loc 3 1395 0
 3221 086a 9DE0     	 b .L184
 3222              	.L190:
 3223              	.LBB18:
1396:../CANopen/stack/301/CO_SDOserver.c ****         }
1397:../CANopen/stack/301/CO_SDOserver.c **** 
1398:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED
1399:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_UPLOAD_SEGMENT_RSP: {
1400:../CANopen/stack/301/CO_SDOserver.c ****             /* refill the data buffer if necessary */
1401:../CANopen/stack/301/CO_SDOserver.c ****             if (!readFromOd(SDO, &abortCode, 7, false))
 3224              	 .loc 3 1401 0
 3225 086c 07F12803 	 add r3,r7,#40
 3226 0870 F868     	 ldr r0,[r7,#12]
 3227 0872 1946     	 mov r1,r3
 3228 0874 0722     	 movs r2,#7
 3229 0876 0023     	 movs r3,#0
 3230 0878 FFF7FEFF 	 bl readFromOd
 3231 087c 0346     	 mov r3,r0
 3232 087e 002B     	 cmp r3,#0
 3233 0880 04D1     	 bne .L201
1402:../CANopen/stack/301/CO_SDOserver.c ****                 break;
 3234              	 .loc 3 1402 0
 3235 0882 91E0     	 b .L184
 3236              	.L217:
 3237              	 .align 2
 3238              	.L216:
 3239 0884 01000405 	 .word 84148225
 3240 0888 00000405 	 .word 84148224
 3241              	.L201:
1403:../CANopen/stack/301/CO_SDOserver.c **** 
1404:../CANopen/stack/301/CO_SDOserver.c ****             /* SDO command specifier with toggle bit */
1405:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[0] = SDO->toggle;
 3242              	 .loc 3 1405 0
 3243 088c FB68     	 ldr r3,[r7,#12]
 3244 088e 5B68     	 ldr r3,[r3,#4]
 3245 0890 FA68     	 ldr r2,[r7,#12]
 3246 0892 92F86C20 	 ldrb r2,[r2,#108]
 3247 0896 5A71     	 strb r2,[r3,#5]
1406:../CANopen/stack/301/CO_SDOserver.c ****             SDO->toggle = (SDO->toggle == 0x00) ? 0x10 : 0x00;
 3248              	 .loc 3 1406 0
 3249 0898 FB68     	 ldr r3,[r7,#12]
 3250 089a 93F86C30 	 ldrb r3,[r3,#108]
 3251 089e 002B     	 cmp r3,#0
 3252 08a0 01D1     	 bne .L202
 3253              	 .loc 3 1406 0 is_stmt 0 discriminator 1
 3254 08a2 1022     	 movs r2,#16
 3255 08a4 00E0     	 b .L203
 3256              	.L202:
 3257              	 .loc 3 1406 0 discriminator 2
 3258 08a6 0022     	 movs r2,#0
 3259              	.L203:
 3260              	 .loc 3 1406 0 discriminator 4
 3261 08a8 FB68     	 ldr r3,[r7,#12]
 3262 08aa 83F86C20 	 strb r2,[r3,#108]
1407:../CANopen/stack/301/CO_SDOserver.c **** 
1408:../CANopen/stack/301/CO_SDOserver.c ****             OD_size_t count = SDO->bufOffsetWr - SDO->bufOffsetRd;
 3263              	 .loc 3 1408 0 is_stmt 1 discriminator 4
 3264 08ae FB68     	 ldr r3,[r7,#12]
 3265 08b0 D3F8A020 	 ldr r2,[r3,#160]
 3266 08b4 FB68     	 ldr r3,[r7,#12]
 3267 08b6 D3F8A430 	 ldr r3,[r3,#164]
 3268 08ba D31A     	 subs r3,r2,r3
 3269 08bc BB65     	 str r3,[r7,#88]
1409:../CANopen/stack/301/CO_SDOserver.c ****             /* verify, if this is the last segment */
1410:../CANopen/stack/301/CO_SDOserver.c ****             if (count < 7 || (SDO->finished && count == 7)) {
 3270              	 .loc 3 1410 0 discriminator 4
 3271 08be BB6D     	 ldr r3,[r7,#88]
 3272 08c0 062B     	 cmp r3,#6
 3273 08c2 06D9     	 bls .L204
 3274              	 .loc 3 1410 0 is_stmt 0 discriminator 1
 3275 08c4 FB68     	 ldr r3,[r7,#12]
 3276 08c6 1B6F     	 ldr r3,[r3,#112]
 3277 08c8 002B     	 cmp r3,#0
 3278 08ca 1BD0     	 beq .L205
 3279              	 .loc 3 1410 0 discriminator 2
 3280 08cc BB6D     	 ldr r3,[r7,#88]
 3281 08ce 072B     	 cmp r3,#7
 3282 08d0 18D1     	 bne .L205
 3283              	.L204:
1411:../CANopen/stack/301/CO_SDOserver.c ****                 /* indicate last segment and nnn */
1412:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->CANtxBuff->data[0] |= ((7 - count) << 1) | 0x01;
 3284              	 .loc 3 1412 0 is_stmt 1
 3285 08d2 FB68     	 ldr r3,[r7,#12]
 3286 08d4 5B68     	 ldr r3,[r3,#4]
 3287 08d6 FA68     	 ldr r2,[r7,#12]
 3288 08d8 5268     	 ldr r2,[r2,#4]
 3289 08da 5179     	 ldrb r1,[r2,#5]
 3290 08dc BA6D     	 ldr r2,[r7,#88]
 3291 08de D2B2     	 uxtb r2,r2
 3292 08e0 C2F10702 	 rsb r2,r2,#7
 3293 08e4 D2B2     	 uxtb r2,r2
 3294 08e6 5200     	 lsls r2,r2,#1
 3295 08e8 D2B2     	 uxtb r2,r2
 3296 08ea 0A43     	 orrs r2,r2,r1
 3297 08ec D2B2     	 uxtb r2,r2
 3298 08ee 42F00102 	 orr r2,r2,#1
 3299 08f2 D2B2     	 uxtb r2,r2
 3300 08f4 5A71     	 strb r2,[r3,#5]
1413:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_IDLE;
 3301              	 .loc 3 1413 0
 3302 08f6 FB68     	 ldr r3,[r7,#12]
 3303 08f8 0022     	 movs r2,#0
 3304 08fa 1A75     	 strb r2,[r3,#20]
1414:../CANopen/stack/301/CO_SDOserver.c ****                 ret = CO_SDO_RT_ok_communicationEnd;
 3305              	 .loc 3 1414 0
 3306 08fc 0023     	 movs r3,#0
 3307 08fe 87F86730 	 strb r3,[r7,#103]
 3308 0902 07E0     	 b .L206
 3309              	.L205:
1415:../CANopen/stack/301/CO_SDOserver.c ****             }
1416:../CANopen/stack/301/CO_SDOserver.c ****             else {
1417:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->timeoutTimer = 0;
 3310              	 .loc 3 1417 0
 3311 0904 FB68     	 ldr r3,[r7,#12]
 3312 0906 0022     	 movs r2,#0
 3313 0908 9A67     	 str r2,[r3,#120]
1418:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_UPLOAD_SEGMENT_REQ;
 3314              	 .loc 3 1418 0
 3315 090a FB68     	 ldr r3,[r7,#12]
 3316 090c 2322     	 movs r2,#35
 3317 090e 1A75     	 strb r2,[r3,#20]
1419:../CANopen/stack/301/CO_SDOserver.c ****                 count = 7;
 3318              	 .loc 3 1419 0
 3319 0910 0723     	 movs r3,#7
 3320 0912 BB65     	 str r3,[r7,#88]
 3321              	.L206:
1420:../CANopen/stack/301/CO_SDOserver.c ****             }
1421:../CANopen/stack/301/CO_SDOserver.c **** 
1422:../CANopen/stack/301/CO_SDOserver.c ****             /* copy data segment to CAN message */
1423:../CANopen/stack/301/CO_SDOserver.c ****             memcpy(&SDO->CANtxBuff->data[1], SDO->buf + SDO->bufOffsetRd,
 3322              	 .loc 3 1423 0
 3323 0914 FB68     	 ldr r3,[r7,#12]
 3324 0916 5B68     	 ldr r3,[r3,#4]
 3325 0918 991D     	 adds r1,r3,#6
 3326 091a FB68     	 ldr r3,[r7,#12]
 3327 091c D3F8A430 	 ldr r3,[r3,#164]
 3328 0920 7833     	 adds r3,r3,#120
 3329 0922 FA68     	 ldr r2,[r7,#12]
 3330 0924 1344     	 add r3,r3,r2
 3331 0926 0433     	 adds r3,r3,#4
 3332 0928 0846     	 mov r0,r1
 3333 092a 1946     	 mov r1,r3
 3334 092c BA6D     	 ldr r2,[r7,#88]
 3335 092e FFF7FEFF 	 bl memcpy
1424:../CANopen/stack/301/CO_SDOserver.c ****                    count);
1425:../CANopen/stack/301/CO_SDOserver.c ****             SDO->bufOffsetRd += count;
 3336              	 .loc 3 1425 0
 3337 0932 FB68     	 ldr r3,[r7,#12]
 3338 0934 D3F8A420 	 ldr r2,[r3,#164]
 3339 0938 BB6D     	 ldr r3,[r7,#88]
 3340 093a 1A44     	 add r2,r2,r3
 3341 093c FB68     	 ldr r3,[r7,#12]
 3342 093e C3F8A420 	 str r2,[r3,#164]
1426:../CANopen/stack/301/CO_SDOserver.c ****             SDO->sizeTran += count;
 3343              	 .loc 3 1426 0
 3344 0942 FB68     	 ldr r3,[r7,#12]
 3345 0944 9A6E     	 ldr r2,[r3,#104]
 3346 0946 BB6D     	 ldr r3,[r7,#88]
 3347 0948 1A44     	 add r2,r2,r3
 3348 094a FB68     	 ldr r3,[r7,#12]
 3349 094c 9A66     	 str r2,[r3,#104]
1427:../CANopen/stack/301/CO_SDOserver.c **** 
1428:../CANopen/stack/301/CO_SDOserver.c ****             /* verify if sizeTran is too large or too short if last segment */
1429:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->sizeInd > 0) {
 3350              	 .loc 3 1429 0
 3351 094e FB68     	 ldr r3,[r7,#12]
 3352 0950 5B6E     	 ldr r3,[r3,#100]
 3353 0952 002B     	 cmp r3,#0
 3354 0954 1ED0     	 beq .L207
1430:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->sizeTran > SDO->sizeInd) {
 3355              	 .loc 3 1430 0
 3356 0956 FB68     	 ldr r3,[r7,#12]
 3357 0958 9A6E     	 ldr r2,[r3,#104]
 3358 095a FB68     	 ldr r3,[r7,#12]
 3359 095c 5B6E     	 ldr r3,[r3,#100]
 3360 095e 9A42     	 cmp r2,r3
 3361 0960 05D9     	 bls .L208
1431:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_DATA_LONG;
 3362              	 .loc 3 1431 0
 3363 0962 334B     	 ldr r3,.L218
 3364 0964 BB62     	 str r3,[r7,#40]
1432:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
 3365              	 .loc 3 1432 0
 3366 0966 FB68     	 ldr r3,[r7,#12]
 3367 0968 0122     	 movs r2,#1
 3368 096a 1A75     	 strb r2,[r3,#20]
1433:../CANopen/stack/301/CO_SDOserver.c ****                     break;
 3369              	 .loc 3 1433 0
 3370 096c 1CE0     	 b .L184
 3371              	.L208:
1434:../CANopen/stack/301/CO_SDOserver.c ****                 }
1435:../CANopen/stack/301/CO_SDOserver.c ****                 else if (ret == CO_SDO_RT_ok_communicationEnd
 3372              	 .loc 3 1435 0
 3373 096e 97F96730 	 ldrsb r3,[r7,#103]
 3374 0972 002B     	 cmp r3,#0
 3375 0974 0ED1     	 bne .L207
1436:../CANopen/stack/301/CO_SDOserver.c ****                          && SDO->sizeTran < SDO->sizeInd
 3376              	 .loc 3 1436 0
 3377 0976 FB68     	 ldr r3,[r7,#12]
 3378 0978 9A6E     	 ldr r2,[r3,#104]
 3379 097a FB68     	 ldr r3,[r7,#12]
 3380 097c 5B6E     	 ldr r3,[r3,#100]
 3381 097e 9A42     	 cmp r2,r3
 3382 0980 08D2     	 bcs .L207
1437:../CANopen/stack/301/CO_SDOserver.c ****                 ) {
1438:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_DATA_SHORT;
 3383              	 .loc 3 1438 0
 3384 0982 2C4B     	 ldr r3,.L218+4
 3385 0984 BB62     	 str r3,[r7,#40]
1439:../CANopen/stack/301/CO_SDOserver.c ****                     ret = CO_SDO_RT_waitingResponse;
 3386              	 .loc 3 1439 0
 3387 0986 0123     	 movs r3,#1
 3388 0988 87F86730 	 strb r3,[r7,#103]
1440:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
 3389              	 .loc 3 1440 0
 3390 098c FB68     	 ldr r3,[r7,#12]
 3391 098e 0122     	 movs r2,#1
 3392 0990 1A75     	 strb r2,[r3,#20]
1441:../CANopen/stack/301/CO_SDOserver.c ****                     break;
 3393              	 .loc 3 1441 0
 3394 0992 09E0     	 b .L184
 3395              	.L207:
1442:../CANopen/stack/301/CO_SDOserver.c ****                 }
1443:../CANopen/stack/301/CO_SDOserver.c ****             }
1444:../CANopen/stack/301/CO_SDOserver.c **** 
1445:../CANopen/stack/301/CO_SDOserver.c ****             /* send message */
1446:../CANopen/stack/301/CO_SDOserver.c ****             CO_CANsend(SDO->CANdevTx, SDO->CANtxBuff);
 3396              	 .loc 3 1446 0
 3397 0994 FB68     	 ldr r3,[r7,#12]
 3398 0996 1A68     	 ldr r2,[r3]
 3399 0998 FB68     	 ldr r3,[r7,#12]
 3400 099a 5B68     	 ldr r3,[r3,#4]
 3401 099c 1046     	 mov r0,r2
 3402 099e 1946     	 mov r1,r3
 3403 09a0 FFF7FEFF 	 bl CO_CANsend
1447:../CANopen/stack/301/CO_SDOserver.c ****             break;
 3404              	 .loc 3 1447 0
 3405 09a4 00E0     	 b .L184
 3406              	.L211:
 3407              	.LBE18:
1448:../CANopen/stack/301/CO_SDOserver.c ****         }
1449:../CANopen/stack/301/CO_SDOserver.c **** #endif /* (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_SEGMENTED */
1450:../CANopen/stack/301/CO_SDOserver.c **** 
1451:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK
1452:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_DOWNLOAD_BLK_INITIATE_RSP: {
1453:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[0] = 0xA4;
1454:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[1] = (uint8_t)SDO->index;
1455:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[2] = (uint8_t)(SDO->index >> 8);
1456:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[3] = SDO->subIndex;
1457:../CANopen/stack/301/CO_SDOserver.c **** 
1458:../CANopen/stack/301/CO_SDOserver.c ****             /* calculate number of block segments from free buffer space */
1459:../CANopen/stack/301/CO_SDOserver.c ****             OD_size_t count = (CO_CONFIG_SDO_SRV_BUFFER_SIZE-2) / 7;
1460:../CANopen/stack/301/CO_SDOserver.c ****             if (count > 127) {
1461:../CANopen/stack/301/CO_SDOserver.c ****                 count = 127;
1462:../CANopen/stack/301/CO_SDOserver.c ****             }
1463:../CANopen/stack/301/CO_SDOserver.c ****             SDO->block_blksize = (uint8_t)count;
1464:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[4] = SDO->block_blksize;
1465:../CANopen/stack/301/CO_SDOserver.c **** 
1466:../CANopen/stack/301/CO_SDOserver.c ****             /* reset variables */
1467:../CANopen/stack/301/CO_SDOserver.c ****             SDO->sizeTran = 0;
1468:../CANopen/stack/301/CO_SDOserver.c ****             SDO->finished = false;
1469:../CANopen/stack/301/CO_SDOserver.c ****             SDO->bufOffsetWr = 0;
1470:../CANopen/stack/301/CO_SDOserver.c ****             SDO->bufOffsetRd = 0;
1471:../CANopen/stack/301/CO_SDOserver.c ****             SDO->block_seqno = 0;
1472:../CANopen/stack/301/CO_SDOserver.c ****             SDO->block_crc = 0;
1473:../CANopen/stack/301/CO_SDOserver.c ****             SDO->timeoutTimer = 0;
1474:../CANopen/stack/301/CO_SDOserver.c ****             SDO->block_timeoutTimer = 0;
1475:../CANopen/stack/301/CO_SDOserver.c **** 
1476:../CANopen/stack/301/CO_SDOserver.c ****             /* Block segments will be received in different thread. Make memory
1477:../CANopen/stack/301/CO_SDOserver.c ****              * barrier here with CO_FLAG_CLEAR() call. */
1478:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_REQ;
1479:../CANopen/stack/301/CO_SDOserver.c ****             CO_FLAG_CLEAR(SDO->CANrxNew);
1480:../CANopen/stack/301/CO_SDOserver.c ****             CO_CANsend(SDO->CANdevTx, SDO->CANtxBuff);
1481:../CANopen/stack/301/CO_SDOserver.c ****             break;
1482:../CANopen/stack/301/CO_SDOserver.c ****         }
1483:../CANopen/stack/301/CO_SDOserver.c **** 
1484:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_RSP: {
1485:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[0] = 0xA2;
1486:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[1] = SDO->block_seqno;
1487:../CANopen/stack/301/CO_SDOserver.c **** #ifdef CO_DEBUG_SDO_SERVER
1488:../CANopen/stack/301/CO_SDOserver.c ****             bool_t transferShort = SDO->block_seqno != SDO->block_blksize;
1489:../CANopen/stack/301/CO_SDOserver.c ****             uint8_t seqnoStart = SDO->block_seqno;
1490:../CANopen/stack/301/CO_SDOserver.c **** #endif
1491:../CANopen/stack/301/CO_SDOserver.c **** 
1492:../CANopen/stack/301/CO_SDOserver.c ****             /* Is last segment? */
1493:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->finished) {
1494:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_DOWNLOAD_BLK_END_REQ;
1495:../CANopen/stack/301/CO_SDOserver.c ****             }
1496:../CANopen/stack/301/CO_SDOserver.c ****             else {
1497:../CANopen/stack/301/CO_SDOserver.c ****                 /* calculate number of block segments from free buffer space */
1498:../CANopen/stack/301/CO_SDOserver.c ****                 OD_size_t count;
1499:../CANopen/stack/301/CO_SDOserver.c ****                 count = (CO_CONFIG_SDO_SRV_BUFFER_SIZE-2-SDO->bufOffsetWr)/7;
1500:../CANopen/stack/301/CO_SDOserver.c ****                 if (count >= 127) {
1501:../CANopen/stack/301/CO_SDOserver.c ****                     count = 127;
1502:../CANopen/stack/301/CO_SDOserver.c ****                 }
1503:../CANopen/stack/301/CO_SDOserver.c ****                 else if (SDO->bufOffsetWr > 0) {
1504:../CANopen/stack/301/CO_SDOserver.c ****                     /* it is necessary to empty the buffer */
1505:../CANopen/stack/301/CO_SDOserver.c ****                     if (!validateAndWriteToOD(SDO, &abortCode, 1, 0))
1506:../CANopen/stack/301/CO_SDOserver.c ****                         break;
1507:../CANopen/stack/301/CO_SDOserver.c **** 
1508:../CANopen/stack/301/CO_SDOserver.c ****                     count =(CO_CONFIG_SDO_SRV_BUFFER_SIZE-2-SDO->bufOffsetWr)/7;
1509:../CANopen/stack/301/CO_SDOserver.c ****                     if (count >= 127) {
1510:../CANopen/stack/301/CO_SDOserver.c ****                         count = 127;
1511:../CANopen/stack/301/CO_SDOserver.c ****                     }
1512:../CANopen/stack/301/CO_SDOserver.c ****                 }
1513:../CANopen/stack/301/CO_SDOserver.c **** 
1514:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->block_blksize = (uint8_t)count;
1515:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->block_seqno = 0;
1516:../CANopen/stack/301/CO_SDOserver.c ****                 /* Block segments will be received in different thread. Make
1517:../CANopen/stack/301/CO_SDOserver.c ****                  * memory barrier here with CO_FLAG_CLEAR() call. */
1518:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_REQ;
1519:../CANopen/stack/301/CO_SDOserver.c ****                 CO_FLAG_CLEAR(SDO->CANrxNew);
1520:../CANopen/stack/301/CO_SDOserver.c ****             }
1521:../CANopen/stack/301/CO_SDOserver.c **** 
1522:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[2] = SDO->block_blksize;
1523:../CANopen/stack/301/CO_SDOserver.c **** 
1524:../CANopen/stack/301/CO_SDOserver.c ****             /* reset block_timeoutTimer, but not SDO->timeoutTimer */
1525:../CANopen/stack/301/CO_SDOserver.c ****             SDO->block_timeoutTimer = 0;
1526:../CANopen/stack/301/CO_SDOserver.c ****             CO_CANsend(SDO->CANdevTx, SDO->CANtxBuff);
1527:../CANopen/stack/301/CO_SDOserver.c **** #ifdef CO_DEBUG_SDO_SERVER
1528:../CANopen/stack/301/CO_SDOserver.c ****             if (transferShort && !SDO->finished) {
1529:../CANopen/stack/301/CO_SDOserver.c ****                 char msg[80];
1530:../CANopen/stack/301/CO_SDOserver.c ****                 sprintf(msg,
1531:../CANopen/stack/301/CO_SDOserver.c ****                         "sub-block restarted: sequnoPrev=%02X, blksize=%02X",
1532:../CANopen/stack/301/CO_SDOserver.c ****                         seqnoStart, SDO->block_blksize);
1533:../CANopen/stack/301/CO_SDOserver.c ****                 CO_DEBUG_SDO_SERVER(msg);
1534:../CANopen/stack/301/CO_SDOserver.c ****             }
1535:../CANopen/stack/301/CO_SDOserver.c **** #endif
1536:../CANopen/stack/301/CO_SDOserver.c ****             break;
1537:../CANopen/stack/301/CO_SDOserver.c ****         }
1538:../CANopen/stack/301/CO_SDOserver.c **** 
1539:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_DOWNLOAD_BLK_END_RSP: {
1540:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[0] = 0xA1;
1541:../CANopen/stack/301/CO_SDOserver.c **** 
1542:../CANopen/stack/301/CO_SDOserver.c ****             CO_CANsend(SDO->CANdevTx, SDO->CANtxBuff);
1543:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_IDLE;
1544:../CANopen/stack/301/CO_SDOserver.c ****             ret = CO_SDO_RT_ok_communicationEnd;
1545:../CANopen/stack/301/CO_SDOserver.c ****             break;
1546:../CANopen/stack/301/CO_SDOserver.c ****         }
1547:../CANopen/stack/301/CO_SDOserver.c **** 
1548:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_UPLOAD_BLK_INITIATE_RSP: {
1549:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[0] = 0xC4;
1550:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[1] = (uint8_t)SDO->index;
1551:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[2] = (uint8_t)(SDO->index >> 8);
1552:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[3] = SDO->subIndex;
1553:../CANopen/stack/301/CO_SDOserver.c **** 
1554:../CANopen/stack/301/CO_SDOserver.c ****             /* indicate data size */
1555:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->sizeInd > 0) {
1556:../CANopen/stack/301/CO_SDOserver.c ****                 uint32_t size = CO_SWAP_32(SDO->sizeInd);
1557:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->CANtxBuff->data[0] |= 0x02;
1558:../CANopen/stack/301/CO_SDOserver.c **** #if (C2000_PORT != 0)
1559:../CANopen/stack/301/CO_SDOserver.c ****                 for(int i = 0; i < 4; i++) {
1560:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->CANtxBuff->data[i + 4] = (uint8_t)((size >> (8 * i)) & 0x00FF);
1561:../CANopen/stack/301/CO_SDOserver.c ****                 }
1562:../CANopen/stack/301/CO_SDOserver.c **** #else
1563:../CANopen/stack/301/CO_SDOserver.c ****                 memcpy(&SDO->CANtxBuff->data[4], &size, sizeof(size));
1564:../CANopen/stack/301/CO_SDOserver.c **** #endif
1565:../CANopen/stack/301/CO_SDOserver.c ****             }
1566:../CANopen/stack/301/CO_SDOserver.c **** 
1567:../CANopen/stack/301/CO_SDOserver.c ****             /* reset timeout timer and send message */
1568:../CANopen/stack/301/CO_SDOserver.c ****             SDO->timeoutTimer = 0;
1569:../CANopen/stack/301/CO_SDOserver.c ****             CO_CANsend(SDO->CANdevTx, SDO->CANtxBuff);
1570:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_UPLOAD_BLK_INITIATE_REQ2;
1571:../CANopen/stack/301/CO_SDOserver.c ****             break;
1572:../CANopen/stack/301/CO_SDOserver.c ****         }
1573:../CANopen/stack/301/CO_SDOserver.c **** 
1574:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_UPLOAD_BLK_SUBBLOCK_SREQ: {
1575:../CANopen/stack/301/CO_SDOserver.c ****             /* write header and get current count */
1576:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[0] = ++SDO->block_seqno;
1577:../CANopen/stack/301/CO_SDOserver.c ****             OD_size_t count = SDO->bufOffsetWr - SDO->bufOffsetRd;
1578:../CANopen/stack/301/CO_SDOserver.c ****             /* verify, if this is the last segment */
1579:../CANopen/stack/301/CO_SDOserver.c ****             if (count < 7 || (SDO->finished && count == 7)) {
1580:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->CANtxBuff->data[0] |= 0x80;
1581:../CANopen/stack/301/CO_SDOserver.c ****             }
1582:../CANopen/stack/301/CO_SDOserver.c ****             else {
1583:../CANopen/stack/301/CO_SDOserver.c ****                 count = 7;
1584:../CANopen/stack/301/CO_SDOserver.c ****             }
1585:../CANopen/stack/301/CO_SDOserver.c **** 
1586:../CANopen/stack/301/CO_SDOserver.c ****             /* copy data segment to CAN message */
1587:../CANopen/stack/301/CO_SDOserver.c ****             memcpy(&SDO->CANtxBuff->data[1], SDO->buf + SDO->bufOffsetRd,
1588:../CANopen/stack/301/CO_SDOserver.c ****                    count);
1589:../CANopen/stack/301/CO_SDOserver.c ****             SDO->bufOffsetRd += count;
1590:../CANopen/stack/301/CO_SDOserver.c ****             SDO->block_noData = (uint8_t)(7 - count);
1591:../CANopen/stack/301/CO_SDOserver.c ****             SDO->sizeTran += count;
1592:../CANopen/stack/301/CO_SDOserver.c **** 
1593:../CANopen/stack/301/CO_SDOserver.c ****             /* verify if sizeTran is too large or too short if last segment */
1594:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->sizeInd > 0) {
1595:../CANopen/stack/301/CO_SDOserver.c ****                 if (SDO->sizeTran > SDO->sizeInd) {
1596:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_DATA_LONG;
1597:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
1598:../CANopen/stack/301/CO_SDOserver.c ****                     break;
1599:../CANopen/stack/301/CO_SDOserver.c ****                 }
1600:../CANopen/stack/301/CO_SDOserver.c ****                 else if (SDO->bufOffsetWr == SDO->bufOffsetRd
1601:../CANopen/stack/301/CO_SDOserver.c ****                          && SDO->sizeTran < SDO->sizeInd
1602:../CANopen/stack/301/CO_SDOserver.c ****                 ) {
1603:../CANopen/stack/301/CO_SDOserver.c ****                     abortCode = CO_SDO_AB_DATA_SHORT;
1604:../CANopen/stack/301/CO_SDOserver.c ****                     SDO->state = CO_SDO_ST_ABORT;
1605:../CANopen/stack/301/CO_SDOserver.c ****                     break;
1606:../CANopen/stack/301/CO_SDOserver.c ****                 }
1607:../CANopen/stack/301/CO_SDOserver.c ****             }
1608:../CANopen/stack/301/CO_SDOserver.c **** 
1609:../CANopen/stack/301/CO_SDOserver.c ****             /* is last segment or all segments in current block transferred? */
1610:../CANopen/stack/301/CO_SDOserver.c ****             if (SDO->bufOffsetWr == SDO->bufOffsetRd
1611:../CANopen/stack/301/CO_SDOserver.c ****                 || SDO->block_seqno >= SDO->block_blksize
1612:../CANopen/stack/301/CO_SDOserver.c ****             ) {
1613:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->state = CO_SDO_ST_UPLOAD_BLK_SUBBLOCK_CRSP;
1614:../CANopen/stack/301/CO_SDOserver.c ****             }
1615:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_FLAG_TIMERNEXT
1616:../CANopen/stack/301/CO_SDOserver.c ****             else {
1617:../CANopen/stack/301/CO_SDOserver.c ****                 /* Inform OS to call this function again without delay. */
1618:../CANopen/stack/301/CO_SDOserver.c ****                 if (timerNext_us != NULL) {
1619:../CANopen/stack/301/CO_SDOserver.c ****                     *timerNext_us = 0;
1620:../CANopen/stack/301/CO_SDOserver.c ****                 }
1621:../CANopen/stack/301/CO_SDOserver.c ****             }
1622:../CANopen/stack/301/CO_SDOserver.c **** #endif
1623:../CANopen/stack/301/CO_SDOserver.c ****             /* reset timeout timer and send message */
1624:../CANopen/stack/301/CO_SDOserver.c ****             SDO->timeoutTimer = 0;
1625:../CANopen/stack/301/CO_SDOserver.c ****             CO_CANsend(SDO->CANdevTx, SDO->CANtxBuff);
1626:../CANopen/stack/301/CO_SDOserver.c ****             break;
1627:../CANopen/stack/301/CO_SDOserver.c ****         }
1628:../CANopen/stack/301/CO_SDOserver.c **** 
1629:../CANopen/stack/301/CO_SDOserver.c ****         case CO_SDO_ST_UPLOAD_BLK_END_SREQ: {
1630:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[0] = 0xC1 | (SDO->block_noData << 2);
1631:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[1] = (uint8_t) SDO->block_crc;
1632:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[2] = (uint8_t) (SDO->block_crc >> 8);
1633:../CANopen/stack/301/CO_SDOserver.c **** 
1634:../CANopen/stack/301/CO_SDOserver.c ****             /* reset timeout timer and send message */
1635:../CANopen/stack/301/CO_SDOserver.c ****             SDO->timeoutTimer = 0;
1636:../CANopen/stack/301/CO_SDOserver.c ****             CO_CANsend(SDO->CANdevTx, SDO->CANtxBuff);
1637:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_UPLOAD_BLK_END_CRSP;
1638:../CANopen/stack/301/CO_SDOserver.c ****             break;
1639:../CANopen/stack/301/CO_SDOserver.c ****         }
1640:../CANopen/stack/301/CO_SDOserver.c **** #endif /* (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK */
1641:../CANopen/stack/301/CO_SDOserver.c **** 
1642:../CANopen/stack/301/CO_SDOserver.c ****         default: {
1643:../CANopen/stack/301/CO_SDOserver.c ****             break;
 3408              	 .loc 3 1643 0
 3409 09a6 00BF     	 nop
 3410              	.L184:
1644:../CANopen/stack/301/CO_SDOserver.c ****         }
1645:../CANopen/stack/301/CO_SDOserver.c ****         } /* switch (SDO->state) */
1646:../CANopen/stack/301/CO_SDOserver.c ****     }
1647:../CANopen/stack/301/CO_SDOserver.c **** 
1648:../CANopen/stack/301/CO_SDOserver.c ****     if (ret == CO_SDO_RT_waitingResponse) {
 3411              	 .loc 3 1648 0
 3412 09a8 97F96730 	 ldrsb r3,[r7,#103]
 3413 09ac 012B     	 cmp r3,#1
 3414 09ae 37D1     	 bne .L209
1649:../CANopen/stack/301/CO_SDOserver.c ****         if (SDO->state == CO_SDO_ST_ABORT) {
 3415              	 .loc 3 1649 0
 3416 09b0 FB68     	 ldr r3,[r7,#12]
 3417 09b2 1B7D     	 ldrb r3,[r3,#20]
 3418 09b4 DBB2     	 uxtb r3,r3
 3419 09b6 012B     	 cmp r3,#1
 3420 09b8 32D1     	 bne .L209
 3421              	.LBB19:
1650:../CANopen/stack/301/CO_SDOserver.c ****             uint32_t code = CO_SWAP_32((uint32_t)abortCode);
 3422              	 .loc 3 1650 0
 3423 09ba BB6A     	 ldr r3,[r7,#40]
 3424 09bc 3B61     	 str r3,[r7,#16]
1651:../CANopen/stack/301/CO_SDOserver.c ****             /* Send SDO abort message */
1652:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[0] = 0x80;
 3425              	 .loc 3 1652 0
 3426 09be FB68     	 ldr r3,[r7,#12]
 3427 09c0 5B68     	 ldr r3,[r3,#4]
 3428 09c2 8022     	 movs r2,#128
 3429 09c4 5A71     	 strb r2,[r3,#5]
1653:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[1] = (uint8_t)SDO->index;
 3430              	 .loc 3 1653 0
 3431 09c6 FB68     	 ldr r3,[r7,#12]
 3432 09c8 5B68     	 ldr r3,[r3,#4]
 3433 09ca FA68     	 ldr r2,[r7,#12]
 3434 09cc 928E     	 ldrh r2,[r2,#52]
 3435 09ce D2B2     	 uxtb r2,r2
 3436 09d0 9A71     	 strb r2,[r3,#6]
1654:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[2] = (uint8_t)(SDO->index >> 8);
 3437              	 .loc 3 1654 0
 3438 09d2 FB68     	 ldr r3,[r7,#12]
 3439 09d4 5B68     	 ldr r3,[r3,#4]
 3440 09d6 FA68     	 ldr r2,[r7,#12]
 3441 09d8 928E     	 ldrh r2,[r2,#52]
 3442 09da 120A     	 lsrs r2,r2,#8
 3443 09dc 92B2     	 uxth r2,r2
 3444 09de D2B2     	 uxtb r2,r2
 3445 09e0 DA71     	 strb r2,[r3,#7]
1655:../CANopen/stack/301/CO_SDOserver.c ****             SDO->CANtxBuff->data[3] = SDO->subIndex;
 3446              	 .loc 3 1655 0
 3447 09e2 FB68     	 ldr r3,[r7,#12]
 3448 09e4 5B68     	 ldr r3,[r3,#4]
 3449 09e6 FA68     	 ldr r2,[r7,#12]
 3450 09e8 92F83620 	 ldrb r2,[r2,#54]
 3451 09ec 1A72     	 strb r2,[r3,#8]
1656:../CANopen/stack/301/CO_SDOserver.c **** 
1657:../CANopen/stack/301/CO_SDOserver.c **** #if (C2000_PORT != 0)
1658:../CANopen/stack/301/CO_SDOserver.c ****             for(int i = 0; i < 4; i++) {
1659:../CANopen/stack/301/CO_SDOserver.c ****                 SDO->CANtxBuff->data[i + 4] = (uint8_t)((code >> (i * 8)) & 0x00FF);
1660:../CANopen/stack/301/CO_SDOserver.c ****             }
1661:../CANopen/stack/301/CO_SDOserver.c **** #else
1662:../CANopen/stack/301/CO_SDOserver.c ****             memcpy(&SDO->CANtxBuff->data[4], &code, sizeof(code));
 3452              	 .loc 3 1662 0
 3453 09ee FB68     	 ldr r3,[r7,#12]
 3454 09f0 5B68     	 ldr r3,[r3,#4]
 3455 09f2 03F10902 	 add r2,r3,#9
 3456 09f6 07F11003 	 add r3,r7,#16
 3457 09fa 1046     	 mov r0,r2
 3458 09fc 1946     	 mov r1,r3
 3459 09fe 0422     	 movs r2,#4
 3460 0a00 FFF7FEFF 	 bl memcpy
1663:../CANopen/stack/301/CO_SDOserver.c **** #endif
1664:../CANopen/stack/301/CO_SDOserver.c ****             CO_CANsend(SDO->CANdevTx, SDO->CANtxBuff);
 3461              	 .loc 3 1664 0
 3462 0a04 FB68     	 ldr r3,[r7,#12]
 3463 0a06 1A68     	 ldr r2,[r3]
 3464 0a08 FB68     	 ldr r3,[r7,#12]
 3465 0a0a 5B68     	 ldr r3,[r3,#4]
 3466 0a0c 1046     	 mov r0,r2
 3467 0a0e 1946     	 mov r1,r3
 3468 0a10 FFF7FEFF 	 bl CO_CANsend
1665:../CANopen/stack/301/CO_SDOserver.c ****             SDO->state = CO_SDO_ST_IDLE;
 3469              	 .loc 3 1665 0
 3470 0a14 FB68     	 ldr r3,[r7,#12]
 3471 0a16 0022     	 movs r2,#0
 3472 0a18 1A75     	 strb r2,[r3,#20]
1666:../CANopen/stack/301/CO_SDOserver.c ****             ret = CO_SDO_RT_endedWithServerAbort;
 3473              	 .loc 3 1666 0
 3474 0a1a F623     	 movs r3,#246
 3475 0a1c 87F86730 	 strb r3,[r7,#103]
 3476              	.L209:
 3477              	.LBE19:
1667:../CANopen/stack/301/CO_SDOserver.c ****         }
1668:../CANopen/stack/301/CO_SDOserver.c **** #if (CO_CONFIG_SDO_SRV) & CO_CONFIG_SDO_SRV_BLOCK
1669:../CANopen/stack/301/CO_SDOserver.c ****         else if (SDO->state == CO_SDO_ST_DOWNLOAD_BLK_SUBBLOCK_REQ) {
1670:../CANopen/stack/301/CO_SDOserver.c ****             ret = CO_SDO_RT_blockDownldInProgress;
1671:../CANopen/stack/301/CO_SDOserver.c ****         }
1672:../CANopen/stack/301/CO_SDOserver.c ****         else if (SDO->state == CO_SDO_ST_UPLOAD_BLK_SUBBLOCK_SREQ) {
1673:../CANopen/stack/301/CO_SDOserver.c ****             ret = CO_SDO_RT_blockUploadInProgress;
1674:../CANopen/stack/301/CO_SDOserver.c ****         }
1675:../CANopen/stack/301/CO_SDOserver.c **** #endif
1676:../CANopen/stack/301/CO_SDOserver.c ****     }
1677:../CANopen/stack/301/CO_SDOserver.c **** 
1678:../CANopen/stack/301/CO_SDOserver.c ****     return ret;
 3478              	 .loc 3 1678 0
 3479 0a20 97F86730 	 ldrb r3,[r7,#103]
 3480              	.L210:
 3481 0a24 5BB2     	 sxtb r3,r3
1679:../CANopen/stack/301/CO_SDOserver.c **** }
 3482              	 .loc 3 1679 0 discriminator 3
 3483 0a26 1846     	 mov r0,r3
 3484 0a28 6C37     	 adds r7,r7,#108
 3485              	.LCFI77:
 3486              	 .cfi_def_cfa_offset 12
 3487 0a2a BD46     	 mov sp,r7
 3488              	.LCFI78:
 3489              	 .cfi_def_cfa_register 13
 3490              	 
 3491 0a2c 90BD     	 pop {r4,r7,pc}
 3492              	.L219:
 3493 0a2e 00BF     	 .align 2
 3494              	.L218:
 3495 0a30 12000706 	 .word 101122066
 3496 0a34 13000706 	 .word 101122067
 3497              	 .cfi_endproc
 3498              	.LFE39:
 3500              	 .text
 3501              	.Letext0:
 3502              	 .file 4 "d:\\programs\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 3503              	 .file 5 "d:\\programs\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 3504              	 .file 6 "D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/driver/CO_driver_target.h"
 3505              	 .file 7 "D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301/CO_SDOserver.h"
DEFINED SYMBOLS
                            *ABS*:00000000 CO_SDOserver.c
    {standard input}:20     .text.CO_getUint8:00000000 $t
    {standard input}:24     .text.CO_getUint8:00000000 CO_getUint8
    {standard input}:66     .text.CO_getUint32:00000000 $t
    {standard input}:70     .text.CO_getUint32:00000000 CO_getUint32
    {standard input}:109    .text.OD_getIndex:00000000 $t
    {standard input}:113    .text.OD_getIndex:00000000 OD_getIndex
    {standard input}:162    .text.OD_mappable:00000000 $t
    {standard input}:166    .text.OD_mappable:00000000 OD_mappable
    {standard input}:219    .text.OD_extension_init:00000000 $t
    {standard input}:223    .text.OD_extension_init:00000000 OD_extension_init
    {standard input}:276    .text.OD_get_u8:00000000 $t
    {standard input}:280    .text.OD_get_u8:00000000 OD_get_u8
    {standard input}:326    .text.OD_get_u32:00000000 $t
    {standard input}:330    .text.OD_get_u32:00000000 OD_get_u32
    {standard input}:376    .text.OD_set_u32:00000000 $t
    {standard input}:380    .text.OD_set_u32:00000000 OD_set_u32
    {standard input}:425    .text.CO_SDO_receive:00000000 $t
    {standard input}:429    .text.CO_SDO_receive:00000000 CO_SDO_receive
    {standard input}:506    .text.CO_SDOserver_init_canRxTx:00000000 $t
    {standard input}:510    .text.CO_SDOserver_init_canRxTx:00000000 CO_SDOserver_init_canRxTx
    {standard input}:670    .text.CO_SDOserver_init_canRxTx:000000d4 $d
    {standard input}:675    .text.OD_write_1201_additional:00000000 $t
    {standard input}:679    .text.OD_write_1201_additional:00000000 OD_write_1201_additional
    {standard input}:732    .text.OD_write_1201_additional:0000003c $d
    {standard input}:736    .text.OD_write_1201_additional:0000004c $t
    {standard input}:1031   .text.OD_write_1201_additional:00000220 $d
    {standard input}:1036   .text.CO_SDOserver_init:00000000 $t
    {standard input}:1041   .text.CO_SDOserver_init:00000000 CO_SDOserver_init
    {standard input}:1396   .text.CO_SDOserver_init:00000224 $d
    {standard input}:1402   .text.validateAndWriteToOD:00000000 $t
    {standard input}:1406   .text.validateAndWriteToOD:00000000 validateAndWriteToOD
    {standard input}:1733   .text.validateAndWriteToOD:000001f8 $d
    {standard input}:1739   .text.readFromOd:00000000 $t
    {standard input}:1743   .text.readFromOd:00000000 readFromOd
    {standard input}:1973   .text.readFromOd:00000170 $d
    {standard input}:1978   .text.CO_SDOserver_process:00000000 $t
    {standard input}:1983   .text.CO_SDOserver_process:00000000 CO_SDOserver_process
    {standard input}:2349   .text.CO_SDOserver_process:0000025c $d
    {standard input}:2368   .text.CO_SDOserver_process:000002a8 $t
    {standard input}:2498   .text.CO_SDOserver_process:00000370 $d
    {standard input}:2506   .text.CO_SDOserver_process:00000388 $t
    {standard input}:2850   .text.CO_SDOserver_process:000005c4 $d
    {standard input}:2856   .text.CO_SDOserver_process:000005d4 $t
    {standard input}:2942   .text.CO_SDOserver_process:00000664 $d
    {standard input}:2961   .text.CO_SDOserver_process:000006b0 $t
    {standard input}:3239   .text.CO_SDOserver_process:00000884 $d
    {standard input}:3243   .text.CO_SDOserver_process:0000088c $t
    {standard input}:3495   .text.CO_SDOserver_process:00000a30 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memmove
OD_get_value
OD_set_value
memcpy
CO_CANrxBufferInit
CO_CANtxBufferInit
OD_writeOriginal
OD_readOriginal
OD_getSDOabCode
strlen
OD_find
OD_getSub
memset
CO_CANsend
