   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "CO_Emergency.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.CO_getUint8,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	CO_getUint8:
  25              	.LFB0:
  26              	 .file 1 "D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301/CO_driver.h"
   1:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
   2:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Interface between CAN hardware and CANopenNode.
   3:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
   4:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @file        CO_driver.h
   5:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @ingroup     CO_driver
   6:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @author      Janez Paternoster
   7:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @copyright   2004 - 2020 Janez Paternoster
   8:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
   9:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * This file is part of CANopenNode, an opensource CANopen Stack.
  10:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Project home page is <https://github.com/CANopenNode/CANopenNode>.
  11:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * For more information on CANopen see <http://www.can-cia.org/>.
  12:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  13:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Licensed under the Apache License, Version 2.0 (the "License");
  14:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * you may not use this file except in compliance with the License.
  15:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * You may obtain a copy of the License at
  16:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  17:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *     http://www.apache.org/licenses/LICENSE-2.0
  18:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  19:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Unless required by applicable law or agreed to in writing, software
  20:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * distributed under the License is distributed on an "AS IS" BASIS,
  21:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  22:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * See the License for the specific language governing permissions and
  23:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * limitations under the License.
  24:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
  25:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  26:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_DRIVER_H
  27:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_DRIVER_H
  28:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  29:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #include <string.h>
  30:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  31:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #include "CO_config.h"
  32:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #include "CO_driver_target.h"
  33:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  34:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifdef __cplusplus
  35:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** extern "C" {
  36:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  37:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  38:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /* Stack configuration default global values.
  39:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * For more information see file CO_config.h. */
  40:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_CONFIG_GLOBAL_FLAG_CALLBACK_PRE
  41:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #define CO_CONFIG_GLOBAL_FLAG_CALLBACK_PRE (0)
  42:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  43:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_CONFIG_GLOBAL_RT_FLAG_CALLBACK_PRE
  44:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #define CO_CONFIG_GLOBAL_RT_FLAG_CALLBACK_PRE (0)
  45:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  46:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_CONFIG_GLOBAL_FLAG_TIMERNEXT
  47:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #define CO_CONFIG_GLOBAL_FLAG_TIMERNEXT (0)
  48:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  49:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_CONFIG_GLOBAL_FLAG_OD_DYNAMIC
  50:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #define CO_CONFIG_GLOBAL_FLAG_OD_DYNAMIC CO_CONFIG_FLAG_OD_DYNAMIC
  51:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  52:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifdef CO_DEBUG_COMMON
  53:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #if (CO_CONFIG_DEBUG) & CO_CONFIG_DEBUG_SDO_CLIENT
  54:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****   #define CO_DEBUG_SDO_CLIENT(msg) CO_DEBUG_COMMON(msg)
  55:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #endif
  56:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #if (CO_CONFIG_DEBUG) & CO_CONFIG_DEBUG_SDO_SERVER
  57:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****   #define CO_DEBUG_SDO_SERVER(msg) CO_DEBUG_COMMON(msg)
  58:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  #endif
  59:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
  60:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
  61:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
  62:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @defgroup CO_driver Driver
  63:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Interface between CAN hardware and CANopenNode.
  64:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  65:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @ingroup CO_CANopen_301
  66:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @{
  67:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANopenNode is designed for speed and portability. It runs efficiently on
  68:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * devices from simple 16-bit microcontrollers to PC computers. It can run in
  69:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * multiple threads. Reception of CAN messages is pre-processed with very fast
  70:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * functions. Time critical objects, such as PDO or SYNC are processed in
  71:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * real-time thread and other objects are processed in normal thread. See
  72:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Flowchart in [README.md](index.html) for more information.
  73:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  74:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @anchor CO_obj
  75:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * #### CANopenNode Object
  76:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANopenNode is implemented as a collection of different objects, for example
  77:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * SDO, SYNC, Emergency, PDO, NMT, Heartbeat, etc. Code is written in C language
  78:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * and tries to be object oriented. So each CANopenNode Object is implemented in
  79:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * a pair of .h/.c files. It basically contains a structure with all necessary
  80:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * variables and some functions which operates on it. CANopenNode Object is
  81:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * usually connected with one or more CAN receive or transmit Message Objects.
  82:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * (CAN message Object is a CAN message with specific 11-bit CAN identifier
  83:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * (usually one fixed or a range).)
  84:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  85:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * #### Hardware interface of CANopenNode
  86:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * It consists of minimum three files:
  87:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - **CO_driver.h** file declares common functions. This file is part of the
  88:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANopenNode. It is included from each .c file from CANopenNode.
  89:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - **CO_driver_target.h** file declares microcontroller specific type
  90:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * declarations and defines some macros, which are necessary for CANopenNode.
  91:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * This file is included from CO_driver.h.
  92:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - **CO_driver.c** file defines functions declared in CO_driver.h.
  93:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
  94:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * **CO_driver_target.h** and **CO_driver.c** files are specific for each
  95:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * different microcontroller and are not part of CANopenNode. There are separate
  96:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * projects for different microcontrollers, which usually include CANopenNode as
  97:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * a git submodule. CANopenNode only includes those two files in the `example`
  98:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * directory and they are basically empty. It should be possible to compile the
  99:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * `CANopenNode/example` on any system, however compiled program is not usable.
 100:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CO_driver.h contains documentation for all necessary macros, types and
 101:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * functions.
 102:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 103:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * See [CANopenNode/Wiki](https://github.com/CANopenNode/CANopenNode/wiki) for a
 104:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * known list of available implementations of CANopenNode on different systems
 105:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * and microcontrollers. Everybody is welcome to extend the list with a link to
 106:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * his own implementation.
 107:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 108:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Implementation of the hardware interface for specific microcontroller is not
 109:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * always an easy task. For reliable and efficient operation it is necessary to
 110:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * know some parts of the target microcontroller in detail (for example threads
 111:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * (or interrupts), CAN module, etc.).
 112:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 113:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 114:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Major version number of CANopenNode */
 115:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_VERSION_MAJOR 4
 116:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Minor version number of CANopenNode */
 117:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_VERSION_MINOR 0
 118:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 119:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 120:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /* Macros and declarations in following part are only used for documentation. */
 121:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifdef CO_DOXYGEN
 122:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 123:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @defgroup CO_dataTypes Basic definitions
 124:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @{
 125:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 126:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Target specific basic definitions and data types.
 127:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 128:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 129:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 130:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Depending on processor or compiler architecture, one of the two macros must
 131:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * be defined: CO_LITTLE_ENDIAN or CO_BIG_ENDIAN. CANopen itself is little
 132:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * endian.
 133:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 134:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Basic data types may be specified differently on different architectures.
 135:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Usually `true` and `false` are defined in `<stdbool.h>`, `NULL` is defined in
 136:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * `<stddef.h>`, `int8_t` to `uint64_t` are defined in `<stdint.h>`.
 137:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 138:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** CO_LITTLE_ENDIAN or CO_BIG_ENDIAN must be defined */
 139:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_LITTLE_ENDIAN
 140:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Macro must swap bytes, if CO_BIG_ENDIAN is defined */
 141:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_SWAP_16(x) x
 142:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Macro must swap bytes, if CO_BIG_ENDIAN is defined */
 143:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_SWAP_32(x) x
 144:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Macro must swap bytes, if CO_BIG_ENDIAN is defined */
 145:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_SWAP_64(x) x
 146:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** NULL, for general usage */
 147:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define NULL (0)
 148:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Logical true, for general use */
 149:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define true 1
 150:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Logical false, for general use */
 151:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define false 0
 152:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Boolean data type for general use */
 153:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef uint_fast8_t bool_t;
 154:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** INTEGER8 in CANopen (0002h), 8-bit signed integer */
 155:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef signed char int8_t;
 156:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** INTEGER16 in CANopen (0003h), 16-bit signed integer */
 157:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef signed int int16_t;
 158:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** INTEGER32 in CANopen (0004h), 32-bit signed integer */
 159:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef signed long int int32_t;
 160:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** INTEGER64 in CANopen (0015h), 64-bit signed integer */
 161:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef signed long long int int64_t;
 162:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** UNSIGNED8 in CANopen (0005h), 8-bit unsigned integer */
 163:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef unsigned char uint8_t;
 164:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** UNSIGNED16 in CANopen (0006h), 16-bit unsigned integer */
 165:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef unsigned int uint16_t;
 166:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** UNSIGNED32 in CANopen (0007h), 32-bit unsigned integer */
 167:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef unsigned long int uint32_t;
 168:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** UNSIGNED64 in CANopen (001Bh), 64-bit unsigned integer */
 169:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef unsigned long long int uint64_t;
 170:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** REAL32 in CANopen (0008h), single precision floating point value, 32-bit */
 171:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef float float32_t;
 172:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** REAL64 in CANopen (0011h), double precision floating point value, 64-bit */
 173:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef double float64_t;
 174:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** @} */
 175:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 176:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 177:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 178:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @defgroup CO_CAN_Message_reception Reception of CAN messages
 179:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @{
 180:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 181:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Target specific definitions and description of CAN message reception
 182:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 183:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN messages in CANopenNode are usually received by its own thread or higher
 184:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * priority interrupt. Received CAN messages are first filtered by hardware or
 185:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * by software. Thread then examines its 11-bit CAN-id and mask and determines,
 186:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * to which \ref CO_obj "CANopenNode Object" it belongs to. After that it calls
 187:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * predefined CANrx_callback() function, which quickly pre-processes the message
 188:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * and fetches the relevant data. CANrx_callback() function is defined by each
 189:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * \ref CO_obj "CANopenNode Object" separately. Pre-processed fetched data are
 190:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * later processed in another thread.
 191:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 192:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * If \ref CO_obj "CANopenNode Object" reception of specific CAN message, it
 193:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * must first configure its own CO_CANrx_t object with the CO_CANrxBufferInit()
 194:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * function.
 195:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 196:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 197:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 198:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN receive callback function which pre-processes received CAN message
 199:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 200:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * It is called by fast CAN receive thread. Each \ref CO_obj "CANopenNode
 201:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Object" defines its own and registers it with CO_CANrxBufferInit(), by
 202:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * passing function pointer.
 203:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 204:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param object pointer to specific \ref CO_obj "CANopenNode Object",
 205:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * registered with CO_CANrxBufferInit()
 206:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxMsg pointer to received CAN message
 207:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 208:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CANrx_callback(void *object, void *rxMsg);
 209:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 210:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 211:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANrx_callback() can read CAN identifier from received CAN message
 212:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 213:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 214:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 215:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * This is target specific function and is specific for specific
 216:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * microcontroller. It is best to implement it by using inline function or
 217:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * macro. `rxMsg` parameter should cast to a pointer to structure. For best
 218:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * efficiency structure may have the same alignment as CAN registers inside CAN
 219:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * module.
 220:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 221:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxMsg Pointer to received message
 222:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return 11-bit CAN standard identifier.
 223:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 224:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint16_t CO_CANrxMsg_readIdent(void *rxMsg) {
 225:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return 0;
 226:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
 227:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 228:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 229:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANrx_callback() can read Data Length Code from received CAN message
 230:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 231:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * See also CO_CANrxMsg_readIdent():
 232:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 233:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxMsg Pointer to received message
 234:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return data length in bytes (0 to 8)
 235:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 236:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint8_t CO_CANrxMsg_readDLC(void *rxMsg) {
 237:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return 0;
 238:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
 239:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 240:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 241:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANrx_callback() can read pointer to data from received CAN message
 242:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 243:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * See also CO_CANrxMsg_readIdent():
 244:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 245:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxMsg Pointer to received message
 246:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return pointer to data buffer
 247:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 248:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint8_t *CO_CANrxMsg_readData(void *rxMsg) {
 249:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return NULL;
 250:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
 251:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 252:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 253:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Configuration object for CAN received message for specific \ref CO_obj
 254:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * "CANopenNode Object".
 255:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 256:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 257:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 258:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Data fields of this structure are used exclusively by the driver. Usually it
 259:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * has the following data fields, but they may differ for different
 260:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * microcontrollers. Array of multiple CO_CANrx_t objects is included inside
 261:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CO_CANmodule_t.
 262:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 263:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef struct {
 264:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t ident; /**< Standard CAN Identifier (bits 0..10) + RTR (bit 11) */
 265:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t mask;  /**< Standard CAN Identifier mask with the same alignment as
 266:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                        ident */
 267:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void *object;   /**< \ref CO_obj "CANopenNode Object" initialized in from
 268:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                        CO_CANrxBufferInit() */
 269:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void (*pCANrx_callback)(
 270:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         void *object, void *message); /**< Pointer to CANrx_callback()
 271:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          initialized in CO_CANrxBufferInit() */
 272:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_CANrx_t;
 273:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** @} */
 274:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 275:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 276:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 277:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @defgroup CO_CAN_Message_transmission Transmission of CAN messages
 278:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @{
 279:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 280:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Target specific definitions and description of CAN message transmission
 281:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 282:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * If \ref CO_obj "CANopenNode Object" needs transmitting CAN message, it must
 283:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * first configure its own CO_CANtx_t object with the CO_CANtxBufferInit()
 284:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * function. CAN message can then be sent with CO_CANsend() function. If at that
 285:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * moment CAN transmit buffer inside microcontroller's CAN module is free,
 286:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * message is copied directly to the CAN module. Otherwise CO_CANsend() function
 287:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * sets _bufferFull_ flag to true. Message will be then sent by CAN TX interrupt
 288:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * as soon as CAN module is freed. Until message is not copied to CAN module,
 289:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * its contents must not change. If there are multiple CO_CANtx_t objects with
 290:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * _bufferFull_ flag set to true, then CO_CANtx_t with lower index will be sent
 291:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * first.
 292:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 293:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 294:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 295:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Configuration object for CAN transmit message for specific \ref CO_obj
 296:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * "CANopenNode Object".
 297:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 298:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 299:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 300:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Data fields of this structure are used exclusively by the driver. Usually it
 301:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * has the following data fields, but they may differ for different
 302:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * microcontrollers. Array of multiple CO_CANtx_t objects is included inside
 303:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CO_CANmodule_t.
 304:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 305:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef struct {
 306:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint32_t ident;             /**< CAN identifier as aligned in CAN module */
 307:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t DLC;                /**< Length of CAN message */
 308:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t data[8];            /**< 8 data bytes */
 309:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t bufferFull; /**< True if previous message is still in the
 310:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                      buffer */
 311:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t syncFlag;   /**< Synchronous PDO messages has this flag set.
 312:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                   It prevents them to be sent outside the synchronous window */
 313:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_CANtx_t;
 314:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** @} */
 315:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 316:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 317:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 318:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Complete CAN module object.
 319:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 320:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 321:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 322:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Usually it has the following data fields, but they may differ for different
 323:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * microcontrollers.
 324:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 325:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef struct {
 326:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void *CANptr;                      /**< From CO_CANmodule_init() */
 327:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CANrx_t *rxArray;               /**< From CO_CANmodule_init() */
 328:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t rxSize;                   /**< From CO_CANmodule_init() */
 329:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CANtx_t *txArray;               /**< From CO_CANmodule_init() */
 330:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t txSize;                   /**< From CO_CANmodule_init() */
 331:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t CANerrorStatus;           /**< CAN error status bitfield,
 332:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                             see @ref CO_CAN_ERR_status_t */
 333:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t CANnormal;         /**< CAN module is in normal mode */
 334:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t useCANrxFilters;   /**< Value different than zero indicates,
 335:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             that CAN module hardware filters are used for CAN reception. If
 336:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             there is not enough hardware filters, they won't be used. In this
 337:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             case will be *all* received CAN messages processed by software. */
 338:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t bufferInhibitFlag; /**< If flag is true, then message in
 339:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             transmit buffer is synchronous PDO message, which will be aborted,
 340:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             if CO_clearPendingSyncPDOs() function will be called by application.
 341:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             This may be necessary if Synchronous window time was expired. */
 342:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile bool_t firstCANtxMessage; /**< Equal to 1, when the first
 343:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             transmitted message (bootup message) is in CAN TX buffers */
 344:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     volatile uint16_t CANtxCount;      /**< Number of messages in transmit
 345:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****             buffer, which are waiting to be copied to the CAN module */
 346:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint32_t errOld;                   /**< Previous state of CAN errors */
 347:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_CANmodule_t;
 348:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 349:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 350:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 351:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Data storage object for one entry.
 352:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 353:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Must be defined in the **CO_driver_target.h** file.
 354:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 355:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * For more information on Data storage see @ref CO_storage or **CO_storage.h**
 356:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * file. Structure members documented here are always required or required with
 357:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @ref CO_storage_eeprom. Target system may add own additional, hardware
 358:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * specific variables.
 359:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 360:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef struct {
 361:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Address of data to store, always required. */
 362:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void *addr;
 363:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Length of data to store, always required. */
 364:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     size_t len;
 365:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Sub index in OD objects 1010 and 1011, from 2 to 127. Writing
 366:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * 0x65766173 to 1010,subIndexOD will store data to non-volatile memory.
 367:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * Writing 0x64616F6C to 1011,subIndexOD will restore default data, always
 368:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * required. */
 369:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t subIndexOD;
 370:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Attribute from @ref CO_storage_attributes_t, always required. */
 371:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t attr;
 372:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Pointer to storage module, target system specific usage, required with
 373:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * @ref CO_storage_eeprom. */
 374:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void *storageModule;
 375:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** CRC checksum of the data stored in eeprom, set on store, required with
 376:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * @ref CO_storage_eeprom. */
 377:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t crc;
 378:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Address of entry signature inside eeprom, set by init, required with
 379:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * @ref CO_storage_eeprom. */
 380:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     size_t eepromAddrSignature;
 381:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Address of data inside eeprom, set by init, required with
 382:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * @ref CO_storage_eeprom. */
 383:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     size_t eepromAddr;
 384:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Offset of next byte being updated by automatic storage, required with
 385:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****      * @ref CO_storage_eeprom. */
 386:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     size_t offset;
 387:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     /** Additional target specific parameters, optional. */
 388:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     void *additionalParameters;
 389:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_storage_entry_t;
 390:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 391:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 392:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 393:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @defgroup CO_critical_sections Critical sections
 394:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @{
 395:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 396:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Protection of critical sections in multi-threaded operation.
 397:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 398:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANopenNode is designed to run in different threads, as described in
 399:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * [README.md](index.html). Threads are implemented differently in different
 400:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * systems. In microcontrollers threads are interrupts with different
 401:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * priorities, for example. It is necessary to protect sections, where different
 402:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * threads access to the same resource. In simple systems interrupts or
 403:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * scheduler may be temporary disabled between access to the shared resource.
 404:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Otherwise mutexes or semaphores can be used.
 405:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 406:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * #### Reentrant functions
 407:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Functions CO_CANsend() from C_driver.h, and CO_error() from CO_Emergency.h
 408:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * may be called from different threads. Critical sections must be protected.
 409:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Either by disabling scheduler or interrupts or by mutexes or semaphores.
 410:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Lock/unlock macro is called with pointer to CAN module, which may be used
 411:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * inside.
 412:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 413:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * #### Object Dictionary variables
 414:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * In general, there are two threads, which accesses OD variables: mainline
 415:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * (initialization, storage, SDO access) and timer (PDO access). CANopenNode
 416:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * uses locking mechanism, where SDO server (or other mainline code) prevents
 417:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * execution of the real-time thread at the moment it reads or writes OD
 418:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * variable. CO_LOCK_OD(CAN_MODULE) and CO_UNLOCK_OD(CAN_MODULE) macros
 419:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * are used to protect:
 420:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - Whole real-time thread,
 421:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - SDO server protects read/write access to OD variable, if specific OD
 422:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   variable has ODA_TRPDO or ODA_TRSRDO from @ref OD_attributes_t set. If
 423:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   those attributes are not set, OD variable is not locked by SDO server.
 424:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   Locking of long OD variables, not accessible from real-time thread, may
 425:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   block RT thread.
 426:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - Any mainline code, which accesses PDO-mappable OD variable, must protect
 427:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   read/write with locking macros. Use @ref OD_mappable() for check.
 428:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * - Other cases, where non-PDO-mappable OD variable is used inside real-time
 429:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   thread by some other part of the user application must be considered with
 430:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *   special care.
 431:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 432:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * #### Synchronization functions for CAN receive
 433:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * After CAN message is received, it is pre-processed in CANrx_callback(), which
 434:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * copies some data into appropriate object and at the end sets **new_message**
 435:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * flag. This flag is then pooled in another thread, which further processes the
 436:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * message. The problem is, that compiler optimization may shuffle memory
 437:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * operations, so it is necessary to ensure, that **new_message** flag is surely
 438:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * set at the end. It is necessary to use [Memory
 439:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * barrier](https://en.wikipedia.org/wiki/Memory_barrier).
 440:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 441:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * If receive function runs inside IRQ, no further synchronization is needed.
 442:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Otherwise, some kind of synchronization has to be included. The following
 443:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * example uses GCC builtin memory barrier `__sync_synchronize()`. More
 444:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * information can be found
 445:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * [here](https://stackoverflow.com/questions/982129/what-does-sync-synchronize-do#982179).
 446:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 447:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 448:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Lock critical section in CO_CANsend() */
 449:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_LOCK_CAN_SEND(CAN_MODULE)
 450:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Unlock critical section in CO_CANsend() */
 451:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_UNLOCK_CAN_SEND(CAN_MODULE)
 452:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Lock critical section in CO_errorReport() or CO_errorReset() */
 453:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_LOCK_EMCY(CAN_MODULE)
 454:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Unlock critical section in CO_errorReport() or CO_errorReset() */
 455:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_UNLOCK_EMCY(CAN_MODULE)
 456:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Lock critical section when accessing Object Dictionary */
 457:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_LOCK_OD(CAN_MODULE)
 458:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Unock critical section when accessing Object Dictionary */
 459:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_UNLOCK_OD(CAN_MODULE)
 460:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 461:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Check if new message has arrived */
 462:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_FLAG_READ(rxNew) ((rxNew) != NULL)
 463:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Set new message flag */
 464:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_FLAG_SET(rxNew) { __sync_synchronize(); rxNew = (void *)1L; }
 465:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Clear new message flag */
 466:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_FLAG_CLEAR(rxNew) { __sync_synchronize(); rxNew = NULL; }
 467:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 468:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** @} */
 469:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif /* CO_DOXYGEN */
 470:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 471:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 472:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 473:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Default CANopen identifiers.
 474:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 475:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Default CANopen identifiers for CANopen communication objects. Same as
 476:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * 11-bit addresses of CAN messages. These are default identifiers and
 477:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * can be changed in CANopen. Especially PDO identifiers are configured
 478:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * in PDO linking phase of the CANopen network configuration.
 479:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 480:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef enum {
 481:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_NMT_SERVICE = 0x000, /**< 0x000, Network management */
 482:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_GFC = 0x001,         /**< 0x001, Global fail-safe command */
 483:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_SYNC = 0x080,        /**< 0x080, Synchronous message */
 484:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_EMERGENCY = 0x080,   /**< 0x080, Emergency messages (+nodeID) */
 485:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_TIME = 0x100,        /**< 0x100, Time message */
 486:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_SRDO_1 = 0x0FF,      /**< 0x0FF, Default SRDO1 (+2*nodeID) */
 487:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_TPDO_1 = 0x180,      /**< 0x180, Default TPDO1 (+nodeID) */
 488:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_RPDO_1 = 0x200,      /**< 0x200, Default RPDO1 (+nodeID) */
 489:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_TPDO_2 = 0x280,      /**< 0x280, Default TPDO2 (+nodeID) */
 490:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_RPDO_2 = 0x300,      /**< 0x300, Default RPDO2 (+nodeID) */
 491:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_TPDO_3 = 0x380,      /**< 0x380, Default TPDO3 (+nodeID) */
 492:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_RPDO_3 = 0x400,      /**< 0x400, Default RPDO3 (+nodeID) */
 493:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_TPDO_4 = 0x480,      /**< 0x480, Default TPDO4 (+nodeID) */
 494:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_RPDO_4 = 0x500,      /**< 0x500, Default RPDO5 (+nodeID) */
 495:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_SDO_SRV = 0x580, /**< 0x580, SDO response from server (+nodeID) */
 496:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_SDO_CLI = 0x600, /**< 0x600, SDO request from client (+nodeID) */
 497:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_HEARTBEAT = 0x700,   /**< 0x700, Heartbeat message */
 498:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_LSS_SLV = 0x7E4,     /**< 0x7E4, LSS response from slave */
 499:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ID_LSS_MST = 0x7E5      /**< 0x7E5, LSS request from master */
 500:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_Default_CAN_ID_t;
 501:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 502:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 503:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 504:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Restricted CAN-IDs
 505:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 506:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Macro for verifying 'Restricted CAN-IDs', as specified by standard CiA301.
 507:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * They shall not be used for SYNC, TIME, EMCY, PDO and SDO.
 508:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 509:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #ifndef CO_IS_RESTRICTED_CAN_ID
 510:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #define CO_IS_RESTRICTED_CAN_ID(CAN_ID) ((CAN_ID) <= 0x7F \
 511:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         || ((CAN_ID) >= 0x101 && (CAN_ID) <= 0x180) \
 512:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         || ((CAN_ID) >= 0x581 && (CAN_ID) <= 0x5FF) \
 513:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         || ((CAN_ID) >= 0x601 && (CAN_ID) <= 0x67F) \
 514:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         || ((CAN_ID) >= 0x6E0 && (CAN_ID) <= 0x6FF) \
 515:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         || (CAN_ID) >= 0x701)
 516:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
 517:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 518:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 519:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 520:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN error status bitmasks.
 521:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 522:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN warning level is reached, if CAN transmit or receive error counter is
 523:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * more or equal to 96. CAN passive level is reached, if counters are more or
 524:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * equal to 128. Transmitter goes in error state 'bus off' if transmit error
 525:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * counter is more or equal to 256.
 526:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 527:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef enum {
 528:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRTX_WARNING = 0x0001,  /**< 0x0001, CAN transmitter warning */
 529:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRTX_PASSIVE = 0x0002,  /**< 0x0002, CAN transmitter passive */
 530:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRTX_BUS_OFF = 0x0004,  /**< 0x0004, CAN transmitter bus off */
 531:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRTX_OVERFLOW = 0x0008, /**< 0x0008, CAN transmitter overflow */
 532:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 533:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRTX_PDO_LATE = 0x0080, /**< 0x0080, TPDO is outside sync window */
 534:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 535:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRRX_WARNING = 0x0100,  /**< 0x0100, CAN receiver warning */
 536:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRRX_PASSIVE = 0x0200,  /**< 0x0200, CAN receiver passive */
 537:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERRRX_OVERFLOW = 0x0800, /**< 0x0800, CAN receiver overflow */
 538:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 539:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_CAN_ERR_WARN_PASSIVE = 0x0303/**< 0x0303, combination */
 540:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_CAN_ERR_status_t;
 541:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 542:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 543:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 544:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Return values of some CANopen functions. If function was executed
 545:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * successfully it returns 0 otherwise it returns <0.
 546:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 547:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** typedef enum {
 548:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_NO = 0,                /**< Operation completed successfully */
 549:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_ILLEGAL_ARGUMENT = -1, /**< Error in function arguments */
 550:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_OUT_OF_MEMORY = -2,    /**< Memory allocation failed */
 551:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_TIMEOUT = -3,          /**< Function timeout */
 552:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_ILLEGAL_BAUDRATE = -4, /**< Illegal baudrate passed to function
 553:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          CO_CANmodule_init() */
 554:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_RX_OVERFLOW = -5,      /**< Previous message was not processed
 555:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          yet */
 556:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_RX_PDO_OVERFLOW = -6,  /**< previous PDO was not processed yet */
 557:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_RX_MSG_LENGTH = -7,    /**< Wrong receive message length */
 558:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_RX_PDO_LENGTH = -8,    /**< Wrong receive PDO length */
 559:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_TX_OVERFLOW = -9,      /**< Previous message is still waiting,
 560:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          buffer full */
 561:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_TX_PDO_WINDOW = -10,   /**< Synchronous TPDO is outside window */
 562:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_TX_UNCONFIGURED = -11, /**< Transmit buffer was not configured
 563:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          properly */
 564:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_OD_PARAMETERS = -12,   /**< Error in Object Dictionary parameters*/
 565:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_DATA_CORRUPT = -13,    /**< Stored data are corrupt */
 566:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_CRC = -14,             /**< CRC does not match */
 567:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_TX_BUSY = -15,         /**< Sending rejected because driver is
 568:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          busy. Try again */
 569:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_WRONG_NMT_STATE = -16, /**< Command can't be processed in current
 570:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          state */
 571:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_SYSCALL = -17,         /**< Syscall failed */
 572:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_INVALID_STATE = -18,   /**< Driver not ready */
 573:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     CO_ERROR_NODE_ID_UNCONFIGURED_LSS = -19 /**< Node-id is in LSS unconfigured
 574:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          state. If objects are handled properly,
 575:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                          this may not be an error. */
 576:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** } CO_ReturnError_t;
 577:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 578:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 579:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 580:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Request CAN configuration (stopped) mode and *wait* until it is set.
 581:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 582:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANptr Pointer to CAN device
 583:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 584:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CO_CANsetConfigurationMode(void *CANptr);
 585:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 586:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 587:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 588:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Request CAN normal (operational) mode and *wait* until it is set.
 589:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 590:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule CO_CANmodule_t object.
 591:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 592:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CO_CANsetNormalMode(CO_CANmodule_t *CANmodule);
 593:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 594:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 595:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 596:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Initialize CAN module object.
 597:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 598:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Function must be called in the communication reset section. CAN module must
 599:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * be in Configuration Mode before.
 600:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 601:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object will be initialized.
 602:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANptr Pointer to CAN device.
 603:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxArray Array for handling received CAN messages
 604:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rxSize Size of the above array. Must be equal to number of receiving
 605:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN objects.
 606:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param txArray Array for handling transmitting CAN messages
 607:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param txSize Size of the above array. Must be equal to number of
 608:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * transmitting CAN objects.
 609:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANbitRate Valid values are (in kbps): 10, 20, 50, 125, 250, 500, 800,
 610:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * 1000. If value is illegal, bitrate defaults to 125.
 611:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 612:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Return #CO_ReturnError_t: CO_ERROR_NO or CO_ERROR_ILLEGAL_ARGUMENT.
 613:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 614:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** CO_ReturnError_t CO_CANmodule_init(CO_CANmodule_t *CANmodule,
 615:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    void *CANptr,
 616:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    CO_CANrx_t rxArray[],
 617:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    uint16_t rxSize,
 618:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    CO_CANtx_t txArray[],
 619:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    uint16_t txSize,
 620:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                    uint16_t CANbitRate);
 621:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 622:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 623:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 624:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Switch off CANmodule. Call at program exit.
 625:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 626:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule CAN module object.
 627:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 628:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CO_CANmodule_disable(CO_CANmodule_t *CANmodule);
 629:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 630:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 631:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 632:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Configure CAN message receive buffer.
 633:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 634:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Function configures specific CAN receive buffer. It sets CAN identifier
 635:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * and connects buffer with specific object. Function must be called for each
 636:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * member in _rxArray_ from CO_CANmodule_t.
 637:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 638:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object.
 639:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param index Index of the specific buffer in _rxArray_.
 640:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param ident 11-bit standard CAN Identifier. If two or more CANrx buffers
 641:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * have the same _ident_, then buffer with lowest _index_ has precedence and
 642:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * other CANrx buffers will be ignored.
 643:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param mask 11-bit mask for identifier. Most usually set to 0x7FF.
 644:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Received message (rcvMsg) will be accepted if the following
 645:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * condition is true: (((rcvMsgId ^ ident) & mask) == 0).
 646:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rtr If true, 'Remote Transmit Request' messages will be accepted.
 647:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param object CANopen object, to which buffer is connected. It will be used
 648:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * as an argument to CANrx_callback. Its type is (void), CANrx_callback will
 649:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * change its type back to the correct object type.
 650:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANrx_callback Pointer to function, which will be called, if received
 651:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CAN message matches the identifier. It must be fast function.
 652:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 653:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Return #CO_ReturnError_t: CO_ERROR_NO CO_ERROR_ILLEGAL_ARGUMENT or
 654:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CO_ERROR_OUT_OF_MEMORY (not enough masks for configuration).
 655:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 656:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** CO_ReturnError_t CO_CANrxBufferInit(CO_CANmodule_t *CANmodule,
 657:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     uint16_t index,
 658:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     uint16_t ident,
 659:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     uint16_t mask,
 660:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     bool_t rtr,
 661:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     void *object,
 662:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                     void (*CANrx_callback)(void *object,
 663:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                                            void *message));
 664:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 665:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 666:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 667:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Configure CAN message transmit buffer.
 668:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 669:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Function configures specific CAN transmit buffer. Function must be called for
 670:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * each member in _txArray_ from CO_CANmodule_t.
 671:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 672:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object.
 673:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param index Index of the specific buffer in _txArray_.
 674:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param ident 11-bit standard CAN Identifier.
 675:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param rtr If true, 'Remote Transmit Request' messages will be transmitted.
 676:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param noOfBytes Length of CAN message in bytes (0 to 8 bytes).
 677:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param syncFlag This flag bit is used for synchronous TPDO messages. If it is
 678:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * set, message will not be sent, if current time is outside synchronous window.
 679:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 680:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return Pointer to CAN transmit message buffer. 8 bytes data array inside
 681:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * buffer should be written, before CO_CANsend() function is called.
 682:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Zero is returned in case of wrong arguments.
 683:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 684:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** CO_CANtx_t *CO_CANtxBufferInit(CO_CANmodule_t *CANmodule,
 685:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                uint16_t index,
 686:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                uint16_t ident,
 687:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                bool_t rtr,
 688:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                uint8_t noOfBytes,
 689:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****                                bool_t syncFlag);
 690:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 691:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 692:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 693:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Send CAN message.
 694:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 695:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object.
 696:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param buffer Pointer to transmit buffer, returned by CO_CANtxBufferInit().
 697:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Data bytes must be written in buffer before function call.
 698:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 699:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return #CO_ReturnError_t: CO_ERROR_NO, CO_ERROR_TX_OVERFLOW or
 700:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CO_ERROR_TX_PDO_WINDOW (Synchronous TPDO is outside window).
 701:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 702:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** CO_ReturnError_t CO_CANsend(CO_CANmodule_t *CANmodule, CO_CANtx_t *buffer);
 703:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 704:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 705:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 706:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Clear all synchronous TPDOs from CAN module transmit buffers.
 707:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 708:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * CANopen allows synchronous PDO communication only inside time between SYNC
 709:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * message and SYNC Window. If time is outside this window, new synchronous PDOs
 710:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * must not be sent and all pending sync TPDOs, which may be on CAN TX buffers,
 711:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * may optionally be cleared.
 712:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 713:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * This function checks (and aborts transmission if necessary) CAN TX buffers
 714:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * when it is called. Function should be called by the stack in the moment,
 715:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * when SYNC time was just passed out of synchronous window.
 716:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 717:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object.
 718:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 719:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CO_CANclearPendingSyncPDOs(CO_CANmodule_t *CANmodule);
 720:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 721:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 722:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 723:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Process can module - verify CAN errors
 724:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 725:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Function must be called cyclically. It should calculate CANerrorStatus
 726:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * bitfield for CAN errors defined in @ref CO_CAN_ERR_status_t.
 727:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 728:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param CANmodule This object.
 729:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 730:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** void CO_CANmodule_process(CO_CANmodule_t *CANmodule);
 731:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 732:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 733:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 734:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Get uint8_t value from memory buffer
 735:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 736:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param buf Memory buffer to get value from.
 737:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 738:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return Value
 739:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 740:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint8_t CO_getUint8(const void *buf) {
  27              	 .loc 1 740 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 85B0     	 sub sp,sp,#20
  37              	.LCFI1:
  38              	 .cfi_def_cfa_offset 24
  39 0004 00AF     	 add r7,sp,#0
  40              	.LCFI2:
  41              	 .cfi_def_cfa_register 7
  42 0006 7860     	 str r0,[r7,#4]
 741:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #if (C2000_PORT != 0)
 742:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t value = 0;
 743:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     value = (*((uint8_t *)buf) & 0x00FF);
 744:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return value;
 745:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #else
 746:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t value; memmove(&value, buf, sizeof(value)); return value;
  43              	 .loc 1 746 0
  44 0008 7B68     	 ldr r3,[r7,#4]
  45 000a 1B78     	 ldrb r3,[r3]
  46 000c FB73     	 strb r3,[r7,#15]
  47 000e FB7B     	 ldrb r3,[r7,#15]
 747:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
 748:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
  48              	 .loc 1 748 0
  49 0010 1846     	 mov r0,r3
  50 0012 1437     	 adds r7,r7,#20
  51              	.LCFI3:
  52              	 .cfi_def_cfa_offset 4
  53 0014 BD46     	 mov sp,r7
  54              	.LCFI4:
  55              	 .cfi_def_cfa_register 13
  56              	 
  57 0016 5DF8047B 	 ldr r7,[sp],#4
  58              	.LCFI5:
  59              	 .cfi_restore 7
  60              	 .cfi_def_cfa_offset 0
  61 001a 7047     	 bx lr
  62              	 .cfi_endproc
  63              	.LFE0:
  65              	 .section .text.CO_setUint8,"ax",%progbits
  66              	 .align 2
  67              	 .thumb
  68              	 .thumb_func
  70              	CO_setUint8:
  71              	.LFB3:
 749:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Get uint16_t value from memory buffer, see @ref CO_getUint8 */
 750:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint16_t CO_getUint16(const void *buf) {
 751:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #if (C2000_PORT != 0)
 752:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t value = 0;
 753:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t * pBuf8 = (uint8_t *)buf;
 754:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     for (int i = 0; i < 2; i++) {
 755:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         value += ((uint16_t)(pBuf8[i])) << (8 * i);
 756:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     }
 757:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return value;
 758:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #else
 759:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint16_t value; memmove(&value, buf, sizeof(value)); return value;
 760:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
 761:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
 762:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Get uint32_t value from memory buffer, see @ref CO_getUint8 */
 763:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint32_t CO_getUint32(const void *buf) {
 764:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #if (C2000_PORT != 0)
 765:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint32_t value = 0;
 766:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t * pBuf8 = (uint8_t *)buf;
 767:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     for(int i = 0; i < 4; i++) {
 768:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         value += ((uint32_t)(pBuf8[i])) << (8 * i);
 769:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     }
 770:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return value;
 771:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #else
 772:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint32_t value; memmove(&value, buf, sizeof(value)); return value;
 773:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
 774:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
 775:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** 
 776:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /**
 777:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * Write uint8_t value into memory buffer
 778:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 779:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param buf Memory buffer.
 780:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @param value Value to be written into buf.
 781:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  *
 782:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  * @return number of bytes written.
 783:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****  */
 784:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint8_t CO_setUint8(void *buf, uint8_t value) {
  72              	 .loc 1 784 0
  73              	 .cfi_startproc
  74              	 
  75              	 
  76              	 
  77 0000 80B4     	 push {r7}
  78              	.LCFI6:
  79              	 .cfi_def_cfa_offset 4
  80              	 .cfi_offset 7,-4
  81 0002 83B0     	 sub sp,sp,#12
  82              	.LCFI7:
  83              	 .cfi_def_cfa_offset 16
  84 0004 00AF     	 add r7,sp,#0
  85              	.LCFI8:
  86              	 .cfi_def_cfa_register 7
  87 0006 7860     	 str r0,[r7,#4]
  88 0008 0B46     	 mov r3,r1
  89 000a FB70     	 strb r3,[r7,#3]
 785:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #if (C2000_PORT != 0)
 786:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t * pBuf8 = (uint8_t *)buf;
 787:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     pBuf8[0] = value;
 788:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return 1;
 789:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #else
 790:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     memmove(buf, &value, sizeof(value)); return sizeof(value);
  90              	 .loc 1 790 0
  91 000c FA78     	 ldrb r2,[r7,#3]
  92 000e 7B68     	 ldr r3,[r7,#4]
  93 0010 1A70     	 strb r2,[r3]
  94 0012 0123     	 movs r3,#1
 791:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
 792:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
  95              	 .loc 1 792 0
  96 0014 1846     	 mov r0,r3
  97 0016 0C37     	 adds r7,r7,#12
  98              	.LCFI9:
  99              	 .cfi_def_cfa_offset 4
 100 0018 BD46     	 mov sp,r7
 101              	.LCFI10:
 102              	 .cfi_def_cfa_register 13
 103              	 
 104 001a 5DF8047B 	 ldr r7,[sp],#4
 105              	.LCFI11:
 106              	 .cfi_restore 7
 107              	 .cfi_def_cfa_offset 0
 108 001e 7047     	 bx lr
 109              	 .cfi_endproc
 110              	.LFE3:
 112              	 .section .text.CO_setUint32,"ax",%progbits
 113              	 .align 2
 114              	 .thumb
 115              	 .thumb_func
 117              	CO_setUint32:
 118              	.LFB5:
 793:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Write uint16_t value into memory buffer, see @ref CO_setUint8 */
 794:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint8_t CO_setUint16(void *buf, uint16_t value) {
 795:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #if (C2000_PORT != 0)
 796:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t * pBuf8 = (uint8_t *)buf;
 797:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     pBuf8[0] = (uint8_t)(value & 0x00FF);
 798:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     pBuf8[1] = (uint8_t)((value >> 8) & 0x00FF);
 799:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return 2;
 800:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #else
 801:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     memmove(buf, &value, sizeof(value)); return sizeof(value);
 802:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
 803:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
 804:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** /** Write uint32_t value into memory buffer, see @ref CO_setUint8 */
 805:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** static inline uint8_t CO_setUint32(void *buf, uint32_t value) {
 119              	 .loc 1 805 0
 120              	 .cfi_startproc
 121              	 
 122              	 
 123 0000 80B5     	 push {r7,lr}
 124              	.LCFI12:
 125              	 .cfi_def_cfa_offset 8
 126              	 .cfi_offset 7,-8
 127              	 .cfi_offset 14,-4
 128 0002 82B0     	 sub sp,sp,#8
 129              	.LCFI13:
 130              	 .cfi_def_cfa_offset 16
 131 0004 00AF     	 add r7,sp,#0
 132              	.LCFI14:
 133              	 .cfi_def_cfa_register 7
 134 0006 7860     	 str r0,[r7,#4]
 135 0008 3960     	 str r1,[r7]
 806:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #if (C2000_PORT != 0)
 807:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     uint8_t * pBuf8 = (uint8_t *)buf;
 808:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     for(int i = 0; i < 4; i++) {
 809:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****         pBuf8[i] = (uint8_t)((value >> (8 * i)) & 0x00FF);
 810:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     }
 811:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     return 4;
 812:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #else
 813:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h ****     memmove(buf, &value, sizeof(value)); return sizeof(value);
 136              	 .loc 1 813 0
 137 000a 3B46     	 mov r3,r7
 138 000c 7868     	 ldr r0,[r7,#4]
 139 000e 1946     	 mov r1,r3
 140 0010 0422     	 movs r2,#4
 141 0012 FFF7FEFF 	 bl memmove
 142 0016 0423     	 movs r3,#4
 814:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** #endif
 815:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_driver.h **** }
 143              	 .loc 1 815 0
 144 0018 1846     	 mov r0,r3
 145 001a 0837     	 adds r7,r7,#8
 146              	.LCFI15:
 147              	 .cfi_def_cfa_offset 8
 148 001c BD46     	 mov sp,r7
 149              	.LCFI16:
 150              	 .cfi_def_cfa_register 13
 151              	 
 152 001e 80BD     	 pop {r7,pc}
 153              	 .cfi_endproc
 154              	.LFE5:
 156              	 .section .text.OD_getIndex,"ax",%progbits
 157              	 .align 2
 158              	 .thumb
 159              	 .thumb_func
 161              	OD_getIndex:
 162              	.LFB6:
 163              	 .file 2 "D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301/CO_ODinterface.h"
   1:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
   2:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * CANopen Object Dictionary interface
   3:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
   4:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @file        CO_ODinterface.h
   5:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ingroup     CO_ODinterface
   6:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @author      Janez Paternoster
   7:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @copyright   2020 Janez Paternoster
   8:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
   9:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * This file is part of CANopenNode, an opensource CANopen Stack.
  10:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Project home page is <https://github.com/CANopenNode/CANopenNode>.
  11:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * For more information on CANopen see <http://www.can-cia.org/>.
  12:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
  13:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Licensed under the Apache License, Version 2.0 (the "License");
  14:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * you may not use this file except in compliance with the License.
  15:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * You may obtain a copy of the License at
  16:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
  17:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *     http://www.apache.org/licenses/LICENSE-2.0
  18:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
  19:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Unless required by applicable law or agreed to in writing, software
  20:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * distributed under the License is distributed on an "AS IS" BASIS,
  21:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  22:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * See the License for the specific language governing permissions and
  23:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * limitations under the License.
  24:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
  25:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  26:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #ifndef CO_OD_INTERFACE_H
  27:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #define CO_OD_INTERFACE_H
  28:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  29:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #include "301/CO_driver.h"
  30:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  31:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #ifdef __cplusplus
  32:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** extern "C" {
  33:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
  34:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  35:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
  36:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @defgroup CO_ODinterface OD interface
  37:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * CANopen Object Dictionary interface.
  38:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
  39:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ingroup CO_CANopen_301
  40:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @{
  41:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * See @ref doc/objectDictionary.md
  42:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
  43:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  44:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #ifndef CO_OD_OWN_TYPES
  45:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Variable of type OD_size_t contains data length in bytes of OD variable */
  46:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef uint32_t OD_size_t;
  47:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Type (and size) of Object Dictionary attribute */
  48:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef uint8_t OD_attr_t;
  49:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
  50:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  51:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #ifndef OD_FLAGS_PDO_SIZE
  52:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Size of of flagsPDO variable inside @ref OD_extension_t, from 0 to 32. */
  53:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #define OD_FLAGS_PDO_SIZE 4
  54:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
  55:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  56:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #ifndef CO_PROGMEM
  57:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Modifier for OD objects. This is large amount of data and is specified in
  58:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Object Dictionary (OD.c file usually) */
  59:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #define CO_PROGMEM const
  60:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
  61:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  62:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
  63:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
  64:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Common DS301 object dictionary entries.
  65:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
  66:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef enum {
  67:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1000_DEV_TYPE           = 0x1000U,/**< Device type */
  68:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1001_ERR_REG            = 0x1001U,/**< Error register */
  69:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1002_MANUF_STATUS_REG   = 0x1002U,/**< Manufacturer status register */
  70:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1003_PREDEF_ERR_FIELD   = 0x1003U,/**< Predefined error field */
  71:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1004_RSV                = 0x1004U,/**< Reserved */
  72:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1005_COBID_SYNC         = 0x1005U,/**< Sync message cob-id */
  73:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1006_COMM_CYCL_PERIOD   = 0x1006U,/**< Communication cycle period */
  74:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1007_SYNC_WINDOW_LEN    = 0x1007U,/**< Sync windows length */
  75:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1008_MANUF_DEV_NAME     = 0x1008U,/**< Manufacturer device name */
  76:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1009_MANUF_HW_VERSION   = 0x1009U,/**< Manufacturer hardware version */
  77:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100A_MANUF_SW_VERSION   = 0x100AU,/**< Manufacturer software version */
  78:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100B_RSV                = 0x100BU,/**< Reserved */
  79:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100C_GUARD_TIME         = 0x100CU,/**< Guard time */
  80:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100D_LIFETIME_FACTOR    = 0x100DU,/**< Life time factor */
  81:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100E_RSV                = 0x100EU,/**< Reserved */
  82:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H100F_RSV                = 0x100FU,/**< Reserved */
  83:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1010_STORE_PARAMETERS   = 0x1010U,/**< Store params in persistent mem.*/
  84:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1011_RESTORE_DEFAULT    = 0x1011U,/**< Restore default parameters */
  85:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1012_COBID_TIME         = 0x1012U,/**< Timestamp message cob-id */
  86:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1013_HIGH_RES_TIMESTAMP = 0x1013U,/**< High resolution timestamp */
  87:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1014_COBID_EMERGENCY    = 0x1014U,/**< Emergency message cob-id */
  88:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1015_INHIBIT_TIME_EMCY  = 0x1015U,/**< Inhibit time emergency message */
  89:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1016_CONSUMER_HB_TIME   = 0x1016U,/**< Consumer heartbeat time */
  90:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1017_PRODUCER_HB_TIME   = 0x1017U,/**< Producer heartbeat time */
  91:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1018_IDENTITY_OBJECT    = 0x1018U,/**< Identity object */
  92:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1019_SYNC_CNT_OVERFLOW  = 0x1019U,/**< Sync counter overflow value */
  93:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1020_VERIFY_CONFIG      = 0x1020U,/**< Verify configuration */
  94:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1021_STORE_EDS          = 0x1021U,/**< Store EDS */
  95:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1022_STORE_FORMAT       = 0x1022U,/**< Store format */
  96:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1023_OS_CMD             = 0x1023U,/**< OS command */
  97:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1024_OS_CMD_MODE        = 0x1024U,/**< OS command mode */
  98:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1025_OS_DBG_INTERFACE   = 0x1025U,/**< OS debug interface */
  99:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1026_OS_PROMPT          = 0x1026U,/**< OS prompt */
 100:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1027_MODULE_LIST        = 0x1027U,/**< Module list */
 101:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1028_EMCY_CONSUMER      = 0x1028U,/**< Emergency consumer object */
 102:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1029_ERR_BEHAVIOR       = 0x1029U,/**< Error behaviour */
 103:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1200_SDO_SERVER_1_PARAM = 0x1200U,/**< SDO server parameter */
 104:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1280_SDO_CLIENT_1_PARAM = 0x1280U,/**< SDO client parameter */
 105:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1300_GFC_PARAM          = 0x1300U,/**< Global fail-safe command param */
 106:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1301_SRDO_1_PARAM       = 0x1301U,/**< SRDO communication parameter */
 107:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1381_SRDO_1_MAPPING     = 0x1381U,/**< SRDO mapping parameter */
 108:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H13FE_SRDO_VALID         = 0x13FEU,/**< SRDO Configuration valid */
 109:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H13FF_SRDO_CHECKSUM      = 0x13FFU,/**< SRDO configuration checksum */
 110:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1400_RXPDO_1_PARAM      = 0x1400U,/**< RXPDO communication parameter */
 111:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1600_RXPDO_1_MAPPING    = 0x1600U,/**< RXPDO mapping parameters */
 112:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1800_TXPDO_1_PARAM      = 0x1800U,/**< TXPDO communication parameter */
 113:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_H1A00_TXPDO_1_MAPPING    = 0x1A00U,/**< TXPDO mapping parameters */
 114:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_ObjDicId_30x_t;
 115:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 116:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 117:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 118:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Attributes (bit masks) for OD sub-object.
 119:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 120:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef enum {
 121:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_SDO_R = 0x01, /**< SDO server may read from the variable */
 122:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_SDO_W = 0x02, /**< SDO server may write to the variable */
 123:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_SDO_RW = 0x03, /**< SDO server may read from or write to the variable */
 124:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_TPDO = 0x04, /**< Variable is mappable into TPDO (can be read) */
 125:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_RPDO = 0x08, /**< Variable is mappable into RPDO (can be written) */
 126:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_TRPDO = 0x0C, /**< Variable is mappable into TPDO or RPDO */
 127:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_TSRDO = 0x10, /**< Variable is mappable into transmitting SRDO */
 128:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_RSRDO = 0x20, /**< Variable is mappable into receiving SRDO */
 129:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_TRSRDO = 0x30, /**< Variable is mappable into tx or rx SRDO */
 130:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_MB = 0x40, /**< Variable is multi-byte ((u)int16_t to (u)int64_t) */
 131:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODA_STR = 0x80 /**< Shorter value, than specified variable size, may be
 132:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     written to the variable. SDO write will fill remaining memory with zeroes.
 133:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     Attribute is used for VISIBLE_STRING and UNICODE_STRING. */
 134:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_attributes_t;
 135:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 136:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 137:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 138:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Return codes from OD access functions.
 139:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 140:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_getSDOabCode() can be used to retrieve corresponding SDO abort code.
 141:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 142:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef enum {
 143:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /* !!!! WARNING !!!!
 144:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * If changing these values, change also OD_getSDOabCode() function!
 145:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 146:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Read/write is only partial, make more calls */
 147:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_PARTIAL = -1,
 148:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x00000000 - Read/write successfully finished */
 149:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_OK = 0,
 150:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x05040005 - Out of memory */
 151:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_OUT_OF_MEM = 1,
 152:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06010000 - Unsupported access to an object */
 153:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_UNSUPP_ACCESS = 2,
 154:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06010001 - Attempt to read a write only object */
 155:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_WRITEONLY = 3,
 156:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06010002 - Attempt to write a read only object */
 157:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_READONLY = 4,
 158:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06020000 - Object does not exist in the object dict. */
 159:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_IDX_NOT_EXIST = 5,
 160:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06040041 - Object cannot be mapped to the PDO */
 161:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_NO_MAP = 6,
 162:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06040042 - PDO length exceeded */
 163:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_MAP_LEN = 7,
 164:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06040043 - General parameter incompatibility reasons */
 165:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_PAR_INCOMPAT = 8,
 166:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06040047 - General internal incompatibility in device */
 167:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DEV_INCOMPAT = 9,
 168:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06060000 - Access failed due to hardware error */
 169:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_HW = 10,
 170:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06070010 - Data type does not match */
 171:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_TYPE_MISMATCH = 11,
 172:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06070012 - Data type does not match, length too high */
 173:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DATA_LONG = 12,
 174:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06070013 - Data type does not match, length too short */
 175:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DATA_SHORT = 13,
 176:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06090011 - Sub index does not exist */
 177:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_SUB_NOT_EXIST = 14,
 178:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06090030 - Invalid value for parameter (download only) */
 179:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_INVALID_VALUE = 15,
 180:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06090031 - Value range of parameter written too high */
 181:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_VALUE_HIGH = 16,
 182:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06090032 - Value range of parameter written too low */
 183:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_VALUE_LOW = 17,
 184:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x06090036 - Maximum value is less than minimum value */
 185:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_MAX_LESS_MIN = 18,
 186:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x060A0023 - Resource not available: SDO connection */
 187:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_NO_RESOURCE = 19,
 188:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000000 - General error */
 189:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_GENERAL = 20,
 190:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000020 - Data cannot be transferred or stored to app */
 191:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DATA_TRANSF = 21,
 192:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000021 - Data can't be transferred (local control) */
 193:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DATA_LOC_CTRL = 22,
 194:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000022 - Data can't be transf. (present device state) */
 195:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_DATA_DEV_STATE = 23,
 196:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000023 - Object dictionary not present */
 197:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_OD_MISSING = 23,
 198:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** SDO abort 0x08000024 - No data available */
 199:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_NO_DATA = 25,
 200:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Last element, number of responses */
 201:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_COUNT = 26
 202:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } ODR_t;
 203:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 204:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 205:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 206:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * IO stream structure, used for read/write access to OD variable, part of
 207:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_IO_t.
 208:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 209:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef struct {
 210:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Pointer to original data object, defined by Object Dictionary. Default
 211:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * read/write functions operate on it. If memory for data object is not
 212:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * specified by Object Dictionary, then dataOrig is NULL.
 213:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      */
 214:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     void *dataOrig;
 215:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Pointer to object, passed by @ref OD_extension_init(). Can be used
 216:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * inside read / write functions from IO extension.
 217:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      */
 218:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     void *object;
 219:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Data length in bytes or 0, if length is not specified */
 220:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_size_t dataLength;
 221:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** In case of large data, dataOffset indicates position of already
 222:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * transferred data */
 223:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_size_t dataOffset;
 224:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Attribute bit-field of the OD sub-object, see @ref OD_attributes_t */
 225:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_attr_t attribute;
 226:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Sub index of the OD sub-object, informative */
 227:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint8_t subIndex;
 228:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_stream_t;
 229:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 230:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 231:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 232:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Structure for input / output on the OD variable. It is initialized with
 233:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_getSub() function. Access principle to OD variable is via read/write
 234:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * functions operating on stream, similar as standard read/write.
 235:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 236:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef struct {
 237:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Object Dictionary stream object, passed to read or write */
 238:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_stream_t stream;
 239:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /**
 240:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Function pointer for reading value from specified variable from Object
 241:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Dictionary. If OD variable is larger than buf, then this function must
 242:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * be called several times. After completed successful read function returns
 243:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * 'ODR_OK'. If read is partial, it returns 'ODR_PARTIAL'. In case of errors
 244:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * function returns code similar to SDO abort code.
 245:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 246:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Read can be restarted with @ref OD_rwRestart() function.
 247:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 248:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * At the moment, when Object Dictionary is initialized, every variable has
 249:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * assigned the same "read" function. This default function simply copies
 250:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * data from Object Dictionary variable. Application can bind its own "read"
 251:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * function for specific object. In that case application is able to
 252:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * calculate data for reading from own internal state at the moment of
 253:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * "read" function call. Own "read" function on OD object can be initialized
 254:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * with @ref OD_extension_init() function.
 255:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 256:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * "read" function must always copy all own data to buf, except if "buf" is
 257:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * not large enough. ("*returnCode" must not return 'ODR_PARTIAL', if there
 258:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * is still space in "buf".)
 259:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 260:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @warning When accessing OD variables by calling the read() function, it
 261:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * may be necessary to use @ref CO_LOCK_OD() and @ref CO_UNLOCK_OD() macros.
 262:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * See @ref CO_critical_sections for more information.
 263:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 264:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param stream Object Dictionary stream object.
 265:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param buf Pointer to external buffer, where to data will be copied.
 266:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param count Size of the external buffer in bytes.
 267:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param [out] countRead If return value is "ODR_OK" or "ODR_PARTIAL",
 268:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * then number of bytes successfully read must be returned here.
 269:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 270:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @return Value from @ref ODR_t, "ODR_OK" in case of success.
 271:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      */
 272:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_t (*read)(OD_stream_t *stream, void *buf,
 273:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                   OD_size_t count, OD_size_t *countRead);
 274:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /**
 275:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Function pointer for writing value into specified variable inside Object
 276:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Dictionary. If OD variable is larger than buf, then this function must
 277:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * be called several times. After completed successful write function
 278:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * returns 'ODR_OK'. If write is partial, it returns 'ODR_PARTIAL'. In case
 279:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * of errors function returns code similar to SDO abort code.
 280:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 281:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Write can be restarted with @ref OD_rwRestart() function.
 282:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 283:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * At the moment, when Object Dictionary is initialized, every variable has
 284:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * assigned the same "write" function, which simply copies data to Object
 285:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * Dictionary variable. Application can bind its own "write" function,
 286:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * similar as it can bind "read" function.
 287:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 288:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * "write" function must always copy all available data from buf. If OD
 289:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * variable expect more data, then "*returnCode" must return 'ODR_PARTIAL'.
 290:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 291:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @warning When accessing OD variables by calling the read() function, it
 292:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * may be necessary to use @ref CO_LOCK_OD() and @ref CO_UNLOCK_OD() macros.
 293:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * See @ref CO_critical_sections for more information.
 294:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 295:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param stream Object Dictionary stream object.
 296:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param buf Pointer to external buffer, from where data will be copied.
 297:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param count Size of the external buffer in bytes.
 298:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @param [out] countWritten If return value is "ODR_OK" or "ODR_PARTIAL",
 299:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * then number of bytes successfully written must be returned here.
 300:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 301:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @return Value from @ref ODR_t, "ODR_OK" in case of success.
 302:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      */
 303:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_t (*write)(OD_stream_t *stream, const void *buf,
 304:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                    OD_size_t count, OD_size_t *countWritten);
 305:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_IO_t;
 306:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 307:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 308:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 309:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Extension of OD object, which can optionally be specified by application in
 310:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * initialization phase with @ref OD_extension_init() function.
 311:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 312:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef struct {
 313:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Object on which read and write will operate, part of @ref OD_stream_t */
 314:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     void *object;
 315:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Application specified read function pointer. If NULL, then read will be
 316:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * disabled. @ref OD_readOriginal can be used here to keep the original read
 317:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * function. For function description see @ref OD_IO_t. */
 318:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_t (*read)(OD_stream_t *stream, void *buf,
 319:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                   OD_size_t count, OD_size_t *countRead);
 320:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Application specified write function pointer. If NULL, then write will
 321:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * be disabled. @ref OD_writeOriginal can be used here to keep the original
 322:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * write function. For function description see @ref OD_IO_t. */
 323:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     ODR_t (*write)(OD_stream_t *stream, const void *buf,
 324:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                    OD_size_t count, OD_size_t *countWritten);
 325:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if OD_FLAGS_PDO_SIZE > 0
 326:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /**PDO flags bit-field provides one bit for each OD variable, which exist
 327:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * inside OD object at specific sub index. If application clears that bit,
 328:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * and OD variable is mapped to an event driven TPDO, then TPDO will be
 329:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * sent.
 330:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      *
 331:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @ref OD_FLAGS_PDO_SIZE can have a value from 0 to 32 bytes, which
 332:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * corresponds to 0 to 256 available bits. If, for example,
 333:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * @ref OD_FLAGS_PDO_SIZE has value 4, then OD variables with sub index up
 334:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * to 31 will have the TPDO requesting functionality.
 335:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * See also @ref OD_requestTPDO and @ref OD_TPDOtransmitted. */
 336:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint8_t flagsPDO[OD_FLAGS_PDO_SIZE];
 337:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 338:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_extension_t;
 339:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 340:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 341:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 342:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Object Dictionary entry for one OD object.
 343:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 344:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * OD entries are collected inside OD_t as array (list). Each OD entry contains
 345:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * basic information about OD object (index and subEntriesCount), pointer to
 346:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * odObject with additional information about var, array or record entry and
 347:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * pointer to extension, configurable by application.
 348:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 349:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef struct {
 350:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Object Dictionary index */
 351:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint16_t index;
 352:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Number of all sub-entries, including sub-entry at sub-index 0 */
 353:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint8_t subEntriesCount;
 354:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Type of the odObject, indicated by @ref OD_objectTypes_t enumerator. */
 355:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint8_t odObjectType;
 356:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** OD object of type indicated by odObjectType, from which @ref OD_getSub()
 357:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****      * fetches the information */
 358:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     CO_PROGMEM void *odObject;
 359:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Extension to OD, specified by application */
 360:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_extension_t *extension;
 361:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_entry_t;
 362:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 363:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 364:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 365:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Object Dictionary
 366:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 367:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** typedef struct {
 368:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** Number of elements in the list, without last element, which is blank */
 369:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     uint16_t size;
 370:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     /** List OD entries (table of contents), ordered by index */
 371:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     OD_entry_t *list;
 372:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** } OD_t;
 373:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 374:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 375:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 376:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Read value from original OD location
 377:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 378:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * This function can be used inside read / write functions, specified by
 379:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_extension_init(). It reads data directly from memory location
 380:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * specified by Object dictionary. If no IO extension is used on OD entry, then
 381:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * io->read returned by @ref OD_getSub() equals to this function. See
 382:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * also @ref OD_IO_t.
 383:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 384:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** ODR_t OD_readOriginal(OD_stream_t *stream, void *buf,
 385:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                       OD_size_t count, OD_size_t *countRead);
 386:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 387:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 388:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 389:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Write value to original OD location
 390:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 391:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * This function can be used inside read / write functions, specified by
 392:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_extension_init(). It writes data directly to memory location
 393:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * specified by Object dictionary. If no IO extension is used on OD entry, then
 394:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * io->write returned by @ref OD_getSub() equals to this function. See
 395:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * also @ref OD_IO_t.
 396:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 397:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** ODR_t OD_writeOriginal(OD_stream_t *stream, const void *buf,
 398:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                        OD_size_t count, OD_size_t *countWritten);
 399:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 400:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 401:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 402:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Find OD entry in Object Dictionary
 403:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 404:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param od Object Dictionary
 405:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param index CANopen Object Dictionary index of object in Object Dictionary
 406:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 407:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return Pointer to OD entry or NULL if not found
 408:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 409:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** OD_entry_t *OD_find(OD_t *od, uint16_t index);
 410:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 411:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 412:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 413:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Find sub-object with specified sub-index on OD entry returned by OD_find.
 414:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Function populates io structure with sub-object data.
 415:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 416:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @warning
 417:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Read and write functions may be called from different threads, so critical
 418:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * sections in custom functions must be observed, see @ref CO_critical_sections.
 419:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 420:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param entry OD entry returned by @ref OD_find().
 421:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param subIndex Sub-index of the variable from the OD object.
 422:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param [out] io Structure will be populated on success.
 423:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param odOrig If true, then potential IO extension on entry will be
 424:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * ignored and access to data entry in the original OD location will be returned
 425:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 426:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return Value from @ref ODR_t, "ODR_OK" in case of success.
 427:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 428:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** ODR_t OD_getSub(const OD_entry_t *entry, uint8_t subIndex,
 429:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                 OD_IO_t *io, bool_t odOrig);
 430:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 431:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 432:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 433:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Return index from OD entry
 434:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 435:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param entry OD entry returned by @ref OD_find().
 436:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 437:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return OD index
 438:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 439:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline uint16_t OD_getIndex(const OD_entry_t *entry) {
 164              	 .loc 2 439 0
 165              	 .cfi_startproc
 166              	 
 167              	 
 168              	 
 169 0000 80B4     	 push {r7}
 170              	.LCFI17:
 171              	 .cfi_def_cfa_offset 4
 172              	 .cfi_offset 7,-4
 173 0002 83B0     	 sub sp,sp,#12
 174              	.LCFI18:
 175              	 .cfi_def_cfa_offset 16
 176 0004 00AF     	 add r7,sp,#0
 177              	.LCFI19:
 178              	 .cfi_def_cfa_register 7
 179 0006 7860     	 str r0,[r7,#4]
 440:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return (entry != NULL) ? entry->index : 0;
 180              	 .loc 2 440 0
 181 0008 7B68     	 ldr r3,[r7,#4]
 182 000a 002B     	 cmp r3,#0
 183 000c 02D0     	 beq .L8
 184              	 .loc 2 440 0 is_stmt 0 discriminator 1
 185 000e 7B68     	 ldr r3,[r7,#4]
 186 0010 1B88     	 ldrh r3,[r3]
 187 0012 00E0     	 b .L9
 188              	.L8:
 189              	 .loc 2 440 0 discriminator 2
 190 0014 0023     	 movs r3,#0
 191              	.L9:
 441:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 192              	 .loc 2 441 0 is_stmt 1 discriminator 4
 193 0016 1846     	 mov r0,r3
 194 0018 0C37     	 adds r7,r7,#12
 195              	.LCFI20:
 196              	 .cfi_def_cfa_offset 4
 197 001a BD46     	 mov sp,r7
 198              	.LCFI21:
 199              	 .cfi_def_cfa_register 13
 200              	 
 201 001c 5DF8047B 	 ldr r7,[sp],#4
 202              	.LCFI22:
 203              	 .cfi_restore 7
 204              	 .cfi_def_cfa_offset 0
 205 0020 7047     	 bx lr
 206              	 .cfi_endproc
 207              	.LFE6:
 209 0022 00BF     	 .section .text.OD_extension_init,"ax",%progbits
 210              	 .align 2
 211              	 .thumb
 212              	 .thumb_func
 214              	OD_extension_init:
 215              	.LFB12:
 442:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 443:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 444:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 445:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Check, if OD variable is mappable to PDO or SRDO.
 446:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 447:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * If OD variable is mappable, then it may be necessary to protect read/write
 448:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * access from mainline function. See @ref CO_critical_sections.
 449:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 450:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param stream Object Dictionary stream object.
 451:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 452:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return true, if OD variable is mappable.
 453:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 454:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline bool_t OD_mappable(OD_stream_t *stream) {
 455:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return (stream != NULL)
 456:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****          ? (stream->attribute & (ODA_TRPDO | ODA_TRSRDO)) != 0 : false;
 457:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 458:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 459:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 460:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 461:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Restart read or write operation on OD variable
 462:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 463:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * It is not necessary to call this function, if stream was initialized by
 464:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_getSub(). It is also not necessary to call this function, if
 465:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * previous read or write was successfully finished.
 466:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 467:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param stream Object Dictionary stream object.
 468:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 469:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline void OD_rwRestart(OD_stream_t *stream) {
 470:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     if (stream != NULL) stream->dataOffset = 0;
 471:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 472:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 473:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 474:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 475:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Get TPDO request flags for OD entry.
 476:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 477:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * flagsPDO can be used for @ref OD_requestTPDO() or @ref OD_TPDOtransmitted().
 478:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 479:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param entry OD entry returned by @ref OD_find().
 480:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 481:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return pointer to flagsPDO
 482:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 483:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline uint8_t *OD_getFlagsPDO(OD_entry_t *entry) {
 484:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if OD_FLAGS_PDO_SIZE > 0
 485:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     if (entry != NULL && entry->extension != NULL) {
 486:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         return &entry->extension->flagsPDO[0];
 487:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     }
 488:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 489:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return 0;
 490:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 491:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 492:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 493:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 494:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Request TPDO, to which OD variable is mapped
 495:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 496:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Function clears the flagPDO bit, which corresponds to OD variable at specific
 497:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * OD index and subindex. For this functionality to work, @ref OD_extension_t
 498:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * must be enabled on OD variable. If OD variable is mapped to any TPDO with
 499:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * event driven transmission, then TPDO will be transmitted after this function
 500:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * call. If OD variable is mapped to more than one TPDO with event driven
 501:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * transmission, only the first matched TPDO will be transmitted.
 502:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 503:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * TPDO event driven transmission is enabled, if TPDO communication parameter,
 504:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * transmission type is set to 0, 254 or 255. For other transmission types
 505:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * (synchronous) flagPDO bit is ignored.
 506:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 507:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param flagsPDO TPDO request flags returned by @ref OD_getFlagsPDO.
 508:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param subIndex subIndex of the OD variable.
 509:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 510:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline void OD_requestTPDO(uint8_t *flagsPDO, uint8_t subIndex) {
 511:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if OD_FLAGS_PDO_SIZE > 0
 512:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     if (flagsPDO != NULL && subIndex < (OD_FLAGS_PDO_SIZE * 8)) {
 513:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         /* clear subIndex-th bit */
 514:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         uint8_t mask = ~(1 << (subIndex & 0x07));
 515:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         flagsPDO[subIndex >> 3] &= mask;
 516:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     }
 517:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 518:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 519:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 520:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 521:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 522:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Check if requested TPDO was transmitted
 523:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 524:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param flagsPDO TPDO request flags returned by @ref OD_getFlagsPDO.
 525:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param subIndex subIndex of the OD variable.
 526:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 527:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return Return true if event driven TPDO with mapping to OD variable,
 528:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * indicated by flagsPDO and subIndex, was transmitted since last
 529:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @ref OD_requestTPDO call. If there was no @ref OD_requestTPDO call yet and
 530:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * TPDO was transmitted by other event, function also returns true.
 531:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 532:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline bool_t OD_TPDOtransmitted(uint8_t *flagsPDO, uint8_t subIndex) {
 533:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if OD_FLAGS_PDO_SIZE > 0
 534:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     if (flagsPDO != NULL && subIndex < (OD_FLAGS_PDO_SIZE * 8)) {
 535:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         /* return true, if subIndex-th bit is set */
 536:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         uint8_t mask = 1 << (subIndex & 0x07);
 537:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         if ((flagsPDO[subIndex >> 3] & mask) != 0) {
 538:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****             return true;
 539:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****         }
 540:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     }
 541:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 542:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return false;
 543:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 544:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 545:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 546:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 547:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Get SDO abort code from returnCode
 548:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 549:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param returnCode Returned from some OD access functions
 550:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 551:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return Corresponding @ref CO_SDO_abortCode_t
 552:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 553:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** uint32_t OD_getSDOabCode(ODR_t returnCode);
 554:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 555:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 556:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 557:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Extend OD object with own read/write functions and/or flagsPDO
 558:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 559:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * This function gives application very powerful tool: definition of own IO
 560:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * access on OD object. Structure and attributes are the same as defined in
 561:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * original OD object, but data are read directly from (or written directly to)
 562:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * application specified object via custom function calls.
 563:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 564:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Before this function specifies extension, OD variables are accessed from
 565:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * original OD location. After this function specifies extension OD variables
 566:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * are accessed from read/write functions specified by extension. (Except when
 567:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * "odOrig" argument to @ref OD_getSub() is set to true.)
 568:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 569:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * This function must also be used, when flagsPDO needs to be enabled for
 570:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * specific entry.
 571:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 572:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @warning
 573:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Object dictionary storage works only directly on OD variables. It does not
 574:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * access read function specified here. So, if extended OD objects needs to be
 575:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * preserved, then @ref OD_writeOriginal can be used inside custom write
 576:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * function.
 577:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 578:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @warning
 579:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Read and write functions may be called from different threads, so critical
 580:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * sections in custom functions must be observed, see @ref CO_critical_sections.
 581:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 582:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param entry OD entry returned by @ref OD_find().
 583:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param extension Extension object, which must be initialized externally.
 584:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Extension object must exist permanently. If NULL, extension will be removed.
 585:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 586:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return "ODR_OK" on success, "ODR_IDX_NOT_EXIST" if OD object doesn't exist.
 587:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 588:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_extension_init(OD_entry_t *entry,
 589:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                       OD_extension_t *extension)
 590:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 216              	 .loc 2 590 0
 217              	 .cfi_startproc
 218              	 
 219              	 
 220              	 
 221 0000 80B4     	 push {r7}
 222              	.LCFI23:
 223              	 .cfi_def_cfa_offset 4
 224              	 .cfi_offset 7,-4
 225 0002 83B0     	 sub sp,sp,#12
 226              	.LCFI24:
 227              	 .cfi_def_cfa_offset 16
 228 0004 00AF     	 add r7,sp,#0
 229              	.LCFI25:
 230              	 .cfi_def_cfa_register 7
 231 0006 7860     	 str r0,[r7,#4]
 232 0008 3960     	 str r1,[r7]
 591:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     if (entry == NULL) return ODR_IDX_NOT_EXIST;
 233              	 .loc 2 591 0
 234 000a 7B68     	 ldr r3,[r7,#4]
 235 000c 002B     	 cmp r3,#0
 236 000e 01D1     	 bne .L12
 237              	 .loc 2 591 0 is_stmt 0 discriminator 1
 238 0010 0523     	 movs r3,#5
 239 0012 03E0     	 b .L13
 240              	.L12:
 592:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     entry->extension = extension;
 241              	 .loc 2 592 0 is_stmt 1
 242 0014 7B68     	 ldr r3,[r7,#4]
 243 0016 3A68     	 ldr r2,[r7]
 244 0018 9A60     	 str r2,[r3,#8]
 593:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return ODR_OK;
 245              	 .loc 2 593 0
 246 001a 0023     	 movs r3,#0
 247              	.L13:
 248 001c 5BB2     	 sxtb r3,r3
 594:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 249              	 .loc 2 594 0
 250 001e 1846     	 mov r0,r3
 251 0020 0C37     	 adds r7,r7,#12
 252              	.LCFI26:
 253              	 .cfi_def_cfa_offset 4
 254 0022 BD46     	 mov sp,r7
 255              	.LCFI27:
 256              	 .cfi_def_cfa_register 13
 257              	 
 258 0024 5DF8047B 	 ldr r7,[sp],#4
 259              	.LCFI28:
 260              	 .cfi_restore 7
 261              	 .cfi_def_cfa_offset 0
 262 0028 7047     	 bx lr
 263              	 .cfi_endproc
 264              	.LFE12:
 266 002a 00BF     	 .section .text.OD_get_u32,"ax",%progbits
 267              	 .align 2
 268              	 .thumb
 269              	 .thumb_func
 271              	OD_get_u32:
 272              	.LFB19:
 595:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 596:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 597:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 598:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @defgroup CO_ODgetSetters Getters and setters
 599:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @{
 600:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 601:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Getter and setter helper functions for accessing different types of Object
 602:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Dictionary variables.
 603:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 604:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /**
 605:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * Get variable from Object Dictionary
 606:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 607:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param entry OD entry returned by @ref OD_find().
 608:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param subIndex Sub-index of the variable from the OD object.
 609:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param [out] val Value will be written here.
 610:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param len Size of value to retrieve from OD.
 611:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @param odOrig If true, then potential IO extension on entry will be
 612:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * ignored and data in the original OD location will be returned.
 613:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  *
 614:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * @return Value from @ref ODR_t, "ODR_OK" in case of success. Error, if
 615:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * variable does not exist in object dictionary or it does not have the correct
 616:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  * length or other reason.
 617:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****  */
 618:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** ODR_t OD_get_value(const OD_entry_t *entry, uint8_t subIndex,
 619:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                    void *val, OD_size_t len, bool_t odOrig);
 620:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 621:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get int8_t variable from Object Dictionary, see @ref OD_get_value */
 622:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_i8(const OD_entry_t *entry, uint8_t subIndex,
 623:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                               int8_t *val, bool_t odOrig)
 624:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 625:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 626:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 1, odOrig);
 627:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 628:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 629:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 630:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 631:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 632:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get int16_t variable from Object Dictionary, see @ref OD_get_value */
 633:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_i16(const OD_entry_t *entry, uint8_t subIndex,
 634:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                int16_t *val, bool_t odOrig)
 635:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 636:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 637:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 2, odOrig);
 638:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 639:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 640:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 641:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 642:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 643:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get int32_t variable from Object Dictionary, see @ref OD_get_value */
 644:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_i32(const OD_entry_t *entry, uint8_t subIndex,
 645:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                int32_t *val, bool_t odOrig)
 646:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 647:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 648:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 4, odOrig);
 649:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 650:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 651:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 652:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 653:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 654:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get int64_t variable from Object Dictionary, see @ref OD_get_value */
 655:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_i64(const OD_entry_t *entry, uint8_t subIndex,
 656:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                int64_t *val, bool_t odOrig)
 657:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 658:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 659:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 8, odOrig);
 660:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 661:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 662:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 663:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 664:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 665:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get uint8_t variable from Object Dictionary, see @ref OD_get_value */
 666:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_u8(const OD_entry_t *entry, uint8_t subIndex,
 667:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                               uint8_t *val, bool_t odOrig)
 668:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 669:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 670:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 1, odOrig);
 671:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 672:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 673:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 674:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 675:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 676:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get uint16_t variable from Object Dictionary, see @ref OD_get_value */
 677:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_u16(const OD_entry_t *entry, uint8_t subIndex,
 678:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                uint16_t *val, bool_t odOrig)
 679:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 680:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 681:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 2, odOrig);
 682:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 683:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 684:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 685:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 686:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** 
 687:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** /** Get uint32_t variable from Object Dictionary, see @ref OD_get_value */
 688:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** static inline ODR_t OD_get_u32(const OD_entry_t *entry, uint8_t subIndex,
 689:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****                                uint32_t *val, bool_t odOrig)
 690:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** {
 273              	 .loc 2 690 0
 274              	 .cfi_startproc
 275              	 
 276              	 
 277 0000 80B5     	 push {r7,lr}
 278              	.LCFI29:
 279              	 .cfi_def_cfa_offset 8
 280              	 .cfi_offset 7,-8
 281              	 .cfi_offset 14,-4
 282 0002 86B0     	 sub sp,sp,#24
 283              	.LCFI30:
 284              	 .cfi_def_cfa_offset 32
 285 0004 02AF     	 add r7,sp,#8
 286              	.LCFI31:
 287              	 .cfi_def_cfa 7,24
 288 0006 F860     	 str r0,[r7,#12]
 289 0008 7A60     	 str r2,[r7,#4]
 290 000a 3B60     	 str r3,[r7]
 291 000c 0B46     	 mov r3,r1
 292 000e FB72     	 strb r3,[r7,#11]
 691:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #if C2000_PORT != 0
 692:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, 4, odOrig);
 693:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #else
 694:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h ****     return OD_get_value(entry, subIndex, val, sizeof(*val), odOrig);
 293              	 .loc 2 694 0
 294 0010 FA7A     	 ldrb r2,[r7,#11]
 295 0012 3B68     	 ldr r3,[r7]
 296 0014 0093     	 str r3,[sp]
 297 0016 F868     	 ldr r0,[r7,#12]
 298 0018 1146     	 mov r1,r2
 299 001a 7A68     	 ldr r2,[r7,#4]
 300 001c 0423     	 movs r3,#4
 301 001e FFF7FEFF 	 bl OD_get_value
 302 0022 0346     	 mov r3,r0
 695:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** #endif
 696:D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301\CO_ODinterface.h **** }
 303              	 .loc 2 696 0
 304 0024 1846     	 mov r0,r3
 305 0026 1037     	 adds r7,r7,#16
 306              	.LCFI32:
 307              	 .cfi_def_cfa_offset 8
 308 0028 BD46     	 mov sp,r7
 309              	.LCFI33:
 310              	 .cfi_def_cfa_register 13
 311              	 
 312 002a 80BD     	 pop {r7,pc}
 313              	 .cfi_endproc
 314              	.LFE19:
 316              	 .section .text.OD_read_1014_default,"ax",%progbits
 317              	 .align 2
 318              	 .thumb
 319              	 .thumb_func
 321              	OD_read_1014_default:
 322              	.LFB35:
 323              	 .file 3 "../CANopen/stack/301/CO_Emergency.c"
   1:../CANopen/stack/301/CO_Emergency.c **** /*
   2:../CANopen/stack/301/CO_Emergency.c ****  * CANopen Emergency object.
   3:../CANopen/stack/301/CO_Emergency.c ****  *
   4:../CANopen/stack/301/CO_Emergency.c ****  * @file        CO_Emergency.c
   5:../CANopen/stack/301/CO_Emergency.c ****  * @ingroup     CO_Emergency
   6:../CANopen/stack/301/CO_Emergency.c ****  * @author      Janez Paternoster
   7:../CANopen/stack/301/CO_Emergency.c ****  * @copyright   2020 Janez Paternoster
   8:../CANopen/stack/301/CO_Emergency.c ****  *
   9:../CANopen/stack/301/CO_Emergency.c ****  * This file is part of CANopenNode, an opensource CANopen Stack.
  10:../CANopen/stack/301/CO_Emergency.c ****  * Project home page is <https://github.com/CANopenNode/CANopenNode>.
  11:../CANopen/stack/301/CO_Emergency.c ****  * For more information on CANopen see <http://www.can-cia.org/>.
  12:../CANopen/stack/301/CO_Emergency.c ****  *
  13:../CANopen/stack/301/CO_Emergency.c ****  * Licensed under the Apache License, Version 2.0 (the "License");
  14:../CANopen/stack/301/CO_Emergency.c ****  * you may not use this file except in compliance with the License.
  15:../CANopen/stack/301/CO_Emergency.c ****  * You may obtain a copy of the License at
  16:../CANopen/stack/301/CO_Emergency.c ****  *
  17:../CANopen/stack/301/CO_Emergency.c ****  *     http://www.apache.org/licenses/LICENSE-2.0
  18:../CANopen/stack/301/CO_Emergency.c ****  *
  19:../CANopen/stack/301/CO_Emergency.c ****  * Unless required by applicable law or agreed to in writing, software
  20:../CANopen/stack/301/CO_Emergency.c ****  * distributed under the License is distributed on an "AS IS" BASIS,
  21:../CANopen/stack/301/CO_Emergency.c ****  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  22:../CANopen/stack/301/CO_Emergency.c ****  * See the License for the specific language governing permissions and
  23:../CANopen/stack/301/CO_Emergency.c ****  * limitations under the License.
  24:../CANopen/stack/301/CO_Emergency.c ****  */
  25:../CANopen/stack/301/CO_Emergency.c **** 
  26:../CANopen/stack/301/CO_Emergency.c **** #include <string.h>
  27:../CANopen/stack/301/CO_Emergency.c **** 
  28:../CANopen/stack/301/CO_Emergency.c **** #include "301/CO_Emergency.h"
  29:../CANopen/stack/301/CO_Emergency.c **** 
  30:../CANopen/stack/301/CO_Emergency.c **** /* verify configuration */
  31:../CANopen/stack/301/CO_Emergency.c **** #if CO_CONFIG_EM_ERR_STATUS_BITS_COUNT < (6*8) \
  32:../CANopen/stack/301/CO_Emergency.c ****     || CO_CONFIG_EM_ERR_STATUS_BITS_COUNT > 256 \
  33:../CANopen/stack/301/CO_Emergency.c ****     || (CO_CONFIG_EM_ERR_STATUS_BITS_COUNT % 8) != 0
  34:../CANopen/stack/301/CO_Emergency.c ****  #error CO_CONFIG_EM_ERR_STATUS_BITS_COUNT is not correct
  35:../CANopen/stack/301/CO_Emergency.c **** #endif
  36:../CANopen/stack/301/CO_Emergency.c **** 
  37:../CANopen/stack/301/CO_Emergency.c **** /* fifo buffer example for fifoSize = 7 (actual capacity = 6)                 *
  38:../CANopen/stack/301/CO_Emergency.c ****  *                                                                            *
  39:../CANopen/stack/301/CO_Emergency.c ****  *   0      *            *             *            *                         *
  40:../CANopen/stack/301/CO_Emergency.c ****  *   1    pp==wp     fifoPpPtr     fifoWrPtr        *                         *
  41:../CANopen/stack/301/CO_Emergency.c ****  *   2      *            *             *            *                         *
  42:../CANopen/stack/301/CO_Emergency.c ****  *   3      *            *             *        fifoWrPtr                     *
  43:../CANopen/stack/301/CO_Emergency.c ****  *   4      *        fifoWrPtr     fifoPpPtr    fifoPpPtr                     *
  44:../CANopen/stack/301/CO_Emergency.c ****  *   5      *            *             *            *                         *
  45:../CANopen/stack/301/CO_Emergency.c ****  *   6      *            *             *            *                         *
  46:../CANopen/stack/301/CO_Emergency.c ****  *                                                                            *
  47:../CANopen/stack/301/CO_Emergency.c ****  *       nothing      3 bytes       4 bytes       buffer                      *
  48:../CANopen/stack/301/CO_Emergency.c ****  *     to process   to process    to process      full                        *
  49:../CANopen/stack/301/CO_Emergency.c ****  ******************************************************************************/
  50:../CANopen/stack/301/CO_Emergency.c **** 
  51:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_PRODUCER
  52:../CANopen/stack/301/CO_Emergency.c ****  #if (CO_CONFIG_EM) & CO_CONFIG_EM_PROD_CONFIGURABLE
  53:../CANopen/stack/301/CO_Emergency.c **** /*
  54:../CANopen/stack/301/CO_Emergency.c ****  * Custom functions for read/write OD object "COB-ID EMCY"
  55:../CANopen/stack/301/CO_Emergency.c ****  *
  56:../CANopen/stack/301/CO_Emergency.c ****  * For more information see file CO_ODinterface.h, OD_IO_t.
  57:../CANopen/stack/301/CO_Emergency.c ****  */
  58:../CANopen/stack/301/CO_Emergency.c **** static ODR_t OD_read_1014(OD_stream_t *stream, void *buf,
  59:../CANopen/stack/301/CO_Emergency.c ****                           OD_size_t count, OD_size_t *countRead)
  60:../CANopen/stack/301/CO_Emergency.c **** {
  61:../CANopen/stack/301/CO_Emergency.c ****     if (stream == NULL || stream->subIndex != 0 || buf == NULL
  62:../CANopen/stack/301/CO_Emergency.c **** #if (C2000_PORT != 0)
  63:../CANopen/stack/301/CO_Emergency.c ****         || count < 4 || countRead == NULL
  64:../CANopen/stack/301/CO_Emergency.c **** #else
  65:../CANopen/stack/301/CO_Emergency.c ****         || count < sizeof(uint32_t) || countRead == NULL
  66:../CANopen/stack/301/CO_Emergency.c **** #endif
  67:../CANopen/stack/301/CO_Emergency.c ****     ) {
  68:../CANopen/stack/301/CO_Emergency.c ****         return ODR_DEV_INCOMPAT;
  69:../CANopen/stack/301/CO_Emergency.c ****     }
  70:../CANopen/stack/301/CO_Emergency.c **** 
  71:../CANopen/stack/301/CO_Emergency.c ****     CO_EM_t *em = (CO_EM_t *)stream->object;
  72:../CANopen/stack/301/CO_Emergency.c **** 
  73:../CANopen/stack/301/CO_Emergency.c ****     uint16_t canId = em->producerCanId == CO_CAN_ID_EMERGENCY ?
  74:../CANopen/stack/301/CO_Emergency.c ****                      CO_CAN_ID_EMERGENCY + em->nodeId : em->producerCanId;
  75:../CANopen/stack/301/CO_Emergency.c ****     uint32_t COB_IDEmergency32 = em->producerEnabled ? 0 : 0x80000000;
  76:../CANopen/stack/301/CO_Emergency.c ****     COB_IDEmergency32 |= canId;
  77:../CANopen/stack/301/CO_Emergency.c ****     CO_setUint32(buf, COB_IDEmergency32);
  78:../CANopen/stack/301/CO_Emergency.c **** 
  79:../CANopen/stack/301/CO_Emergency.c **** #if (C2000_PORT != 0)
  80:../CANopen/stack/301/CO_Emergency.c ****     *countRead = 4;
  81:../CANopen/stack/301/CO_Emergency.c **** #else
  82:../CANopen/stack/301/CO_Emergency.c ****     *countRead = sizeof(uint32_t);
  83:../CANopen/stack/301/CO_Emergency.c **** #endif
  84:../CANopen/stack/301/CO_Emergency.c ****     return ODR_OK;
  85:../CANopen/stack/301/CO_Emergency.c **** }
  86:../CANopen/stack/301/CO_Emergency.c **** 
  87:../CANopen/stack/301/CO_Emergency.c **** static ODR_t OD_write_1014(OD_stream_t *stream, const void *buf,
  88:../CANopen/stack/301/CO_Emergency.c ****                            OD_size_t count, OD_size_t *countWritten)
  89:../CANopen/stack/301/CO_Emergency.c **** {
  90:../CANopen/stack/301/CO_Emergency.c ****     if (stream == NULL || stream->subIndex != 0 || buf == NULL
  91:../CANopen/stack/301/CO_Emergency.c **** #if (C2000_PORT != 0)
  92:../CANopen/stack/301/CO_Emergency.c ****         || count != 4 || countRead == NULL
  93:../CANopen/stack/301/CO_Emergency.c **** #else
  94:../CANopen/stack/301/CO_Emergency.c ****         || count != sizeof(uint32_t) || countWritten == NULL
  95:../CANopen/stack/301/CO_Emergency.c **** #endif
  96:../CANopen/stack/301/CO_Emergency.c ****     ) {
  97:../CANopen/stack/301/CO_Emergency.c ****         return ODR_DEV_INCOMPAT;
  98:../CANopen/stack/301/CO_Emergency.c ****     }
  99:../CANopen/stack/301/CO_Emergency.c **** 
 100:../CANopen/stack/301/CO_Emergency.c ****     CO_EM_t *em = (CO_EM_t *)stream->object;
 101:../CANopen/stack/301/CO_Emergency.c **** 
 102:../CANopen/stack/301/CO_Emergency.c ****     /* Verify written value. COB ID must not change, if emergency is enabled */
 103:../CANopen/stack/301/CO_Emergency.c ****     uint32_t COB_IDEmergency32 = CO_getUint32(buf);
 104:../CANopen/stack/301/CO_Emergency.c ****     uint16_t newCanId = (uint16_t)(COB_IDEmergency32 & 0x7FF);
 105:../CANopen/stack/301/CO_Emergency.c ****     uint16_t curCanId = em->producerCanId == CO_CAN_ID_EMERGENCY ?
 106:../CANopen/stack/301/CO_Emergency.c ****                         CO_CAN_ID_EMERGENCY + em->nodeId : em->producerCanId;
 107:../CANopen/stack/301/CO_Emergency.c ****     bool_t newEnabled = (COB_IDEmergency32 & 0x80000000) == 0 && newCanId != 0;
 108:../CANopen/stack/301/CO_Emergency.c ****     if ((COB_IDEmergency32 & 0x7FFFF800)!=0 || CO_IS_RESTRICTED_CAN_ID(newCanId)
 109:../CANopen/stack/301/CO_Emergency.c ****         || (em->producerEnabled && newEnabled && newCanId != curCanId)
 110:../CANopen/stack/301/CO_Emergency.c ****     ) {
 111:../CANopen/stack/301/CO_Emergency.c ****         return ODR_INVALID_VALUE;
 112:../CANopen/stack/301/CO_Emergency.c ****     }
 113:../CANopen/stack/301/CO_Emergency.c **** 
 114:../CANopen/stack/301/CO_Emergency.c ****     /* store values. If default CAN-ID is used, then store only value of
 115:../CANopen/stack/301/CO_Emergency.c ****      * CO_CAN_ID_EMERGENCY without node id. */
 116:../CANopen/stack/301/CO_Emergency.c ****     em->producerEnabled = newEnabled;
 117:../CANopen/stack/301/CO_Emergency.c ****     em->producerCanId = newCanId == (CO_CAN_ID_EMERGENCY + em->nodeId) ?
 118:../CANopen/stack/301/CO_Emergency.c ****                         CO_CAN_ID_EMERGENCY : newCanId;
 119:../CANopen/stack/301/CO_Emergency.c **** 
 120:../CANopen/stack/301/CO_Emergency.c ****     /* configure emergency message CAN transmission */
 121:../CANopen/stack/301/CO_Emergency.c ****     if (newEnabled) {
 122:../CANopen/stack/301/CO_Emergency.c ****         em->CANtxBuff = CO_CANtxBufferInit(
 123:../CANopen/stack/301/CO_Emergency.c ****             em->CANdevTx,       /* CAN device */
 124:../CANopen/stack/301/CO_Emergency.c ****             em->CANdevTxIdx,    /* index of specific buffer inside CAN module */
 125:../CANopen/stack/301/CO_Emergency.c ****             newCanId,           /* CAN identifier */
 126:../CANopen/stack/301/CO_Emergency.c ****             0,                  /* rtr */
 127:../CANopen/stack/301/CO_Emergency.c ****             8U,                 /* number of data bytes */
 128:../CANopen/stack/301/CO_Emergency.c ****             0);                 /* synchronous message flag bit */
 129:../CANopen/stack/301/CO_Emergency.c ****     }
 130:../CANopen/stack/301/CO_Emergency.c **** 
 131:../CANopen/stack/301/CO_Emergency.c ****     /* write value to the original location in the Object Dictionary */
 132:../CANopen/stack/301/CO_Emergency.c **** #if (C2000_PORT != 0)
 133:../CANopen/stack/301/CO_Emergency.c ****     uint32_t value = CO_getUint32(buf);
 134:../CANopen/stack/301/CO_Emergency.c ****     return OD_writeOriginal(stream, &value, count, countWritten);
 135:../CANopen/stack/301/CO_Emergency.c **** #else
 136:../CANopen/stack/301/CO_Emergency.c ****     return OD_writeOriginal(stream, buf, count, countWritten);
 137:../CANopen/stack/301/CO_Emergency.c **** #endif
 138:../CANopen/stack/301/CO_Emergency.c **** }
 139:../CANopen/stack/301/CO_Emergency.c ****  #else
 140:../CANopen/stack/301/CO_Emergency.c **** /*
 141:../CANopen/stack/301/CO_Emergency.c ****  * Custom functions for read/write OD object "COB-ID EMCY"
 142:../CANopen/stack/301/CO_Emergency.c ****  *
 143:../CANopen/stack/301/CO_Emergency.c ****  * For more information see file CO_ODinterface.h, OD_IO_t.
 144:../CANopen/stack/301/CO_Emergency.c ****  */
 145:../CANopen/stack/301/CO_Emergency.c **** static ODR_t OD_read_1014_default(OD_stream_t *stream, void *buf,
 146:../CANopen/stack/301/CO_Emergency.c ****                                   OD_size_t count, OD_size_t *countRead)
 147:../CANopen/stack/301/CO_Emergency.c **** {
 324              	 .loc 3 147 0
 325              	 .cfi_startproc
 326              	 
 327              	 
 328 0000 80B5     	 push {r7,lr}
 329              	.LCFI34:
 330              	 .cfi_def_cfa_offset 8
 331              	 .cfi_offset 7,-8
 332              	 .cfi_offset 14,-4
 333 0002 86B0     	 sub sp,sp,#24
 334              	.LCFI35:
 335              	 .cfi_def_cfa_offset 32
 336 0004 00AF     	 add r7,sp,#0
 337              	.LCFI36:
 338              	 .cfi_def_cfa_register 7
 339 0006 F860     	 str r0,[r7,#12]
 340 0008 B960     	 str r1,[r7,#8]
 341 000a 7A60     	 str r2,[r7,#4]
 342 000c 3B60     	 str r3,[r7]
 148:../CANopen/stack/301/CO_Emergency.c ****     if (stream == NULL || stream->subIndex != 0 || buf == NULL
 343              	 .loc 3 148 0
 344 000e FB68     	 ldr r3,[r7,#12]
 345 0010 002B     	 cmp r3,#0
 346 0012 0CD0     	 beq .L17
 347              	 .loc 3 148 0 is_stmt 0 discriminator 1
 348 0014 FB68     	 ldr r3,[r7,#12]
 349 0016 5B7C     	 ldrb r3,[r3,#17]
 350 0018 002B     	 cmp r3,#0
 351 001a 08D1     	 bne .L17
 352              	 .loc 3 148 0 discriminator 2
 353 001c BB68     	 ldr r3,[r7,#8]
 354 001e 002B     	 cmp r3,#0
 355 0020 05D0     	 beq .L17
 149:../CANopen/stack/301/CO_Emergency.c **** #if (C2000_PORT != 0)
 150:../CANopen/stack/301/CO_Emergency.c ****         || count < 4 || countRead == NULL
 151:../CANopen/stack/301/CO_Emergency.c **** #else
 152:../CANopen/stack/301/CO_Emergency.c ****         || count < sizeof(uint32_t) || countRead == NULL
 356              	 .loc 3 152 0 is_stmt 1
 357 0022 7B68     	 ldr r3,[r7,#4]
 358 0024 032B     	 cmp r3,#3
 359 0026 02D9     	 bls .L17
 360              	 .loc 3 152 0 is_stmt 0 discriminator 1
 361 0028 3B68     	 ldr r3,[r7]
 362 002a 002B     	 cmp r3,#0
 363 002c 01D1     	 bne .L18
 364              	.L17:
 153:../CANopen/stack/301/CO_Emergency.c **** #endif
 154:../CANopen/stack/301/CO_Emergency.c ****     ) {
 155:../CANopen/stack/301/CO_Emergency.c ****         return ODR_DEV_INCOMPAT;
 365              	 .loc 3 155 0 is_stmt 1
 366 002e 0923     	 movs r3,#9
 367 0030 1BE0     	 b .L19
 368              	.L18:
 156:../CANopen/stack/301/CO_Emergency.c ****     }
 157:../CANopen/stack/301/CO_Emergency.c **** 
 158:../CANopen/stack/301/CO_Emergency.c ****     CO_EM_t *em = (CO_EM_t *)stream->object;
 369              	 .loc 3 158 0
 370 0032 FB68     	 ldr r3,[r7,#12]
 371 0034 5B68     	 ldr r3,[r3,#4]
 372 0036 7B61     	 str r3,[r7,#20]
 159:../CANopen/stack/301/CO_Emergency.c **** 
 160:../CANopen/stack/301/CO_Emergency.c ****     uint32_t COB_IDEmergency32 = em->producerEnabled ? 0 : 0x80000000;
 373              	 .loc 3 160 0
 374 0038 7B69     	 ldr r3,[r7,#20]
 375 003a 5B6A     	 ldr r3,[r3,#36]
 376 003c 002B     	 cmp r3,#0
 377 003e 01D0     	 beq .L20
 378              	 .loc 3 160 0 is_stmt 0 discriminator 1
 379 0040 0023     	 movs r3,#0
 380 0042 01E0     	 b .L21
 381              	.L20:
 382              	 .loc 3 160 0 discriminator 2
 383 0044 4FF00043 	 mov r3,#-2147483648
 384              	.L21:
 385              	 .loc 3 160 0 discriminator 4
 386 0048 3B61     	 str r3,[r7,#16]
 161:../CANopen/stack/301/CO_Emergency.c ****     COB_IDEmergency32 |= CO_CAN_ID_EMERGENCY + em->nodeId;
 387              	 .loc 3 161 0 is_stmt 1 discriminator 4
 388 004a 7B69     	 ldr r3,[r7,#20]
 389 004c 93F82830 	 ldrb r3,[r3,#40]
 390 0050 8033     	 adds r3,r3,#128
 391 0052 1A46     	 mov r2,r3
 392 0054 3B69     	 ldr r3,[r7,#16]
 393 0056 1343     	 orrs r3,r3,r2
 394 0058 3B61     	 str r3,[r7,#16]
 162:../CANopen/stack/301/CO_Emergency.c ****     CO_setUint32(buf, COB_IDEmergency32);
 395              	 .loc 3 162 0 discriminator 4
 396 005a B868     	 ldr r0,[r7,#8]
 397 005c 3969     	 ldr r1,[r7,#16]
 398 005e FFF7FEFF 	 bl CO_setUint32
 163:../CANopen/stack/301/CO_Emergency.c **** 
 164:../CANopen/stack/301/CO_Emergency.c **** #if (C2000_PORT != 0)
 165:../CANopen/stack/301/CO_Emergency.c ****     *countRead = 4;
 166:../CANopen/stack/301/CO_Emergency.c **** #else
 167:../CANopen/stack/301/CO_Emergency.c ****     *countRead = sizeof(uint32_t);
 399              	 .loc 3 167 0 discriminator 4
 400 0062 3B68     	 ldr r3,[r7]
 401 0064 0422     	 movs r2,#4
 402 0066 1A60     	 str r2,[r3]
 168:../CANopen/stack/301/CO_Emergency.c **** #endif
 169:../CANopen/stack/301/CO_Emergency.c ****     return ODR_OK;
 403              	 .loc 3 169 0 discriminator 4
 404 0068 0023     	 movs r3,#0
 405              	.L19:
 406 006a 5BB2     	 sxtb r3,r3
 170:../CANopen/stack/301/CO_Emergency.c **** }
 407              	 .loc 3 170 0
 408 006c 1846     	 mov r0,r3
 409 006e 1837     	 adds r7,r7,#24
 410              	.LCFI37:
 411              	 .cfi_def_cfa_offset 8
 412 0070 BD46     	 mov sp,r7
 413              	.LCFI38:
 414              	 .cfi_def_cfa_register 13
 415              	 
 416 0072 80BD     	 pop {r7,pc}
 417              	 .cfi_endproc
 418              	.LFE35:
 420              	 .section .text.OD_read_1003,"ax",%progbits
 421              	 .align 2
 422              	 .thumb
 423              	 .thumb_func
 425              	OD_read_1003:
 426              	.LFB36:
 171:../CANopen/stack/301/CO_Emergency.c ****  #endif /* (CO_CONFIG_EM) & CO_CONFIG_EM_PROD_CONFIGURABLE */
 172:../CANopen/stack/301/CO_Emergency.c **** 
 173:../CANopen/stack/301/CO_Emergency.c ****  #if (CO_CONFIG_EM) & CO_CONFIG_EM_PROD_INHIBIT
 174:../CANopen/stack/301/CO_Emergency.c **** /*
 175:../CANopen/stack/301/CO_Emergency.c ****  * Custom function for writing OD object "Inhibit time EMCY"
 176:../CANopen/stack/301/CO_Emergency.c ****  *
 177:../CANopen/stack/301/CO_Emergency.c ****  * For more information see file CO_ODinterface.h, OD_IO_t.
 178:../CANopen/stack/301/CO_Emergency.c ****  */
 179:../CANopen/stack/301/CO_Emergency.c **** static ODR_t OD_write_1015(OD_stream_t *stream, const void *buf,
 180:../CANopen/stack/301/CO_Emergency.c ****                            OD_size_t count, OD_size_t *countWritten)
 181:../CANopen/stack/301/CO_Emergency.c **** {
 182:../CANopen/stack/301/CO_Emergency.c ****     if (stream == NULL || stream->subIndex != 0 || buf == NULL
 183:../CANopen/stack/301/CO_Emergency.c **** #if (C2000_PORT != 0)
 184:../CANopen/stack/301/CO_Emergency.c ****         || count != 2 || countWritten == NULL
 185:../CANopen/stack/301/CO_Emergency.c **** #else
 186:../CANopen/stack/301/CO_Emergency.c ****         || count != sizeof(uint16_t) || countWritten == NULL
 187:../CANopen/stack/301/CO_Emergency.c **** #endif
 188:../CANopen/stack/301/CO_Emergency.c ****     ) {
 189:../CANopen/stack/301/CO_Emergency.c ****         return ODR_DEV_INCOMPAT;
 190:../CANopen/stack/301/CO_Emergency.c ****     }
 191:../CANopen/stack/301/CO_Emergency.c **** 
 192:../CANopen/stack/301/CO_Emergency.c ****     CO_EM_t *em = (CO_EM_t *)stream->object;
 193:../CANopen/stack/301/CO_Emergency.c **** 
 194:../CANopen/stack/301/CO_Emergency.c ****     /* update object */
 195:../CANopen/stack/301/CO_Emergency.c ****     em->inhibitEmTime_us = (uint32_t)CO_getUint16(buf) * 100;
 196:../CANopen/stack/301/CO_Emergency.c ****     em->inhibitEmTimer = 0;
 197:../CANopen/stack/301/CO_Emergency.c **** 
 198:../CANopen/stack/301/CO_Emergency.c ****     /* write value to the original location in the Object Dictionary */
 199:../CANopen/stack/301/CO_Emergency.c **** #if (C2000_PORT != 0)
 200:../CANopen/stack/301/CO_Emergency.c ****     uint16_t value  = CO_getUint16(buf);
 201:../CANopen/stack/301/CO_Emergency.c ****     return OD_writeOriginal(stream, &value, count, countWritten);
 202:../CANopen/stack/301/CO_Emergency.c **** #else
 203:../CANopen/stack/301/CO_Emergency.c ****     return OD_writeOriginal(stream, buf, count, countWritten);
 204:../CANopen/stack/301/CO_Emergency.c **** #endif
 205:../CANopen/stack/301/CO_Emergency.c **** }
 206:../CANopen/stack/301/CO_Emergency.c ****  #endif /* (CO_CONFIG_EM) & CO_CONFIG_EM_PROD_INHIBIT */
 207:../CANopen/stack/301/CO_Emergency.c **** #endif /* (CO_CONFIG_EM) & CO_CONFIG_EM_PRODUCER */
 208:../CANopen/stack/301/CO_Emergency.c **** 
 209:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_HISTORY
 210:../CANopen/stack/301/CO_Emergency.c **** /*
 211:../CANopen/stack/301/CO_Emergency.c ****  * Custom functions for read/write OD object _OD_statusBits_, optional
 212:../CANopen/stack/301/CO_Emergency.c ****  *
 213:../CANopen/stack/301/CO_Emergency.c ****  * For more information see file CO_ODinterface.h, OD_IO_t.
 214:../CANopen/stack/301/CO_Emergency.c ****  */
 215:../CANopen/stack/301/CO_Emergency.c **** static ODR_t OD_read_1003(OD_stream_t *stream, void *buf,
 216:../CANopen/stack/301/CO_Emergency.c ****                           OD_size_t count, OD_size_t *countRead)
 217:../CANopen/stack/301/CO_Emergency.c **** {
 427              	 .loc 3 217 0
 428              	 .cfi_startproc
 429              	 
 430              	 
 431 0000 80B5     	 push {r7,lr}
 432              	.LCFI39:
 433              	 .cfi_def_cfa_offset 8
 434              	 .cfi_offset 7,-8
 435              	 .cfi_offset 14,-4
 436 0002 86B0     	 sub sp,sp,#24
 437              	.LCFI40:
 438              	 .cfi_def_cfa_offset 32
 439 0004 00AF     	 add r7,sp,#0
 440              	.LCFI41:
 441              	 .cfi_def_cfa_register 7
 442 0006 F860     	 str r0,[r7,#12]
 443 0008 B960     	 str r1,[r7,#8]
 444 000a 7A60     	 str r2,[r7,#4]
 445 000c 3B60     	 str r3,[r7]
 218:../CANopen/stack/301/CO_Emergency.c ****     if (stream == NULL || buf == NULL || countRead == NULL
 446              	 .loc 3 218 0
 447 000e FB68     	 ldr r3,[r7,#12]
 448 0010 002B     	 cmp r3,#0
 449 0012 0FD0     	 beq .L23
 450              	 .loc 3 218 0 is_stmt 0 discriminator 1
 451 0014 BB68     	 ldr r3,[r7,#8]
 452 0016 002B     	 cmp r3,#0
 453 0018 0CD0     	 beq .L23
 454              	 .loc 3 218 0 discriminator 2
 455 001a 3B68     	 ldr r3,[r7]
 456 001c 002B     	 cmp r3,#0
 457 001e 09D0     	 beq .L23
 219:../CANopen/stack/301/CO_Emergency.c ****         || (count < 4 && stream->subIndex > 0) || count < 1
 458              	 .loc 3 219 0 is_stmt 1
 459 0020 7B68     	 ldr r3,[r7,#4]
 460 0022 032B     	 cmp r3,#3
 461 0024 03D8     	 bhi .L24
 462              	 .loc 3 219 0 is_stmt 0 discriminator 1
 463 0026 FB68     	 ldr r3,[r7,#12]
 464 0028 5B7C     	 ldrb r3,[r3,#17]
 465 002a 002B     	 cmp r3,#0
 466 002c 02D1     	 bne .L23
 467              	.L24:
 468              	 .loc 3 219 0 discriminator 3
 469 002e 7B68     	 ldr r3,[r7,#4]
 470 0030 002B     	 cmp r3,#0
 471 0032 01D1     	 bne .L25
 472              	.L23:
 220:../CANopen/stack/301/CO_Emergency.c ****     ) {
 221:../CANopen/stack/301/CO_Emergency.c ****         return ODR_DEV_INCOMPAT;
 473              	 .loc 3 221 0 is_stmt 1
 474 0034 0923     	 movs r3,#9
 475 0036 4DE0     	 b .L26
 476              	.L25:
 222:../CANopen/stack/301/CO_Emergency.c ****     }
 223:../CANopen/stack/301/CO_Emergency.c **** 
 224:../CANopen/stack/301/CO_Emergency.c ****     CO_EM_t *em = (CO_EM_t *)stream->object;
 477              	 .loc 3 224 0
 478 0038 FB68     	 ldr r3,[r7,#12]
 479 003a 5B68     	 ldr r3,[r3,#4]
 480 003c 3B61     	 str r3,[r7,#16]
 225:../CANopen/stack/301/CO_Emergency.c **** 
 226:../CANopen/stack/301/CO_Emergency.c ****     if (em->fifoSize < 2) {
 481              	 .loc 3 226 0
 482 003e 3B69     	 ldr r3,[r7,#16]
 483 0040 1B7F     	 ldrb r3,[r3,#28]
 484 0042 012B     	 cmp r3,#1
 485 0044 01D8     	 bhi .L27
 227:../CANopen/stack/301/CO_Emergency.c ****         return ODR_DEV_INCOMPAT;
 486              	 .loc 3 227 0
 487 0046 0923     	 movs r3,#9
 488 0048 44E0     	 b .L26
 489              	.L27:
 228:../CANopen/stack/301/CO_Emergency.c ****     }
 229:../CANopen/stack/301/CO_Emergency.c ****     if (stream->subIndex == 0) {
 490              	 .loc 3 229 0
 491 004a FB68     	 ldr r3,[r7,#12]
 492 004c 5B7C     	 ldrb r3,[r3,#17]
 493 004e 002B     	 cmp r3,#0
 494 0050 0BD1     	 bne .L28
 230:../CANopen/stack/301/CO_Emergency.c ****         CO_setUint8(buf, em->fifoCount);
 495              	 .loc 3 230 0
 496 0052 3B69     	 ldr r3,[r7,#16]
 497 0054 93F82030 	 ldrb r3,[r3,#32]
 498 0058 B868     	 ldr r0,[r7,#8]
 499 005a 1946     	 mov r1,r3
 500 005c FFF7FEFF 	 bl CO_setUint8
 231:../CANopen/stack/301/CO_Emergency.c **** 
 232:../CANopen/stack/301/CO_Emergency.c ****         *countRead = sizeof(uint8_t);
 501              	 .loc 3 232 0
 502 0060 3B68     	 ldr r3,[r7]
 503 0062 0122     	 movs r2,#1
 504 0064 1A60     	 str r2,[r3]
 233:../CANopen/stack/301/CO_Emergency.c ****         return ODR_OK;
 505              	 .loc 3 233 0
 506 0066 0023     	 movs r3,#0
 507 0068 34E0     	 b .L26
 508              	.L28:
 234:../CANopen/stack/301/CO_Emergency.c ****     }
 235:../CANopen/stack/301/CO_Emergency.c ****     else if (stream->subIndex <= em->fifoCount) {
 509              	 .loc 3 235 0
 510 006a FB68     	 ldr r3,[r7,#12]
 511 006c 5A7C     	 ldrb r2,[r3,#17]
 512 006e 3B69     	 ldr r3,[r7,#16]
 513 0070 93F82030 	 ldrb r3,[r3,#32]
 514 0074 9A42     	 cmp r2,r3
 515 0076 2CD8     	 bhi .L29
 516              	.LBB2:
 236:../CANopen/stack/301/CO_Emergency.c ****         /* newest error is reported on subIndex 1 and is stored just behind
 237:../CANopen/stack/301/CO_Emergency.c ****          * fifoWrPtr. Get correct index in FIFO buffer. */
 238:../CANopen/stack/301/CO_Emergency.c ****         int16_t index = (int16_t)em->fifoWrPtr - stream->subIndex;
 517              	 .loc 3 238 0
 518 0078 3B69     	 ldr r3,[r7,#16]
 519 007a 5B7F     	 ldrb r3,[r3,#29]
 520 007c 9AB2     	 uxth r2,r3
 521 007e FB68     	 ldr r3,[r7,#12]
 522 0080 5B7C     	 ldrb r3,[r3,#17]
 523 0082 9BB2     	 uxth r3,r3
 524 0084 D31A     	 subs r3,r2,r3
 525 0086 9BB2     	 uxth r3,r3
 526 0088 FB82     	 strh r3,[r7,#22]
 239:../CANopen/stack/301/CO_Emergency.c ****         if (index < 0) {
 527              	 .loc 3 239 0
 528 008a B7F91630 	 ldrsh r3,[r7,#22]
 529 008e 002B     	 cmp r3,#0
 530 0090 07DA     	 bge .L30
 240:../CANopen/stack/301/CO_Emergency.c ****             index += em->fifoSize;
 531              	 .loc 3 240 0
 532 0092 3B69     	 ldr r3,[r7,#16]
 533 0094 1B7F     	 ldrb r3,[r3,#28]
 534 0096 9AB2     	 uxth r2,r3
 535 0098 FB8A     	 ldrh r3,[r7,#22]
 536 009a 1344     	 add r3,r3,r2
 537 009c 9BB2     	 uxth r3,r3
 538 009e FB82     	 strh r3,[r7,#22]
 539 00a0 07E0     	 b .L31
 540              	.L30:
 241:../CANopen/stack/301/CO_Emergency.c ****         }
 242:../CANopen/stack/301/CO_Emergency.c ****         else if (index >= (em->fifoSize)) {
 541              	 .loc 3 242 0
 542 00a2 B7F91630 	 ldrsh r3,[r7,#22]
 543 00a6 3A69     	 ldr r2,[r7,#16]
 544 00a8 127F     	 ldrb r2,[r2,#28]
 545 00aa 9342     	 cmp r3,r2
 546 00ac 01DB     	 blt .L31
 243:../CANopen/stack/301/CO_Emergency.c ****             return ODR_DEV_INCOMPAT;
 547              	 .loc 3 243 0
 548 00ae 0923     	 movs r3,#9
 549 00b0 10E0     	 b .L26
 550              	.L31:
 244:../CANopen/stack/301/CO_Emergency.c ****         }
 245:../CANopen/stack/301/CO_Emergency.c ****         CO_setUint32(buf, em->fifo[index].msg);
 551              	 .loc 3 245 0
 552 00b2 3B69     	 ldr r3,[r7,#16]
 553 00b4 9A69     	 ldr r2,[r3,#24]
 554 00b6 B7F91630 	 ldrsh r3,[r7,#22]
 555 00ba DB00     	 lsls r3,r3,#3
 556 00bc 1344     	 add r3,r3,r2
 557 00be 1B68     	 ldr r3,[r3]
 558 00c0 B868     	 ldr r0,[r7,#8]
 559 00c2 1946     	 mov r1,r3
 560 00c4 FFF7FEFF 	 bl CO_setUint32
 246:../CANopen/stack/301/CO_Emergency.c **** 
 247:../CANopen/stack/301/CO_Emergency.c **** #if (C2000_PORT != 0)
 248:../CANopen/stack/301/CO_Emergency.c ****         *countRead = 4;
 249:../CANopen/stack/301/CO_Emergency.c **** #else
 250:../CANopen/stack/301/CO_Emergency.c ****         *countRead = sizeof(uint32_t);
 561              	 .loc 3 250 0
 562 00c8 3B68     	 ldr r3,[r7]
 563 00ca 0422     	 movs r2,#4
 564 00cc 1A60     	 str r2,[r3]
 251:../CANopen/stack/301/CO_Emergency.c **** #endif
 252:../CANopen/stack/301/CO_Emergency.c ****         return ODR_OK;
 565              	 .loc 3 252 0
 566 00ce 0023     	 movs r3,#0
 567 00d0 00E0     	 b .L26
 568              	.L29:
 569              	.LBE2:
 253:../CANopen/stack/301/CO_Emergency.c ****     }
 254:../CANopen/stack/301/CO_Emergency.c ****     else {
 255:../CANopen/stack/301/CO_Emergency.c ****         return ODR_NO_DATA;
 570              	 .loc 3 255 0
 571 00d2 1923     	 movs r3,#25
 572              	.L26:
 573 00d4 5BB2     	 sxtb r3,r3
 256:../CANopen/stack/301/CO_Emergency.c ****     }
 257:../CANopen/stack/301/CO_Emergency.c **** }
 574              	 .loc 3 257 0
 575 00d6 1846     	 mov r0,r3
 576 00d8 1837     	 adds r7,r7,#24
 577              	.LCFI42:
 578              	 .cfi_def_cfa_offset 8
 579 00da BD46     	 mov sp,r7
 580              	.LCFI43:
 581              	 .cfi_def_cfa_register 13
 582              	 
 583 00dc 80BD     	 pop {r7,pc}
 584              	 .cfi_endproc
 585              	.LFE36:
 587 00de 00BF     	 .section .text.OD_write_1003,"ax",%progbits
 588              	 .align 2
 589              	 .thumb
 590              	 .thumb_func
 592              	OD_write_1003:
 593              	.LFB37:
 258:../CANopen/stack/301/CO_Emergency.c **** 
 259:../CANopen/stack/301/CO_Emergency.c **** static ODR_t OD_write_1003(OD_stream_t *stream, const void *buf,
 260:../CANopen/stack/301/CO_Emergency.c ****                            OD_size_t count, OD_size_t *countWritten)
 261:../CANopen/stack/301/CO_Emergency.c **** {
 594              	 .loc 3 261 0
 595              	 .cfi_startproc
 596              	 
 597              	 
 598 0000 80B5     	 push {r7,lr}
 599              	.LCFI44:
 600              	 .cfi_def_cfa_offset 8
 601              	 .cfi_offset 7,-8
 602              	 .cfi_offset 14,-4
 603 0002 86B0     	 sub sp,sp,#24
 604              	.LCFI45:
 605              	 .cfi_def_cfa_offset 32
 606 0004 00AF     	 add r7,sp,#0
 607              	.LCFI46:
 608              	 .cfi_def_cfa_register 7
 609 0006 F860     	 str r0,[r7,#12]
 610 0008 B960     	 str r1,[r7,#8]
 611 000a 7A60     	 str r2,[r7,#4]
 612 000c 3B60     	 str r3,[r7]
 262:../CANopen/stack/301/CO_Emergency.c ****     if (stream == NULL || stream->subIndex != 0 || buf == NULL || count != 1
 613              	 .loc 3 262 0
 614 000e FB68     	 ldr r3,[r7,#12]
 615 0010 002B     	 cmp r3,#0
 616 0012 0CD0     	 beq .L33
 617              	 .loc 3 262 0 is_stmt 0 discriminator 1
 618 0014 FB68     	 ldr r3,[r7,#12]
 619 0016 5B7C     	 ldrb r3,[r3,#17]
 620 0018 002B     	 cmp r3,#0
 621 001a 08D1     	 bne .L33
 622              	 .loc 3 262 0 discriminator 2
 623 001c BB68     	 ldr r3,[r7,#8]
 624 001e 002B     	 cmp r3,#0
 625 0020 05D0     	 beq .L33
 626              	 .loc 3 262 0 discriminator 3
 627 0022 7B68     	 ldr r3,[r7,#4]
 628 0024 012B     	 cmp r3,#1
 629 0026 02D1     	 bne .L33
 263:../CANopen/stack/301/CO_Emergency.c ****         || countWritten == NULL)
 630              	 .loc 3 263 0 is_stmt 1
 631 0028 3B68     	 ldr r3,[r7]
 632 002a 002B     	 cmp r3,#0
 633 002c 01D1     	 bne .L34
 634              	.L33:
 264:../CANopen/stack/301/CO_Emergency.c ****     {
 265:../CANopen/stack/301/CO_Emergency.c ****         return ODR_DEV_INCOMPAT;
 635              	 .loc 3 265 0
 636 002e 0923     	 movs r3,#9
 637 0030 12E0     	 b .L35
 638              	.L34:
 266:../CANopen/stack/301/CO_Emergency.c ****     }
 267:../CANopen/stack/301/CO_Emergency.c **** 
 268:../CANopen/stack/301/CO_Emergency.c ****     if (CO_getUint8(buf) != 0) {
 639              	 .loc 3 268 0
 640 0032 B868     	 ldr r0,[r7,#8]
 641 0034 FFF7FEFF 	 bl CO_getUint8
 642 0038 0346     	 mov r3,r0
 643 003a 002B     	 cmp r3,#0
 644 003c 01D0     	 beq .L36
 269:../CANopen/stack/301/CO_Emergency.c ****         return ODR_INVALID_VALUE;
 645              	 .loc 3 269 0
 646 003e 0F23     	 movs r3,#15
 647 0040 0AE0     	 b .L35
 648              	.L36:
 270:../CANopen/stack/301/CO_Emergency.c ****     }
 271:../CANopen/stack/301/CO_Emergency.c **** 
 272:../CANopen/stack/301/CO_Emergency.c ****     CO_EM_t *em = (CO_EM_t *)stream->object;
 649              	 .loc 3 272 0
 650 0042 FB68     	 ldr r3,[r7,#12]
 651 0044 5B68     	 ldr r3,[r3,#4]
 652 0046 7B61     	 str r3,[r7,#20]
 273:../CANopen/stack/301/CO_Emergency.c **** 
 274:../CANopen/stack/301/CO_Emergency.c ****     /* clear error history */
 275:../CANopen/stack/301/CO_Emergency.c ****     em->fifoCount = 0;
 653              	 .loc 3 275 0
 654 0048 7B69     	 ldr r3,[r7,#20]
 655 004a 0022     	 movs r2,#0
 656 004c 83F82020 	 strb r2,[r3,#32]
 276:../CANopen/stack/301/CO_Emergency.c **** 
 277:../CANopen/stack/301/CO_Emergency.c ****     *countWritten = sizeof(uint8_t);
 657              	 .loc 3 277 0
 658 0050 3B68     	 ldr r3,[r7]
 659 0052 0122     	 movs r2,#1
 660 0054 1A60     	 str r2,[r3]
 278:../CANopen/stack/301/CO_Emergency.c ****     return ODR_OK;
 661              	 .loc 3 278 0
 662 0056 0023     	 movs r3,#0
 663              	.L35:
 664 0058 5BB2     	 sxtb r3,r3
 279:../CANopen/stack/301/CO_Emergency.c **** }
 665              	 .loc 3 279 0
 666 005a 1846     	 mov r0,r3
 667 005c 1837     	 adds r7,r7,#24
 668              	.LCFI47:
 669              	 .cfi_def_cfa_offset 8
 670 005e BD46     	 mov sp,r7
 671              	.LCFI48:
 672              	 .cfi_def_cfa_register 13
 673              	 
 674 0060 80BD     	 pop {r7,pc}
 675              	 .cfi_endproc
 676              	.LFE37:
 678 0062 00BF     	 .section .text.CO_EM_init,"ax",%progbits
 679              	 .align 2
 680              	 .global CO_EM_init
 681              	 .thumb
 682              	 .thumb_func
 684              	CO_EM_init:
 685              	.LFB38:
 280:../CANopen/stack/301/CO_Emergency.c **** #endif /* (CO_CONFIG_EM) & CO_CONFIG_EM_HISTORY */
 281:../CANopen/stack/301/CO_Emergency.c **** 
 282:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_STATUS_BITS
 283:../CANopen/stack/301/CO_Emergency.c **** /*
 284:../CANopen/stack/301/CO_Emergency.c ****  * Custom functions for read/write OD object _OD_statusBits_, optional
 285:../CANopen/stack/301/CO_Emergency.c ****  *
 286:../CANopen/stack/301/CO_Emergency.c ****  * For more information see file CO_ODinterface.h, OD_IO_t.
 287:../CANopen/stack/301/CO_Emergency.c ****  */
 288:../CANopen/stack/301/CO_Emergency.c **** static ODR_t OD_read_statusBits(OD_stream_t *stream, void *buf,
 289:../CANopen/stack/301/CO_Emergency.c ****                                 OD_size_t count, OD_size_t *countRead)
 290:../CANopen/stack/301/CO_Emergency.c **** {
 291:../CANopen/stack/301/CO_Emergency.c ****     if (stream == NULL || stream->subIndex != 0
 292:../CANopen/stack/301/CO_Emergency.c ****         || buf == NULL || countRead == NULL)
 293:../CANopen/stack/301/CO_Emergency.c ****     {
 294:../CANopen/stack/301/CO_Emergency.c ****         return ODR_DEV_INCOMPAT;
 295:../CANopen/stack/301/CO_Emergency.c ****     }
 296:../CANopen/stack/301/CO_Emergency.c **** 
 297:../CANopen/stack/301/CO_Emergency.c ****     CO_EM_t *em = (CO_EM_t *)stream->object;
 298:../CANopen/stack/301/CO_Emergency.c **** 
 299:../CANopen/stack/301/CO_Emergency.c ****     /* get MAX(errorStatusBitsSize, bufSize, ODsizeIndication) */
 300:../CANopen/stack/301/CO_Emergency.c ****     OD_size_t countReadLocal = CO_CONFIG_EM_ERR_STATUS_BITS_COUNT / 8;
 301:../CANopen/stack/301/CO_Emergency.c ****     if (countReadLocal > count) {
 302:../CANopen/stack/301/CO_Emergency.c ****         countReadLocal = count;
 303:../CANopen/stack/301/CO_Emergency.c ****     }
 304:../CANopen/stack/301/CO_Emergency.c ****     if (stream->dataLength != 0 && countReadLocal > stream->dataLength) {
 305:../CANopen/stack/301/CO_Emergency.c ****         countReadLocal = stream->dataLength;
 306:../CANopen/stack/301/CO_Emergency.c ****     }
 307:../CANopen/stack/301/CO_Emergency.c ****     else {
 308:../CANopen/stack/301/CO_Emergency.c ****         stream->dataLength = countReadLocal;
 309:../CANopen/stack/301/CO_Emergency.c ****     }
 310:../CANopen/stack/301/CO_Emergency.c **** 
 311:../CANopen/stack/301/CO_Emergency.c ****     memcpy (buf, &em->errorStatusBits[0], countReadLocal);
 312:../CANopen/stack/301/CO_Emergency.c **** 
 313:../CANopen/stack/301/CO_Emergency.c ****     *countRead = countReadLocal;
 314:../CANopen/stack/301/CO_Emergency.c ****     return ODR_OK;
 315:../CANopen/stack/301/CO_Emergency.c **** }
 316:../CANopen/stack/301/CO_Emergency.c **** 
 317:../CANopen/stack/301/CO_Emergency.c **** static ODR_t OD_write_statusBits(OD_stream_t *stream, const void *buf,
 318:../CANopen/stack/301/CO_Emergency.c ****                                  OD_size_t count, OD_size_t *countWritten)
 319:../CANopen/stack/301/CO_Emergency.c **** {
 320:../CANopen/stack/301/CO_Emergency.c ****     if (stream == NULL || stream->subIndex != 0
 321:../CANopen/stack/301/CO_Emergency.c ****         || buf == NULL || countWritten == NULL
 322:../CANopen/stack/301/CO_Emergency.c ****     ) {
 323:../CANopen/stack/301/CO_Emergency.c ****         return ODR_DEV_INCOMPAT;
 324:../CANopen/stack/301/CO_Emergency.c ****     }
 325:../CANopen/stack/301/CO_Emergency.c **** 
 326:../CANopen/stack/301/CO_Emergency.c ****     CO_EM_t *em = (CO_EM_t *)stream->object;
 327:../CANopen/stack/301/CO_Emergency.c **** 
 328:../CANopen/stack/301/CO_Emergency.c ****     /* get MAX(errorStatusBitsSize, bufSize, ODsizeIndication) */
 329:../CANopen/stack/301/CO_Emergency.c ****     OD_size_t countWrite = CO_CONFIG_EM_ERR_STATUS_BITS_COUNT / 8;
 330:../CANopen/stack/301/CO_Emergency.c ****     if (countWrite > count) {
 331:../CANopen/stack/301/CO_Emergency.c ****         countWrite = count;
 332:../CANopen/stack/301/CO_Emergency.c ****     }
 333:../CANopen/stack/301/CO_Emergency.c ****     if (stream->dataLength != 0 && countWrite > stream->dataLength) {
 334:../CANopen/stack/301/CO_Emergency.c ****         countWrite = stream->dataLength;
 335:../CANopen/stack/301/CO_Emergency.c ****     }
 336:../CANopen/stack/301/CO_Emergency.c ****     else {
 337:../CANopen/stack/301/CO_Emergency.c ****         stream->dataLength = countWrite;
 338:../CANopen/stack/301/CO_Emergency.c ****     }
 339:../CANopen/stack/301/CO_Emergency.c **** 
 340:../CANopen/stack/301/CO_Emergency.c ****     memcpy (&em->errorStatusBits[0], buf, countWrite);
 341:../CANopen/stack/301/CO_Emergency.c **** 
 342:../CANopen/stack/301/CO_Emergency.c ****     *countWritten = countWrite;
 343:../CANopen/stack/301/CO_Emergency.c ****     return ODR_OK;
 344:../CANopen/stack/301/CO_Emergency.c **** }
 345:../CANopen/stack/301/CO_Emergency.c **** #endif /* (CO_CONFIG_EM) & CO_CONFIG_EM_STATUS_BITS */
 346:../CANopen/stack/301/CO_Emergency.c **** 
 347:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_CONSUMER
 348:../CANopen/stack/301/CO_Emergency.c **** /*
 349:../CANopen/stack/301/CO_Emergency.c ****  * Read received message from CAN module.
 350:../CANopen/stack/301/CO_Emergency.c ****  *
 351:../CANopen/stack/301/CO_Emergency.c ****  * Function will be called (by CAN receive interrupt) every time, when CAN
 352:../CANopen/stack/301/CO_Emergency.c ****  * message with correct identifier will be received. For more information and
 353:../CANopen/stack/301/CO_Emergency.c ****  * description of parameters see file CO_driver.h.
 354:../CANopen/stack/301/CO_Emergency.c ****  */
 355:../CANopen/stack/301/CO_Emergency.c **** static void CO_EM_receive(void *object, void *msg) {
 356:../CANopen/stack/301/CO_Emergency.c ****     CO_EM_t *em = (CO_EM_t*)object;
 357:../CANopen/stack/301/CO_Emergency.c **** 
 358:../CANopen/stack/301/CO_Emergency.c ****     if (em != NULL && em->pFunctSignalRx != NULL) {
 359:../CANopen/stack/301/CO_Emergency.c ****         uint16_t ident = CO_CANrxMsg_readIdent(msg);
 360:../CANopen/stack/301/CO_Emergency.c **** 
 361:../CANopen/stack/301/CO_Emergency.c ****         /* ignore sync messages (necessary if sync object is not used) */
 362:../CANopen/stack/301/CO_Emergency.c ****         if (ident != 0x80) {
 363:../CANopen/stack/301/CO_Emergency.c ****             uint8_t *data = CO_CANrxMsg_readData(msg);
 364:../CANopen/stack/301/CO_Emergency.c ****             uint16_t errorCode;
 365:../CANopen/stack/301/CO_Emergency.c ****             uint32_t infoCode;
 366:../CANopen/stack/301/CO_Emergency.c **** 
 367:../CANopen/stack/301/CO_Emergency.c **** #if (C2000_PORT != 0)
 368:../CANopen/stack/301/CO_Emergency.c ****             errorCode = 0;
 369:../CANopen/stack/301/CO_Emergency.c ****             for(int i = 0; i < 2; i++) {
 370:../CANopen/stack/301/CO_Emergency.c ****                 errorCode += (((uint16_t)(data[i])) & 0x00FF) << (i * 8);
 371:../CANopen/stack/301/CO_Emergency.c ****             }
 372:../CANopen/stack/301/CO_Emergency.c **** #else
 373:../CANopen/stack/301/CO_Emergency.c ****             memcpy(&errorCode, &data[0], sizeof(errorCode));
 374:../CANopen/stack/301/CO_Emergency.c **** #endif
 375:../CANopen/stack/301/CO_Emergency.c **** #if (C2000_PORT != 0)
 376:../CANopen/stack/301/CO_Emergency.c ****             infoCode = 0;
 377:../CANopen/stack/301/CO_Emergency.c ****             for(int i = 0; i < 4; i++) {
 378:../CANopen/stack/301/CO_Emergency.c ****                 infoCode += (((uint32_t)(data[i + 4])) & 0x00FF) << (i * 8);
 379:../CANopen/stack/301/CO_Emergency.c ****             }
 380:../CANopen/stack/301/CO_Emergency.c **** #else
 381:../CANopen/stack/301/CO_Emergency.c ****             memcpy(&infoCode, &data[4], sizeof(infoCode));
 382:../CANopen/stack/301/CO_Emergency.c **** #endif
 383:../CANopen/stack/301/CO_Emergency.c ****             em->pFunctSignalRx(ident,
 384:../CANopen/stack/301/CO_Emergency.c ****                                CO_SWAP_16(errorCode),
 385:../CANopen/stack/301/CO_Emergency.c ****                                data[2],
 386:../CANopen/stack/301/CO_Emergency.c ****                                data[3],
 387:../CANopen/stack/301/CO_Emergency.c ****                                CO_SWAP_32(infoCode));
 388:../CANopen/stack/301/CO_Emergency.c ****         }
 389:../CANopen/stack/301/CO_Emergency.c ****     }
 390:../CANopen/stack/301/CO_Emergency.c **** }
 391:../CANopen/stack/301/CO_Emergency.c **** #endif
 392:../CANopen/stack/301/CO_Emergency.c **** 
 393:../CANopen/stack/301/CO_Emergency.c **** 
 394:../CANopen/stack/301/CO_Emergency.c **** /******************************************************************************/
 395:../CANopen/stack/301/CO_Emergency.c **** CO_ReturnError_t CO_EM_init(CO_EM_t *em,
 396:../CANopen/stack/301/CO_Emergency.c ****                             CO_CANmodule_t *CANdevTx,
 397:../CANopen/stack/301/CO_Emergency.c ****                             const OD_entry_t *OD_1001_errReg,
 398:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & (CO_CONFIG_EM_PRODUCER | CO_CONFIG_EM_HISTORY)
 399:../CANopen/stack/301/CO_Emergency.c ****                             CO_EM_fifo_t *fifo,
 400:../CANopen/stack/301/CO_Emergency.c ****                             uint8_t fifoSize,
 401:../CANopen/stack/301/CO_Emergency.c **** #endif
 402:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_PRODUCER
 403:../CANopen/stack/301/CO_Emergency.c ****                             OD_entry_t *OD_1014_cobIdEm,
 404:../CANopen/stack/301/CO_Emergency.c ****                             uint16_t CANdevTxIdx,
 405:../CANopen/stack/301/CO_Emergency.c ****  #if (CO_CONFIG_EM) & CO_CONFIG_EM_PROD_INHIBIT
 406:../CANopen/stack/301/CO_Emergency.c ****                             OD_entry_t *OD_1015_InhTime,
 407:../CANopen/stack/301/CO_Emergency.c ****  #endif
 408:../CANopen/stack/301/CO_Emergency.c **** #endif
 409:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_HISTORY
 410:../CANopen/stack/301/CO_Emergency.c ****                             OD_entry_t *OD_1003_preDefErr,
 411:../CANopen/stack/301/CO_Emergency.c **** #endif
 412:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_STATUS_BITS
 413:../CANopen/stack/301/CO_Emergency.c ****                             OD_entry_t *OD_statusBits,
 414:../CANopen/stack/301/CO_Emergency.c **** #endif
 415:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_CONSUMER
 416:../CANopen/stack/301/CO_Emergency.c ****                             CO_CANmodule_t *CANdevRx,
 417:../CANopen/stack/301/CO_Emergency.c ****                             uint16_t CANdevRxIdx,
 418:../CANopen/stack/301/CO_Emergency.c **** #endif
 419:../CANopen/stack/301/CO_Emergency.c ****                             const uint8_t nodeId,
 420:../CANopen/stack/301/CO_Emergency.c ****                             uint32_t *errInfo)
 421:../CANopen/stack/301/CO_Emergency.c **** {
 686              	 .loc 3 421 0
 687              	 .cfi_startproc
 688              	 
 689              	 
 690 0000 80B5     	 push {r7,lr}
 691              	.LCFI49:
 692              	 .cfi_def_cfa_offset 8
 693              	 .cfi_offset 7,-8
 694              	 .cfi_offset 14,-4
 695 0002 88B0     	 sub sp,sp,#32
 696              	.LCFI50:
 697              	 .cfi_def_cfa_offset 40
 698 0004 02AF     	 add r7,sp,#8
 699              	.LCFI51:
 700              	 .cfi_def_cfa 7,32
 701 0006 F860     	 str r0,[r7,#12]
 702 0008 B960     	 str r1,[r7,#8]
 703 000a 7A60     	 str r2,[r7,#4]
 704 000c 3B60     	 str r3,[r7]
 422:../CANopen/stack/301/CO_Emergency.c ****     (void) nodeId; /* may be unused */
 423:../CANopen/stack/301/CO_Emergency.c ****     CO_ReturnError_t ret = CO_ERROR_NO;
 705              	 .loc 3 423 0
 706 000e 0023     	 movs r3,#0
 707 0010 FB75     	 strb r3,[r7,#23]
 424:../CANopen/stack/301/CO_Emergency.c ****     ODR_t odRet;
 425:../CANopen/stack/301/CO_Emergency.c **** 
 426:../CANopen/stack/301/CO_Emergency.c ****     /* verify arguments */
 427:../CANopen/stack/301/CO_Emergency.c ****     if (em == NULL || OD_1001_errReg == NULL
 708              	 .loc 3 427 0
 709 0012 FB68     	 ldr r3,[r7,#12]
 710 0014 002B     	 cmp r3,#0
 711 0016 1BD0     	 beq .L38
 712              	 .loc 3 427 0 is_stmt 0 discriminator 1
 713 0018 7B68     	 ldr r3,[r7,#4]
 714 001a 002B     	 cmp r3,#0
 715 001c 18D0     	 beq .L38
 428:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & (CO_CONFIG_EM_PRODUCER | CO_CONFIG_EM_HISTORY)
 429:../CANopen/stack/301/CO_Emergency.c ****         || (fifo == NULL && fifoSize >= 2)
 716              	 .loc 3 429 0 is_stmt 1
 717 001e 3B68     	 ldr r3,[r7]
 718 0020 002B     	 cmp r3,#0
 719 0022 03D1     	 bne .L39
 720              	 .loc 3 429 0 is_stmt 0 discriminator 1
 721 0024 97F82030 	 ldrb r3,[r7,#32]
 722 0028 012B     	 cmp r3,#1
 723 002a 11D8     	 bhi .L38
 724              	.L39:
 430:../CANopen/stack/301/CO_Emergency.c **** #endif
 431:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_PRODUCER
 432:../CANopen/stack/301/CO_Emergency.c ****         || OD_1014_cobIdEm == NULL || CANdevTx == NULL
 725              	 .loc 3 432 0 is_stmt 1
 726 002c 7B6A     	 ldr r3,[r7,#36]
 727 002e 002B     	 cmp r3,#0
 728 0030 0ED0     	 beq .L38
 729              	 .loc 3 432 0 is_stmt 0 discriminator 1
 730 0032 BB68     	 ldr r3,[r7,#8]
 731 0034 002B     	 cmp r3,#0
 732 0036 0BD0     	 beq .L38
 433:../CANopen/stack/301/CO_Emergency.c ****         || nodeId < 1 || nodeId > 127
 733              	 .loc 3 433 0 is_stmt 1
 734 0038 97F83030 	 ldrb r3,[r7,#48]
 735 003c 002B     	 cmp r3,#0
 736 003e 07D0     	 beq .L38
 737              	 .loc 3 433 0 is_stmt 0 discriminator 1
 738 0040 97F83030 	 ldrb r3,[r7,#48]
 739 0044 5BB2     	 sxtb r3,r3
 740 0046 002B     	 cmp r3,#0
 741 0048 02DB     	 blt .L38
 434:../CANopen/stack/301/CO_Emergency.c **** #endif
 435:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_HISTORY
 436:../CANopen/stack/301/CO_Emergency.c ****        || OD_1003_preDefErr == NULL
 742              	 .loc 3 436 0 is_stmt 1
 743 004a FB6A     	 ldr r3,[r7,#44]
 744 004c 002B     	 cmp r3,#0
 745 004e 01D1     	 bne .L40
 746              	.L38:
 437:../CANopen/stack/301/CO_Emergency.c **** #endif
 438:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_CONSUMER
 439:../CANopen/stack/301/CO_Emergency.c ****        || CANdevRx == NULL
 440:../CANopen/stack/301/CO_Emergency.c **** #endif
 441:../CANopen/stack/301/CO_Emergency.c ****     ) {
 442:../CANopen/stack/301/CO_Emergency.c ****         return CO_ERROR_ILLEGAL_ARGUMENT;
 747              	 .loc 3 442 0
 748 0050 FF23     	 movs r3,#255
 749 0052 A3E0     	 b .L50
 750              	.L40:
 443:../CANopen/stack/301/CO_Emergency.c ****     }
 444:../CANopen/stack/301/CO_Emergency.c **** 
 445:../CANopen/stack/301/CO_Emergency.c ****     /* clear the object */
 446:../CANopen/stack/301/CO_Emergency.c ****     memset(em, 0, sizeof(CO_EM_t));
 751              	 .loc 3 446 0
 752 0054 F868     	 ldr r0,[r7,#12]
 753 0056 0021     	 movs r1,#0
 754 0058 5022     	 movs r2,#80
 755 005a FFF7FEFF 	 bl memset
 447:../CANopen/stack/301/CO_Emergency.c **** 
 448:../CANopen/stack/301/CO_Emergency.c ****     /* set object variables */
 449:../CANopen/stack/301/CO_Emergency.c ****     em->CANdevTx = CANdevTx;
 756              	 .loc 3 449 0
 757 005e FB68     	 ldr r3,[r7,#12]
 758 0060 BA68     	 ldr r2,[r7,#8]
 759 0062 5A61     	 str r2,[r3,#20]
 450:../CANopen/stack/301/CO_Emergency.c **** 
 451:../CANopen/stack/301/CO_Emergency.c ****     /* get and verify "Error register" from Object Dictionary */
 452:../CANopen/stack/301/CO_Emergency.c ****     em->errorRegister = OD_getPtr(OD_1001_errReg, 0, sizeof(uint8_t), NULL);
 760              	 .loc 3 452 0
 761 0064 7868     	 ldr r0,[r7,#4]
 762 0066 0021     	 movs r1,#0
 763 0068 0122     	 movs r2,#1
 764 006a 0023     	 movs r3,#0
 765 006c FFF7FEFF 	 bl OD_getPtr
 766 0070 0246     	 mov r2,r0
 767 0072 FB68     	 ldr r3,[r7,#12]
 768 0074 DA60     	 str r2,[r3,#12]
 453:../CANopen/stack/301/CO_Emergency.c ****     if (em->errorRegister == NULL) {
 769              	 .loc 3 453 0
 770 0076 FB68     	 ldr r3,[r7,#12]
 771 0078 DB68     	 ldr r3,[r3,#12]
 772 007a 002B     	 cmp r3,#0
 773 007c 0BD1     	 bne .L42
 454:../CANopen/stack/301/CO_Emergency.c ****         if (errInfo != NULL) *errInfo = OD_getIndex(OD_1001_errReg);
 774              	 .loc 3 454 0
 775 007e 7B6B     	 ldr r3,[r7,#52]
 776 0080 002B     	 cmp r3,#0
 777 0082 06D0     	 beq .L43
 778              	 .loc 3 454 0 is_stmt 0 discriminator 1
 779 0084 7868     	 ldr r0,[r7,#4]
 780 0086 FFF7FEFF 	 bl OD_getIndex
 781 008a 0346     	 mov r3,r0
 782 008c 1A46     	 mov r2,r3
 783 008e 7B6B     	 ldr r3,[r7,#52]
 784 0090 1A60     	 str r2,[r3]
 785              	.L43:
 455:../CANopen/stack/301/CO_Emergency.c ****         return CO_ERROR_OD_PARAMETERS;
 786              	 .loc 3 455 0 is_stmt 1
 787 0092 F423     	 movs r3,#244
 788 0094 82E0     	 b .L50
 789              	.L42:
 456:../CANopen/stack/301/CO_Emergency.c ****     }
 457:../CANopen/stack/301/CO_Emergency.c ****     *em->errorRegister = 0;
 790              	 .loc 3 457 0
 791 0096 FB68     	 ldr r3,[r7,#12]
 792 0098 DB68     	 ldr r3,[r3,#12]
 793 009a 0022     	 movs r2,#0
 794 009c 1A70     	 strb r2,[r3]
 458:../CANopen/stack/301/CO_Emergency.c **** 
 459:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & (CO_CONFIG_EM_PRODUCER | CO_CONFIG_EM_HISTORY)
 460:../CANopen/stack/301/CO_Emergency.c ****     em->fifo = fifo;
 795              	 .loc 3 460 0
 796 009e FB68     	 ldr r3,[r7,#12]
 797 00a0 3A68     	 ldr r2,[r7]
 798 00a2 9A61     	 str r2,[r3,#24]
 461:../CANopen/stack/301/CO_Emergency.c ****     em->fifoSize = fifoSize;
 799              	 .loc 3 461 0
 800 00a4 FB68     	 ldr r3,[r7,#12]
 801 00a6 97F82020 	 ldrb r2,[r7,#32]
 802 00aa 1A77     	 strb r2,[r3,#28]
 462:../CANopen/stack/301/CO_Emergency.c **** #endif
 463:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_PRODUCER
 464:../CANopen/stack/301/CO_Emergency.c ****     /* get initial and verify "COB-ID EMCY" from Object Dictionary */
 465:../CANopen/stack/301/CO_Emergency.c ****     uint32_t COB_IDEmergency32;
 466:../CANopen/stack/301/CO_Emergency.c ****     odRet = OD_get_u32(OD_1014_cobIdEm, 0, &COB_IDEmergency32, true);
 803              	 .loc 3 466 0
 804 00ac 07F11003 	 add r3,r7,#16
 805 00b0 786A     	 ldr r0,[r7,#36]
 806 00b2 0021     	 movs r1,#0
 807 00b4 1A46     	 mov r2,r3
 808 00b6 0123     	 movs r3,#1
 809 00b8 FFF7FEFF 	 bl OD_get_u32
 810 00bc 0346     	 mov r3,r0
 811 00be BB75     	 strb r3,[r7,#22]
 467:../CANopen/stack/301/CO_Emergency.c ****     if (odRet != ODR_OK || (COB_IDEmergency32 & 0x7FFFF800) != 0) {
 812              	 .loc 3 467 0
 813 00c0 97F91630 	 ldrsb r3,[r7,#22]
 814 00c4 002B     	 cmp r3,#0
 815 00c6 04D1     	 bne .L44
 816              	 .loc 3 467 0 is_stmt 0 discriminator 1
 817 00c8 3A69     	 ldr r2,[r7,#16]
 818 00ca 374B     	 ldr r3,.L51
 819 00cc 1340     	 ands r3,r3,r2
 820 00ce 002B     	 cmp r3,#0
 821 00d0 0FD0     	 beq .L45
 822              	.L44:
 468:../CANopen/stack/301/CO_Emergency.c ****         if (errInfo != NULL) *errInfo = OD_getIndex(OD_1014_cobIdEm);
 823              	 .loc 3 468 0 is_stmt 1
 824 00d2 7B6B     	 ldr r3,[r7,#52]
 825 00d4 002B     	 cmp r3,#0
 826 00d6 06D0     	 beq .L46
 827              	 .loc 3 468 0 is_stmt 0 discriminator 1
 828 00d8 786A     	 ldr r0,[r7,#36]
 829 00da FFF7FEFF 	 bl OD_getIndex
 830 00de 0346     	 mov r3,r0
 831 00e0 1A46     	 mov r2,r3
 832 00e2 7B6B     	 ldr r3,[r7,#52]
 833 00e4 1A60     	 str r2,[r3]
 834              	.L46:
 469:../CANopen/stack/301/CO_Emergency.c ****          /* don't break a program, if only value of a parameter is wrong */
 470:../CANopen/stack/301/CO_Emergency.c ****         if (odRet != ODR_OK)
 835              	 .loc 3 470 0 is_stmt 1
 836 00e6 97F91630 	 ldrsb r3,[r7,#22]
 837 00ea 002B     	 cmp r3,#0
 838 00ec 01D0     	 beq .L45
 471:../CANopen/stack/301/CO_Emergency.c ****             return CO_ERROR_OD_PARAMETERS;
 839              	 .loc 3 471 0
 840 00ee F423     	 movs r3,#244
 841 00f0 54E0     	 b .L50
 842              	.L45:
 472:../CANopen/stack/301/CO_Emergency.c ****     }
 473:../CANopen/stack/301/CO_Emergency.c **** 
 474:../CANopen/stack/301/CO_Emergency.c ****  #if (CO_CONFIG_EM) & CO_CONFIG_EM_PROD_CONFIGURABLE
 475:../CANopen/stack/301/CO_Emergency.c ****     uint16_t producerCanId = (uint16_t)(COB_IDEmergency32 & 0x7FF);
 476:../CANopen/stack/301/CO_Emergency.c ****     em->producerEnabled = (COB_IDEmergency32 & 0x80000000) == 0
 477:../CANopen/stack/301/CO_Emergency.c ****                           && producerCanId != 0;
 478:../CANopen/stack/301/CO_Emergency.c **** 
 479:../CANopen/stack/301/CO_Emergency.c ****     em->OD_1014_extension.object = em;
 480:../CANopen/stack/301/CO_Emergency.c ****     em->OD_1014_extension.read = OD_read_1014;
 481:../CANopen/stack/301/CO_Emergency.c ****     em->OD_1014_extension.write = OD_write_1014;
 482:../CANopen/stack/301/CO_Emergency.c ****     odRet = OD_extension_init(OD_1014_cobIdEm, &em->OD_1014_extension);
 483:../CANopen/stack/301/CO_Emergency.c ****     if (odRet != ODR_OK) {
 484:../CANopen/stack/301/CO_Emergency.c ****         if (errInfo != NULL) *errInfo = OD_getIndex(OD_1014_cobIdEm);
 485:../CANopen/stack/301/CO_Emergency.c ****         return CO_ERROR_OD_PARAMETERS;
 486:../CANopen/stack/301/CO_Emergency.c ****     }
 487:../CANopen/stack/301/CO_Emergency.c ****     /* following two variables are used inside OD_read_1014 and OD_write_1014 */
 488:../CANopen/stack/301/CO_Emergency.c ****     em->producerCanId = producerCanId;
 489:../CANopen/stack/301/CO_Emergency.c ****     em->CANdevTxIdx = CANdevTxIdx;
 490:../CANopen/stack/301/CO_Emergency.c ****     /* if default producerCanId is used, then value of CO_CAN_ID_EMERGENCY
 491:../CANopen/stack/301/CO_Emergency.c ****      * (0x80) is stored into non-volatile memory. In that case it is necessary
 492:../CANopen/stack/301/CO_Emergency.c ****      * to add nodeId of this node to the stored value. */
 493:../CANopen/stack/301/CO_Emergency.c ****     if (producerCanId == CO_CAN_ID_EMERGENCY) producerCanId += nodeId;
 494:../CANopen/stack/301/CO_Emergency.c ****  #else
 495:../CANopen/stack/301/CO_Emergency.c ****     uint16_t producerCanId = CO_CAN_ID_EMERGENCY + nodeId;
 843              	 .loc 3 495 0
 844 00f2 97F83030 	 ldrb r3,[r7,#48]
 845 00f6 9BB2     	 uxth r3,r3
 846 00f8 8033     	 adds r3,r3,#128
 847 00fa BB82     	 strh r3,[r7,#20]
 496:../CANopen/stack/301/CO_Emergency.c ****     em->producerEnabled = (COB_IDEmergency32 & 0x80000000) == 0;
 848              	 .loc 3 496 0
 849 00fc 3B69     	 ldr r3,[r7,#16]
 850 00fe DB43     	 mvns r3,r3
 851 0100 DB0F     	 lsrs r3,r3,#31
 852 0102 DBB2     	 uxtb r3,r3
 853 0104 1A46     	 mov r2,r3
 854 0106 FB68     	 ldr r3,[r7,#12]
 855 0108 5A62     	 str r2,[r3,#36]
 497:../CANopen/stack/301/CO_Emergency.c **** 
 498:../CANopen/stack/301/CO_Emergency.c ****     em->OD_1014_extension.object = em;
 856              	 .loc 3 498 0
 857 010a FB68     	 ldr r3,[r7,#12]
 858 010c FA68     	 ldr r2,[r7,#12]
 859 010e 1A63     	 str r2,[r3,#48]
 499:../CANopen/stack/301/CO_Emergency.c ****     em->OD_1014_extension.read = OD_read_1014_default;
 860              	 .loc 3 499 0
 861 0110 FB68     	 ldr r3,[r7,#12]
 862 0112 264A     	 ldr r2,.L51+4
 863 0114 5A63     	 str r2,[r3,#52]
 500:../CANopen/stack/301/CO_Emergency.c ****     em->OD_1014_extension.write = OD_writeOriginal;
 864              	 .loc 3 500 0
 865 0116 FB68     	 ldr r3,[r7,#12]
 866 0118 254A     	 ldr r2,.L51+8
 867 011a 9A63     	 str r2,[r3,#56]
 501:../CANopen/stack/301/CO_Emergency.c ****     odRet = OD_extension_init(OD_1014_cobIdEm, &em->OD_1014_extension);
 868              	 .loc 3 501 0
 869 011c FB68     	 ldr r3,[r7,#12]
 870 011e 3033     	 adds r3,r3,#48
 871 0120 786A     	 ldr r0,[r7,#36]
 872 0122 1946     	 mov r1,r3
 873 0124 FFF7FEFF 	 bl OD_extension_init
 874 0128 0346     	 mov r3,r0
 875 012a BB75     	 strb r3,[r7,#22]
 502:../CANopen/stack/301/CO_Emergency.c ****     if (odRet != ODR_OK) {
 876              	 .loc 3 502 0
 877 012c 97F91630 	 ldrsb r3,[r7,#22]
 878 0130 002B     	 cmp r3,#0
 879 0132 0BD0     	 beq .L47
 503:../CANopen/stack/301/CO_Emergency.c ****         if (errInfo != NULL) *errInfo = OD_getIndex(OD_1014_cobIdEm);
 880              	 .loc 3 503 0
 881 0134 7B6B     	 ldr r3,[r7,#52]
 882 0136 002B     	 cmp r3,#0
 883 0138 06D0     	 beq .L48
 884              	 .loc 3 503 0 is_stmt 0 discriminator 1
 885 013a 786A     	 ldr r0,[r7,#36]
 886 013c FFF7FEFF 	 bl OD_getIndex
 887 0140 0346     	 mov r3,r0
 888 0142 1A46     	 mov r2,r3
 889 0144 7B6B     	 ldr r3,[r7,#52]
 890 0146 1A60     	 str r2,[r3]
 891              	.L48:
 504:../CANopen/stack/301/CO_Emergency.c ****         return CO_ERROR_OD_PARAMETERS;
 892              	 .loc 3 504 0 is_stmt 1
 893 0148 F423     	 movs r3,#244
 894 014a 27E0     	 b .L50
 895              	.L47:
 505:../CANopen/stack/301/CO_Emergency.c ****     }
 506:../CANopen/stack/301/CO_Emergency.c ****  #endif
 507:../CANopen/stack/301/CO_Emergency.c **** 
 508:../CANopen/stack/301/CO_Emergency.c ****     /* configure parameters and emergency message CAN transmission */
 509:../CANopen/stack/301/CO_Emergency.c ****     em->nodeId = nodeId;
 896              	 .loc 3 509 0
 897 014c FB68     	 ldr r3,[r7,#12]
 898 014e 97F83020 	 ldrb r2,[r7,#48]
 899 0152 83F82820 	 strb r2,[r3,#40]
 510:../CANopen/stack/301/CO_Emergency.c **** 
 511:../CANopen/stack/301/CO_Emergency.c ****     em->CANtxBuff = CO_CANtxBufferInit(
 900              	 .loc 3 511 0
 901 0156 398D     	 ldrh r1,[r7,#40]
 902 0158 BA8A     	 ldrh r2,[r7,#20]
 903 015a 0823     	 movs r3,#8
 904 015c 0093     	 str r3,[sp]
 905 015e 0023     	 movs r3,#0
 906 0160 0193     	 str r3,[sp,#4]
 907 0162 B868     	 ldr r0,[r7,#8]
 908 0164 0023     	 movs r3,#0
 909 0166 FFF7FEFF 	 bl CO_CANtxBufferInit
 910 016a 0246     	 mov r2,r0
 911 016c FB68     	 ldr r3,[r7,#12]
 912 016e DA62     	 str r2,[r3,#44]
 512:../CANopen/stack/301/CO_Emergency.c ****             CANdevTx,           /* CAN device */
 513:../CANopen/stack/301/CO_Emergency.c ****             CANdevTxIdx,        /* index of specific buffer inside CAN module */
 514:../CANopen/stack/301/CO_Emergency.c ****             producerCanId,      /* CAN identifier */
 515:../CANopen/stack/301/CO_Emergency.c ****             0,                  /* rtr */
 516:../CANopen/stack/301/CO_Emergency.c ****             8U,                 /* number of data bytes */
 517:../CANopen/stack/301/CO_Emergency.c ****             0);                 /* synchronous message flag bit */
 518:../CANopen/stack/301/CO_Emergency.c **** 
 519:../CANopen/stack/301/CO_Emergency.c ****     if (em->CANtxBuff == NULL) {
 913              	 .loc 3 519 0
 914 0170 FB68     	 ldr r3,[r7,#12]
 915 0172 DB6A     	 ldr r3,[r3,#44]
 916 0174 002B     	 cmp r3,#0
 917 0176 01D1     	 bne .L49
 520:../CANopen/stack/301/CO_Emergency.c ****         return CO_ERROR_ILLEGAL_ARGUMENT;
 918              	 .loc 3 520 0
 919 0178 FF23     	 movs r3,#255
 920 017a 0FE0     	 b .L50
 921              	.L49:
 521:../CANopen/stack/301/CO_Emergency.c ****     }
 522:../CANopen/stack/301/CO_Emergency.c **** 
 523:../CANopen/stack/301/CO_Emergency.c ****  #if (CO_CONFIG_EM) & CO_CONFIG_EM_PROD_INHIBIT
 524:../CANopen/stack/301/CO_Emergency.c ****     /* get and verify optional "Inhibit time EMCY" from Object Dictionary */
 525:../CANopen/stack/301/CO_Emergency.c ****     em->inhibitEmTime_us = 0;
 526:../CANopen/stack/301/CO_Emergency.c ****     em->inhibitEmTimer = 0;
 527:../CANopen/stack/301/CO_Emergency.c ****     uint16_t inhibitTime_100us;
 528:../CANopen/stack/301/CO_Emergency.c ****     odRet = OD_get_u16(OD_1015_InhTime, 0, &inhibitTime_100us, true);
 529:../CANopen/stack/301/CO_Emergency.c ****     if (odRet == ODR_OK) {
 530:../CANopen/stack/301/CO_Emergency.c ****         em->inhibitEmTime_us = (uint32_t)inhibitTime_100us * 100;
 531:../CANopen/stack/301/CO_Emergency.c **** 
 532:../CANopen/stack/301/CO_Emergency.c ****         em->OD_1015_extension.object = em;
 533:../CANopen/stack/301/CO_Emergency.c ****         em->OD_1015_extension.read = OD_readOriginal;
 534:../CANopen/stack/301/CO_Emergency.c ****         em->OD_1015_extension.write = OD_write_1015;
 535:../CANopen/stack/301/CO_Emergency.c ****         OD_extension_init(OD_1015_InhTime, &em->OD_1015_extension);
 536:../CANopen/stack/301/CO_Emergency.c ****     }
 537:../CANopen/stack/301/CO_Emergency.c ****  #endif /* (CO_CONFIG_EM) & CO_CONFIG_EM_PROD_INHIBIT */
 538:../CANopen/stack/301/CO_Emergency.c **** #endif /* (CO_CONFIG_EM) & CO_CONFIG_EM_PRODUCER */
 539:../CANopen/stack/301/CO_Emergency.c **** 
 540:../CANopen/stack/301/CO_Emergency.c **** 
 541:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_HISTORY
 542:../CANopen/stack/301/CO_Emergency.c ****     /* If OD entry available, make access to em->preDefErr */
 543:../CANopen/stack/301/CO_Emergency.c ****     em->OD_1003_extension.object = em;
 922              	 .loc 3 543 0
 923 017c FB68     	 ldr r3,[r7,#12]
 924 017e FA68     	 ldr r2,[r7,#12]
 925 0180 1A64     	 str r2,[r3,#64]
 544:../CANopen/stack/301/CO_Emergency.c ****     em->OD_1003_extension.read = OD_read_1003;
 926              	 .loc 3 544 0
 927 0182 FB68     	 ldr r3,[r7,#12]
 928 0184 0B4A     	 ldr r2,.L51+12
 929 0186 5A64     	 str r2,[r3,#68]
 545:../CANopen/stack/301/CO_Emergency.c ****     em->OD_1003_extension.write = OD_write_1003;
 930              	 .loc 3 545 0
 931 0188 FB68     	 ldr r3,[r7,#12]
 932 018a 0B4A     	 ldr r2,.L51+16
 933 018c 9A64     	 str r2,[r3,#72]
 546:../CANopen/stack/301/CO_Emergency.c ****     OD_extension_init(OD_1003_preDefErr, &em->OD_1003_extension);
 934              	 .loc 3 546 0
 935 018e FB68     	 ldr r3,[r7,#12]
 936 0190 4033     	 adds r3,r3,#64
 937 0192 F86A     	 ldr r0,[r7,#44]
 938 0194 1946     	 mov r1,r3
 939 0196 FFF7FEFF 	 bl OD_extension_init
 547:../CANopen/stack/301/CO_Emergency.c **** #endif /* (CO_CONFIG_EM) & CO_CONFIG_EM_HISTORY */
 548:../CANopen/stack/301/CO_Emergency.c **** 
 549:../CANopen/stack/301/CO_Emergency.c **** 
 550:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_STATUS_BITS
 551:../CANopen/stack/301/CO_Emergency.c ****     /* If OD entry available, make access to em->errorStatusBits */
 552:../CANopen/stack/301/CO_Emergency.c ****     em->OD_statusBits_extension.object = em;
 553:../CANopen/stack/301/CO_Emergency.c ****     em->OD_statusBits_extension.read = OD_read_statusBits;
 554:../CANopen/stack/301/CO_Emergency.c ****     em->OD_statusBits_extension.write = OD_write_statusBits;
 555:../CANopen/stack/301/CO_Emergency.c ****     OD_extension_init(OD_statusBits, &em->OD_statusBits_extension);
 556:../CANopen/stack/301/CO_Emergency.c **** #endif /* (CO_CONFIG_EM) & CO_CONFIG_EM_STATUS_BITS */
 557:../CANopen/stack/301/CO_Emergency.c **** 
 558:../CANopen/stack/301/CO_Emergency.c **** 
 559:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_CONSUMER
 560:../CANopen/stack/301/CO_Emergency.c ****     em->pFunctSignalRx = NULL;
 561:../CANopen/stack/301/CO_Emergency.c ****     /* configure SDO server CAN reception */
 562:../CANopen/stack/301/CO_Emergency.c ****     ret = CO_CANrxBufferInit(
 563:../CANopen/stack/301/CO_Emergency.c ****         CANdevRx,               /* CAN device */
 564:../CANopen/stack/301/CO_Emergency.c ****         CANdevRxIdx,            /* rx buffer index */
 565:../CANopen/stack/301/CO_Emergency.c ****         CO_CAN_ID_EMERGENCY,    /* CAN identifier */
 566:../CANopen/stack/301/CO_Emergency.c ****         0x780,                  /* mask */
 567:../CANopen/stack/301/CO_Emergency.c ****         0,                      /* rtr */
 568:../CANopen/stack/301/CO_Emergency.c ****         (void*)em,              /* object passed to receive function */
 569:../CANopen/stack/301/CO_Emergency.c ****         CO_EM_receive);         /* this function will process received message*/
 570:../CANopen/stack/301/CO_Emergency.c **** #endif /* (CO_CONFIG_EM) & CO_CONFIG_EM_CONSUMER */
 571:../CANopen/stack/301/CO_Emergency.c **** 
 572:../CANopen/stack/301/CO_Emergency.c ****     return ret;
 940              	 .loc 3 572 0
 941 019a FB7D     	 ldrb r3,[r7,#23]
 942              	.L50:
 943 019c 5BB2     	 sxtb r3,r3
 573:../CANopen/stack/301/CO_Emergency.c **** }
 944              	 .loc 3 573 0 discriminator 1
 945 019e 1846     	 mov r0,r3
 946 01a0 1837     	 adds r7,r7,#24
 947              	.LCFI52:
 948              	 .cfi_def_cfa_offset 8
 949 01a2 BD46     	 mov sp,r7
 950              	.LCFI53:
 951              	 .cfi_def_cfa_register 13
 952              	 
 953 01a4 80BD     	 pop {r7,pc}
 954              	.L52:
 955 01a6 00BF     	 .align 2
 956              	.L51:
 957 01a8 00F8FF7F 	 .word 2147481600
 958 01ac 00000000 	 .word OD_read_1014_default
 959 01b0 00000000 	 .word OD_writeOriginal
 960 01b4 00000000 	 .word OD_read_1003
 961 01b8 00000000 	 .word OD_write_1003
 962              	 .cfi_endproc
 963              	.LFE38:
 965              	 .section .text.CO_EM_process,"ax",%progbits
 966              	 .align 2
 967              	 .global CO_EM_process
 968              	 .thumb
 969              	 .thumb_func
 971              	CO_EM_process:
 972              	.LFB39:
 574:../CANopen/stack/301/CO_Emergency.c **** 
 575:../CANopen/stack/301/CO_Emergency.c **** 
 576:../CANopen/stack/301/CO_Emergency.c **** /******************************************************************************/
 577:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_CONSUMER
 578:../CANopen/stack/301/CO_Emergency.c **** void CO_EM_initCallbackRx(CO_EM_t *em,
 579:../CANopen/stack/301/CO_Emergency.c ****                           void (*pFunctSignalRx)(const uint16_t ident,
 580:../CANopen/stack/301/CO_Emergency.c ****                                                  const uint16_t errorCode,
 581:../CANopen/stack/301/CO_Emergency.c ****                                                  const uint8_t errorRegister,
 582:../CANopen/stack/301/CO_Emergency.c ****                                                  const uint8_t errorBit,
 583:../CANopen/stack/301/CO_Emergency.c ****                                                  const uint32_t infoCode))
 584:../CANopen/stack/301/CO_Emergency.c **** {
 585:../CANopen/stack/301/CO_Emergency.c ****     if (em != NULL) {
 586:../CANopen/stack/301/CO_Emergency.c ****         em->pFunctSignalRx = pFunctSignalRx;
 587:../CANopen/stack/301/CO_Emergency.c ****     }
 588:../CANopen/stack/301/CO_Emergency.c **** }
 589:../CANopen/stack/301/CO_Emergency.c **** #endif
 590:../CANopen/stack/301/CO_Emergency.c **** 
 591:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_FLAG_CALLBACK_PRE
 592:../CANopen/stack/301/CO_Emergency.c **** void CO_EM_initCallbackPre(CO_EM_t *em,
 593:../CANopen/stack/301/CO_Emergency.c ****                            void *object,
 594:../CANopen/stack/301/CO_Emergency.c ****                            void (*pFunctSignal)(void *object))
 595:../CANopen/stack/301/CO_Emergency.c **** {
 596:../CANopen/stack/301/CO_Emergency.c ****     if (em != NULL) {
 597:../CANopen/stack/301/CO_Emergency.c ****         em->functSignalObjectPre = object;
 598:../CANopen/stack/301/CO_Emergency.c ****         em->pFunctSignalPre = pFunctSignal;
 599:../CANopen/stack/301/CO_Emergency.c ****     }
 600:../CANopen/stack/301/CO_Emergency.c **** }
 601:../CANopen/stack/301/CO_Emergency.c **** #endif
 602:../CANopen/stack/301/CO_Emergency.c **** 
 603:../CANopen/stack/301/CO_Emergency.c **** 
 604:../CANopen/stack/301/CO_Emergency.c **** /******************************************************************************/
 605:../CANopen/stack/301/CO_Emergency.c **** void CO_EM_process(CO_EM_t *em,
 606:../CANopen/stack/301/CO_Emergency.c ****                    bool_t NMTisPreOrOperational,
 607:../CANopen/stack/301/CO_Emergency.c ****                    uint32_t timeDifference_us,
 608:../CANopen/stack/301/CO_Emergency.c ****                    uint32_t *timerNext_us)
 609:../CANopen/stack/301/CO_Emergency.c **** {
 973              	 .loc 3 609 0
 974              	 .cfi_startproc
 975              	 
 976              	 
 977 0000 80B5     	 push {r7,lr}
 978              	.LCFI54:
 979              	 .cfi_def_cfa_offset 8
 980              	 .cfi_offset 7,-8
 981              	 .cfi_offset 14,-4
 982 0002 88B0     	 sub sp,sp,#32
 983              	.LCFI55:
 984              	 .cfi_def_cfa_offset 40
 985 0004 02AF     	 add r7,sp,#8
 986              	.LCFI56:
 987              	 .cfi_def_cfa 7,32
 988 0006 F860     	 str r0,[r7,#12]
 989 0008 B960     	 str r1,[r7,#8]
 990 000a 7A60     	 str r2,[r7,#4]
 991 000c 3B60     	 str r3,[r7]
 610:../CANopen/stack/301/CO_Emergency.c ****     (void)timerNext_us; /* may be unused */
 611:../CANopen/stack/301/CO_Emergency.c **** 
 612:../CANopen/stack/301/CO_Emergency.c ****     /* verify errors from driver */
 613:../CANopen/stack/301/CO_Emergency.c ****     uint16_t CANerrSt = em->CANdevTx->CANerrorStatus;
 992              	 .loc 3 613 0
 993 000e FB68     	 ldr r3,[r7,#12]
 994 0010 5B69     	 ldr r3,[r3,#20]
 995 0012 5B8A     	 ldrh r3,[r3,#18]
 996 0014 BB82     	 strh r3,[r7,#20]
 614:../CANopen/stack/301/CO_Emergency.c ****     if (CANerrSt != em->CANerrorStatusOld) {
 997              	 .loc 3 614 0
 998 0016 FB68     	 ldr r3,[r7,#12]
 999 0018 1B8A     	 ldrh r3,[r3,#16]
 1000 001a BA8A     	 ldrh r2,[r7,#20]
 1001 001c 9A42     	 cmp r2,r3
 1002 001e 00F0A980 	 beq .L54
 1003              	.LBB3:
 615:../CANopen/stack/301/CO_Emergency.c ****         uint16_t CANerrStChanged = CANerrSt ^ em->CANerrorStatusOld;
 1004              	 .loc 3 615 0
 1005 0022 FB68     	 ldr r3,[r7,#12]
 1006 0024 1A8A     	 ldrh r2,[r3,#16]
 1007 0026 BB8A     	 ldrh r3,[r7,#20]
 1008 0028 5340     	 eors r3,r3,r2
 1009 002a 7B82     	 strh r3,[r7,#18]
 616:../CANopen/stack/301/CO_Emergency.c ****         em->CANerrorStatusOld = CANerrSt;
 1010              	 .loc 3 616 0
 1011 002c FB68     	 ldr r3,[r7,#12]
 1012 002e BA8A     	 ldrh r2,[r7,#20]
 1013 0030 1A82     	 strh r2,[r3,#16]
 617:../CANopen/stack/301/CO_Emergency.c **** 
 618:../CANopen/stack/301/CO_Emergency.c ****         if (CANerrStChanged & (CO_CAN_ERRTX_WARNING | CO_CAN_ERRRX_WARNING))
 1014              	 .loc 3 618 0
 1015 0032 7A8A     	 ldrh r2,[r7,#18]
 1016 0034 40F20113 	 movw r3,#257
 1017 0038 1340     	 ands r3,r3,r2
 1018 003a 002B     	 cmp r3,#0
 1019 003c 11D0     	 beq .L55
 619:../CANopen/stack/301/CO_Emergency.c ****             CO_error(em,
 620:../CANopen/stack/301/CO_Emergency.c ****                 (CANerrSt & (CO_CAN_ERRTX_WARNING | CO_CAN_ERRRX_WARNING)) != 0,
 1020              	 .loc 3 620 0
 1021 003e BA8A     	 ldrh r2,[r7,#20]
 1022 0040 40F20113 	 movw r3,#257
 1023 0044 1340     	 ands r3,r3,r2
 619:../CANopen/stack/301/CO_Emergency.c ****             CO_error(em,
 1024              	 .loc 3 619 0
 1025 0046 002B     	 cmp r3,#0
 1026 0048 14BF     	 ite ne
 1027 004a 0123     	 movne r3,#1
 1028 004c 0023     	 moveq r3,#0
 1029 004e DBB2     	 uxtb r3,r3
 1030 0050 1A46     	 mov r2,r3
 1031 0052 0023     	 movs r3,#0
 1032 0054 0093     	 str r3,[sp]
 1033 0056 F868     	 ldr r0,[r7,#12]
 1034 0058 1146     	 mov r1,r2
 1035 005a 0122     	 movs r2,#1
 1036 005c 0023     	 movs r3,#0
 1037 005e FFF7FEFF 	 bl CO_error
 1038              	.L55:
 621:../CANopen/stack/301/CO_Emergency.c ****                 CO_EM_CAN_BUS_WARNING, CO_EMC_NO_ERROR, 0);
 622:../CANopen/stack/301/CO_Emergency.c **** 
 623:../CANopen/stack/301/CO_Emergency.c ****         if (CANerrStChanged & CO_CAN_ERRTX_PASSIVE)
 1039              	 .loc 3 623 0
 1040 0062 7B8A     	 ldrh r3,[r7,#18]
 1041 0064 03F00203 	 and r3,r3,#2
 1042 0068 002B     	 cmp r3,#0
 1043 006a 11D0     	 beq .L56
 624:../CANopen/stack/301/CO_Emergency.c ****             CO_error(em, (CANerrSt & CO_CAN_ERRTX_PASSIVE) != 0,
 1044              	 .loc 3 624 0
 1045 006c BB8A     	 ldrh r3,[r7,#20]
 1046 006e 03F00203 	 and r3,r3,#2
 1047 0072 002B     	 cmp r3,#0
 1048 0074 14BF     	 ite ne
 1049 0076 0123     	 movne r3,#1
 1050 0078 0023     	 moveq r3,#0
 1051 007a DBB2     	 uxtb r3,r3
 1052 007c 1A46     	 mov r2,r3
 1053 007e 0023     	 movs r3,#0
 1054 0080 0093     	 str r3,[sp]
 1055 0082 F868     	 ldr r0,[r7,#12]
 1056 0084 1146     	 mov r1,r2
 1057 0086 0722     	 movs r2,#7
 1058 0088 48F22013 	 movw r3,#33056
 1059 008c FFF7FEFF 	 bl CO_error
 1060              	.L56:
 625:../CANopen/stack/301/CO_Emergency.c ****                      CO_EM_CAN_TX_BUS_PASSIVE, CO_EMC_CAN_PASSIVE, 0);
 626:../CANopen/stack/301/CO_Emergency.c **** 
 627:../CANopen/stack/301/CO_Emergency.c ****         if (CANerrStChanged & CO_CAN_ERRTX_BUS_OFF)
 1061              	 .loc 3 627 0
 1062 0090 7B8A     	 ldrh r3,[r7,#18]
 1063 0092 03F00403 	 and r3,r3,#4
 1064 0096 002B     	 cmp r3,#0
 1065 0098 11D0     	 beq .L57
 628:../CANopen/stack/301/CO_Emergency.c ****             CO_error(em, (CANerrSt & CO_CAN_ERRTX_BUS_OFF) != 0,
 1066              	 .loc 3 628 0
 1067 009a BB8A     	 ldrh r3,[r7,#20]
 1068 009c 03F00403 	 and r3,r3,#4
 1069 00a0 002B     	 cmp r3,#0
 1070 00a2 14BF     	 ite ne
 1071 00a4 0123     	 movne r3,#1
 1072 00a6 0023     	 moveq r3,#0
 1073 00a8 DBB2     	 uxtb r3,r3
 1074 00aa 1A46     	 mov r2,r3
 1075 00ac 0023     	 movs r3,#0
 1076 00ae 0093     	 str r3,[sp]
 1077 00b0 F868     	 ldr r0,[r7,#12]
 1078 00b2 1146     	 mov r1,r2
 1079 00b4 1222     	 movs r2,#18
 1080 00b6 48F24013 	 movw r3,#33088
 1081 00ba FFF7FEFF 	 bl CO_error
 1082              	.L57:
 629:../CANopen/stack/301/CO_Emergency.c ****                      CO_EM_CAN_TX_BUS_OFF, CO_EMC_BUS_OFF_RECOVERED, 0);
 630:../CANopen/stack/301/CO_Emergency.c **** 
 631:../CANopen/stack/301/CO_Emergency.c ****         if (CANerrStChanged & CO_CAN_ERRTX_OVERFLOW)
 1083              	 .loc 3 631 0
 1084 00be 7B8A     	 ldrh r3,[r7,#18]
 1085 00c0 03F00803 	 and r3,r3,#8
 1086 00c4 002B     	 cmp r3,#0
 1087 00c6 11D0     	 beq .L58
 632:../CANopen/stack/301/CO_Emergency.c ****             CO_error(em, (CANerrSt & CO_CAN_ERRTX_OVERFLOW) != 0,
 1088              	 .loc 3 632 0
 1089 00c8 BB8A     	 ldrh r3,[r7,#20]
 1090 00ca 03F00803 	 and r3,r3,#8
 1091 00ce 002B     	 cmp r3,#0
 1092 00d0 14BF     	 ite ne
 1093 00d2 0123     	 movne r3,#1
 1094 00d4 0023     	 moveq r3,#0
 1095 00d6 DBB2     	 uxtb r3,r3
 1096 00d8 1A46     	 mov r2,r3
 1097 00da 0023     	 movs r3,#0
 1098 00dc 0093     	 str r3,[sp]
 1099 00de F868     	 ldr r0,[r7,#12]
 1100 00e0 1146     	 mov r1,r2
 1101 00e2 1422     	 movs r2,#20
 1102 00e4 48F21013 	 movw r3,#33040
 1103 00e8 FFF7FEFF 	 bl CO_error
 1104              	.L58:
 633:../CANopen/stack/301/CO_Emergency.c ****                      CO_EM_CAN_TX_OVERFLOW, CO_EMC_CAN_OVERRUN, 0);
 634:../CANopen/stack/301/CO_Emergency.c **** 
 635:../CANopen/stack/301/CO_Emergency.c ****         if (CANerrStChanged & CO_CAN_ERRTX_PDO_LATE)
 1105              	 .loc 3 635 0
 1106 00ec 7B8A     	 ldrh r3,[r7,#18]
 1107 00ee 03F08003 	 and r3,r3,#128
 1108 00f2 002B     	 cmp r3,#0
 1109 00f4 11D0     	 beq .L59
 636:../CANopen/stack/301/CO_Emergency.c ****             CO_error(em, (CANerrSt & CO_CAN_ERRTX_PDO_LATE) != 0,
 1110              	 .loc 3 636 0
 1111 00f6 BB8A     	 ldrh r3,[r7,#20]
 1112 00f8 03F08003 	 and r3,r3,#128
 1113 00fc 002B     	 cmp r3,#0
 1114 00fe 14BF     	 ite ne
 1115 0100 0123     	 movne r3,#1
 1116 0102 0023     	 moveq r3,#0
 1117 0104 DBB2     	 uxtb r3,r3
 1118 0106 1A46     	 mov r2,r3
 1119 0108 0023     	 movs r3,#0
 1120 010a 0093     	 str r3,[sp]
 1121 010c F868     	 ldr r0,[r7,#12]
 1122 010e 1146     	 mov r1,r2
 1123 0110 1522     	 movs r2,#21
 1124 0112 4FF40143 	 mov r3,#33024
 1125 0116 FFF7FEFF 	 bl CO_error
 1126              	.L59:
 637:../CANopen/stack/301/CO_Emergency.c ****                      CO_EM_TPDO_OUTSIDE_WINDOW, CO_EMC_COMMUNICATION, 0);
 638:../CANopen/stack/301/CO_Emergency.c **** 
 639:../CANopen/stack/301/CO_Emergency.c ****         if (CANerrStChanged & CO_CAN_ERRRX_PASSIVE)
 1127              	 .loc 3 639 0
 1128 011a 7B8A     	 ldrh r3,[r7,#18]
 1129 011c 03F40073 	 and r3,r3,#512
 1130 0120 002B     	 cmp r3,#0
 1131 0122 11D0     	 beq .L60
 640:../CANopen/stack/301/CO_Emergency.c ****             CO_error(em, (CANerrSt & CO_CAN_ERRRX_PASSIVE) != 0,
 1132              	 .loc 3 640 0
 1133 0124 BB8A     	 ldrh r3,[r7,#20]
 1134 0126 03F40073 	 and r3,r3,#512
 1135 012a 002B     	 cmp r3,#0
 1136 012c 14BF     	 ite ne
 1137 012e 0123     	 movne r3,#1
 1138 0130 0023     	 moveq r3,#0
 1139 0132 DBB2     	 uxtb r3,r3
 1140 0134 1A46     	 mov r2,r3
 1141 0136 0023     	 movs r3,#0
 1142 0138 0093     	 str r3,[sp]
 1143 013a F868     	 ldr r0,[r7,#12]
 1144 013c 1146     	 mov r1,r2
 1145 013e 0622     	 movs r2,#6
 1146 0140 48F22013 	 movw r3,#33056
 1147 0144 FFF7FEFF 	 bl CO_error
 1148              	.L60:
 641:../CANopen/stack/301/CO_Emergency.c ****                      CO_EM_CAN_RX_BUS_PASSIVE, CO_EMC_CAN_PASSIVE, 0);
 642:../CANopen/stack/301/CO_Emergency.c **** 
 643:../CANopen/stack/301/CO_Emergency.c ****         if (CANerrStChanged & CO_CAN_ERRRX_OVERFLOW)
 1149              	 .loc 3 643 0
 1150 0148 7B8A     	 ldrh r3,[r7,#18]
 1151 014a 03F40063 	 and r3,r3,#2048
 1152 014e 002B     	 cmp r3,#0
 1153 0150 10D0     	 beq .L54
 644:../CANopen/stack/301/CO_Emergency.c ****             CO_error(em, (CANerrSt & CO_CAN_ERRRX_OVERFLOW) != 0,
 1154              	 .loc 3 644 0
 1155 0152 BB8A     	 ldrh r3,[r7,#20]
 1156 0154 03F40063 	 and r3,r3,#2048
 1157 0158 002B     	 cmp r3,#0
 1158 015a 14BF     	 ite ne
 1159 015c 0123     	 movne r3,#1
 1160 015e 0023     	 moveq r3,#0
 1161 0160 DBB2     	 uxtb r3,r3
 1162 0162 1A46     	 mov r2,r3
 1163 0164 0023     	 movs r3,#0
 1164 0166 0093     	 str r3,[sp]
 1165 0168 F868     	 ldr r0,[r7,#12]
 1166 016a 1146     	 mov r1,r2
 1167 016c 1322     	 movs r2,#19
 1168 016e 1323     	 movs r3,#19
 1169 0170 FFF7FEFF 	 bl CO_error
 1170              	.L54:
 1171              	.LBE3:
 645:../CANopen/stack/301/CO_Emergency.c ****                      CO_EM_CAN_RXB_OVERFLOW, CO_EM_CAN_RXB_OVERFLOW, 0);
 646:../CANopen/stack/301/CO_Emergency.c ****     }
 647:../CANopen/stack/301/CO_Emergency.c **** 
 648:../CANopen/stack/301/CO_Emergency.c ****     /* calculate Error register */
 649:../CANopen/stack/301/CO_Emergency.c ****     uint8_t errorRegister = 0U;
 1172              	 .loc 3 649 0
 1173 0174 0023     	 movs r3,#0
 1174 0176 FB75     	 strb r3,[r7,#23]
 650:../CANopen/stack/301/CO_Emergency.c ****     if (CO_CONFIG_ERR_CONDITION_GENERIC)
 1175              	 .loc 3 650 0
 1176 0178 FB68     	 ldr r3,[r7,#12]
 1177 017a 5B79     	 ldrb r3,[r3,#5]
 1178 017c 002B     	 cmp r3,#0
 1179 017e 03D0     	 beq .L61
 651:../CANopen/stack/301/CO_Emergency.c ****         errorRegister |= CO_ERR_REG_GENERIC_ERR;
 1180              	 .loc 3 651 0
 1181 0180 FB7D     	 ldrb r3,[r7,#23]
 1182 0182 43F00103 	 orr r3,r3,#1
 1183 0186 FB75     	 strb r3,[r7,#23]
 1184              	.L61:
 652:../CANopen/stack/301/CO_Emergency.c **** #ifdef CO_CONFIG_ERR_CONDITION_CURRENT
 653:../CANopen/stack/301/CO_Emergency.c ****     if (CO_CONFIG_ERR_CONDITION_CURRENT)
 654:../CANopen/stack/301/CO_Emergency.c ****         errorRegister |= CO_ERR_REG_CURRENT;
 655:../CANopen/stack/301/CO_Emergency.c **** #endif
 656:../CANopen/stack/301/CO_Emergency.c **** #ifdef CO_CONFIG_ERR_CONDITION_VOLTAGE
 657:../CANopen/stack/301/CO_Emergency.c ****     if (CO_CONFIG_ERR_CONDITION_VOLTAGE)
 658:../CANopen/stack/301/CO_Emergency.c ****         errorRegister |= CO_ERR_REG_VOLTAGE;
 659:../CANopen/stack/301/CO_Emergency.c **** #endif
 660:../CANopen/stack/301/CO_Emergency.c **** #ifdef CO_CONFIG_ERR_CONDITION_TEMPERATURE
 661:../CANopen/stack/301/CO_Emergency.c ****     if (CO_CONFIG_ERR_CONDITION_TEMPERATURE)
 662:../CANopen/stack/301/CO_Emergency.c ****         errorRegister |= CO_ERR_REG_TEMPERATURE;
 663:../CANopen/stack/301/CO_Emergency.c **** #endif
 664:../CANopen/stack/301/CO_Emergency.c ****     if (CO_CONFIG_ERR_CONDITION_COMMUNICATION)
 1185              	 .loc 3 664 0
 1186 0188 FB68     	 ldr r3,[r7,#12]
 1187 018a 9B78     	 ldrb r3,[r3,#2]
 1188 018c 002B     	 cmp r3,#0
 1189 018e 03D1     	 bne .L62
 1190              	 .loc 3 664 0 is_stmt 0 discriminator 1
 1191 0190 FB68     	 ldr r3,[r7,#12]
 1192 0192 DB78     	 ldrb r3,[r3,#3]
 1193 0194 002B     	 cmp r3,#0
 1194 0196 03D0     	 beq .L63
 1195              	.L62:
 665:../CANopen/stack/301/CO_Emergency.c ****         errorRegister |= CO_ERR_REG_COMMUNICATION;
 1196              	 .loc 3 665 0 is_stmt 1
 1197 0198 FB7D     	 ldrb r3,[r7,#23]
 1198 019a 43F01003 	 orr r3,r3,#16
 1199 019e FB75     	 strb r3,[r7,#23]
 1200              	.L63:
 666:../CANopen/stack/301/CO_Emergency.c **** #ifdef CO_CONFIG_ERR_CONDITION_DEV_PROFILE
 667:../CANopen/stack/301/CO_Emergency.c ****     if (CO_CONFIG_ERR_CONDITION_DEV_PROFILE)
 668:../CANopen/stack/301/CO_Emergency.c ****         errorRegister |= CO_ERR_REG_DEV_PROFILE;
 669:../CANopen/stack/301/CO_Emergency.c **** #endif
 670:../CANopen/stack/301/CO_Emergency.c ****     if (CO_CONFIG_ERR_CONDITION_MANUFACTURER)
 1201              	 .loc 3 670 0
 1202 01a0 FB68     	 ldr r3,[r7,#12]
 1203 01a2 1B7A     	 ldrb r3,[r3,#8]
 1204 01a4 002B     	 cmp r3,#0
 1205 01a6 03D1     	 bne .L64
 1206              	 .loc 3 670 0 is_stmt 0 discriminator 1
 1207 01a8 FB68     	 ldr r3,[r7,#12]
 1208 01aa 5B7A     	 ldrb r3,[r3,#9]
 1209 01ac 002B     	 cmp r3,#0
 1210 01ae 03D0     	 beq .L65
 1211              	.L64:
 671:../CANopen/stack/301/CO_Emergency.c ****         errorRegister |= CO_ERR_REG_MANUFACTURER;
 1212              	 .loc 3 671 0 is_stmt 1
 1213 01b0 FB7D     	 ldrb r3,[r7,#23]
 1214 01b2 63F07F03 	 orn r3,r3,#127
 1215 01b6 FB75     	 strb r3,[r7,#23]
 1216              	.L65:
 672:../CANopen/stack/301/CO_Emergency.c ****     *em->errorRegister = errorRegister;
 1217              	 .loc 3 672 0
 1218 01b8 FB68     	 ldr r3,[r7,#12]
 1219 01ba DB68     	 ldr r3,[r3,#12]
 1220 01bc FA7D     	 ldrb r2,[r7,#23]
 1221 01be 1A70     	 strb r2,[r3]
 673:../CANopen/stack/301/CO_Emergency.c **** 
 674:../CANopen/stack/301/CO_Emergency.c ****     if (!NMTisPreOrOperational) {
 1222              	 .loc 3 674 0
 1223 01c0 BB68     	 ldr r3,[r7,#8]
 1224 01c2 002B     	 cmp r3,#0
 1225 01c4 00D1     	 bne .L66
 675:../CANopen/stack/301/CO_Emergency.c ****         return;
 1226              	 .loc 3 675 0
 1227 01c6 68E0     	 b .L53
 1228              	.L66:
 676:../CANopen/stack/301/CO_Emergency.c ****     }
 677:../CANopen/stack/301/CO_Emergency.c **** 
 678:../CANopen/stack/301/CO_Emergency.c ****     /* post-process Emergency message in fifo buffer. */
 679:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_EM_PRODUCER
 680:../CANopen/stack/301/CO_Emergency.c ****     if (em->fifoSize >= 2) {
 1229              	 .loc 3 680 0
 1230 01c8 FB68     	 ldr r3,[r7,#12]
 1231 01ca 1B7F     	 ldrb r3,[r3,#28]
 1232 01cc 012B     	 cmp r3,#1
 1233 01ce 63D9     	 bls .L68
 1234              	.LBB4:
 681:../CANopen/stack/301/CO_Emergency.c ****         uint8_t fifoPpPtr = em->fifoPpPtr;
 1235              	 .loc 3 681 0
 1236 01d0 FB68     	 ldr r3,[r7,#12]
 1237 01d2 9B7F     	 ldrb r3,[r3,#30]
 1238 01d4 7B74     	 strb r3,[r7,#17]
 682:../CANopen/stack/301/CO_Emergency.c **** 
 683:../CANopen/stack/301/CO_Emergency.c ****  #if (CO_CONFIG_EM) & CO_CONFIG_EM_PROD_INHIBIT
 684:../CANopen/stack/301/CO_Emergency.c ****         if (em->inhibitEmTimer < em->inhibitEmTime_us) {
 685:../CANopen/stack/301/CO_Emergency.c ****             em->inhibitEmTimer += timeDifference_us;
 686:../CANopen/stack/301/CO_Emergency.c ****         }
 687:../CANopen/stack/301/CO_Emergency.c **** 
 688:../CANopen/stack/301/CO_Emergency.c ****         if (fifoPpPtr != em->fifoWrPtr && !em->CANtxBuff->bufferFull
 689:../CANopen/stack/301/CO_Emergency.c ****             && em->inhibitEmTimer >= em->inhibitEmTime_us
 690:../CANopen/stack/301/CO_Emergency.c ****         ) {
 691:../CANopen/stack/301/CO_Emergency.c ****             em->inhibitEmTimer = 0;
 692:../CANopen/stack/301/CO_Emergency.c ****  #else
 693:../CANopen/stack/301/CO_Emergency.c ****         if (fifoPpPtr != em->fifoWrPtr && !em->CANtxBuff->bufferFull) {
 1239              	 .loc 3 693 0
 1240 01d6 FB68     	 ldr r3,[r7,#12]
 1241 01d8 5B7F     	 ldrb r3,[r3,#29]
 1242 01da 7A7C     	 ldrb r2,[r7,#17]
 1243 01dc 9A42     	 cmp r2,r3
 1244 01de 5BD0     	 beq .L68
 1245              	 .loc 3 693 0 is_stmt 0 discriminator 1
 1246 01e0 FB68     	 ldr r3,[r7,#12]
 1247 01e2 DB6A     	 ldr r3,[r3,#44]
 1248 01e4 1B69     	 ldr r3,[r3,#16]
 1249 01e6 002B     	 cmp r3,#0
 1250 01e8 56D1     	 bne .L68
 694:../CANopen/stack/301/CO_Emergency.c ****  #endif
 695:../CANopen/stack/301/CO_Emergency.c ****             /* add error register to emergency message */
 696:../CANopen/stack/301/CO_Emergency.c ****             em->fifo[fifoPpPtr].msg |= (uint32_t) errorRegister << 16;
 1251              	 .loc 3 696 0 is_stmt 1
 1252 01ea FB68     	 ldr r3,[r7,#12]
 1253 01ec 9A69     	 ldr r2,[r3,#24]
 1254 01ee 7B7C     	 ldrb r3,[r7,#17]
 1255 01f0 DB00     	 lsls r3,r3,#3
 1256 01f2 1344     	 add r3,r3,r2
 1257 01f4 FA68     	 ldr r2,[r7,#12]
 1258 01f6 9169     	 ldr r1,[r2,#24]
 1259 01f8 7A7C     	 ldrb r2,[r7,#17]
 1260 01fa D200     	 lsls r2,r2,#3
 1261 01fc 0A44     	 add r2,r2,r1
 1262 01fe 1168     	 ldr r1,[r2]
 1263 0200 FA7D     	 ldrb r2,[r7,#23]
 1264 0202 1204     	 lsls r2,r2,#16
 1265 0204 0A43     	 orrs r2,r2,r1
 1266 0206 1A60     	 str r2,[r3]
 697:../CANopen/stack/301/CO_Emergency.c **** 
 698:../CANopen/stack/301/CO_Emergency.c ****             /* send emergency message */
 699:../CANopen/stack/301/CO_Emergency.c ****             memcpy(em->CANtxBuff->data, &em->fifo[fifoPpPtr].msg,
 1267              	 .loc 3 699 0
 1268 0208 FB68     	 ldr r3,[r7,#12]
 1269 020a DB6A     	 ldr r3,[r3,#44]
 1270 020c 591D     	 adds r1,r3,#5
 1271 020e FB68     	 ldr r3,[r7,#12]
 1272 0210 9A69     	 ldr r2,[r3,#24]
 1273 0212 7B7C     	 ldrb r3,[r7,#17]
 1274 0214 DB00     	 lsls r3,r3,#3
 1275 0216 1344     	 add r3,r3,r2
 1276 0218 0846     	 mov r0,r1
 1277 021a 1946     	 mov r1,r3
 1278 021c 0822     	 movs r2,#8
 1279 021e FFF7FEFF 	 bl memcpy
 700:../CANopen/stack/301/CO_Emergency.c ****                 sizeof(em->CANtxBuff->data));
 701:../CANopen/stack/301/CO_Emergency.c ****             CO_CANsend(em->CANdevTx, em->CANtxBuff);
 1280              	 .loc 3 701 0
 1281 0222 FB68     	 ldr r3,[r7,#12]
 1282 0224 5A69     	 ldr r2,[r3,#20]
 1283 0226 FB68     	 ldr r3,[r7,#12]
 1284 0228 DB6A     	 ldr r3,[r3,#44]
 1285 022a 1046     	 mov r0,r2
 1286 022c 1946     	 mov r1,r3
 1287 022e FFF7FEFF 	 bl CO_CANsend
 702:../CANopen/stack/301/CO_Emergency.c **** 
 703:../CANopen/stack/301/CO_Emergency.c ****  #if (CO_CONFIG_EM) & CO_CONFIG_EM_CONSUMER
 704:../CANopen/stack/301/CO_Emergency.c ****             /* report also own emergency messages */
 705:../CANopen/stack/301/CO_Emergency.c ****             if (em->pFunctSignalRx != NULL) {
 706:../CANopen/stack/301/CO_Emergency.c ****                 uint32_t errMsg = em->fifo[fifoPpPtr].msg;
 707:../CANopen/stack/301/CO_Emergency.c ****                 em->pFunctSignalRx(0,
 708:../CANopen/stack/301/CO_Emergency.c ****                                    CO_SWAP_16((uint16_t) errMsg),
 709:../CANopen/stack/301/CO_Emergency.c ****                                    errorRegister,
 710:../CANopen/stack/301/CO_Emergency.c ****                                    (uint8_t) (errMsg >> 24),
 711:../CANopen/stack/301/CO_Emergency.c ****                                    CO_SWAP_32(em->fifo[fifoPpPtr].info));
 712:../CANopen/stack/301/CO_Emergency.c ****             }
 713:../CANopen/stack/301/CO_Emergency.c ****  #endif
 714:../CANopen/stack/301/CO_Emergency.c **** 
 715:../CANopen/stack/301/CO_Emergency.c ****             /* increment pointer */
 716:../CANopen/stack/301/CO_Emergency.c ****             em->fifoPpPtr = (++fifoPpPtr < em->fifoSize) ? fifoPpPtr : 0;
 1288              	 .loc 3 716 0
 1289 0232 7B7C     	 ldrb r3,[r7,#17]
 1290 0234 0133     	 adds r3,r3,#1
 1291 0236 7B74     	 strb r3,[r7,#17]
 1292 0238 FB68     	 ldr r3,[r7,#12]
 1293 023a 1B7F     	 ldrb r3,[r3,#28]
 1294 023c 7A7C     	 ldrb r2,[r7,#17]
 1295 023e 9A42     	 cmp r2,r3
 1296 0240 01D2     	 bcs .L69
 1297              	 .loc 3 716 0 is_stmt 0 discriminator 1
 1298 0242 7A7C     	 ldrb r2,[r7,#17]
 1299 0244 00E0     	 b .L70
 1300              	.L69:
 1301              	 .loc 3 716 0 discriminator 2
 1302 0246 0022     	 movs r2,#0
 1303              	.L70:
 1304              	 .loc 3 716 0 discriminator 4
 1305 0248 FB68     	 ldr r3,[r7,#12]
 1306 024a 9A77     	 strb r2,[r3,#30]
 717:../CANopen/stack/301/CO_Emergency.c **** 
 718:../CANopen/stack/301/CO_Emergency.c ****             /* verify message buffer overflow. Clear error condition if all
 719:../CANopen/stack/301/CO_Emergency.c ****              * messages from fifo buffer are processed */
 720:../CANopen/stack/301/CO_Emergency.c ****             if (em->fifoOverflow == 1) {
 1307              	 .loc 3 720 0 is_stmt 1 discriminator 4
 1308 024c FB68     	 ldr r3,[r7,#12]
 1309 024e DB7F     	 ldrb r3,[r3,#31]
 1310 0250 012B     	 cmp r3,#1
 1311 0252 0CD1     	 bne .L71
 721:../CANopen/stack/301/CO_Emergency.c ****                 em->fifoOverflow = 2;
 1312              	 .loc 3 721 0
 1313 0254 FB68     	 ldr r3,[r7,#12]
 1314 0256 0222     	 movs r2,#2
 1315 0258 DA77     	 strb r2,[r3,#31]
 722:../CANopen/stack/301/CO_Emergency.c ****                 CO_errorReport(em, CO_EM_EMERGENCY_BUFFER_FULL,
 1316              	 .loc 3 722 0
 1317 025a 0023     	 movs r3,#0
 1318 025c 0093     	 str r3,[sp]
 1319 025e F868     	 ldr r0,[r7,#12]
 1320 0260 0121     	 movs r1,#1
 1321 0262 2022     	 movs r2,#32
 1322 0264 4FF48053 	 mov r3,#4096
 1323 0268 FFF7FEFF 	 bl CO_error
 1324 026c 14E0     	 b .L68
 1325              	.L71:
 723:../CANopen/stack/301/CO_Emergency.c ****                                CO_EMC_GENERIC, 0);
 724:../CANopen/stack/301/CO_Emergency.c ****             }
 725:../CANopen/stack/301/CO_Emergency.c ****             else if (em->fifoOverflow == 2 && em->fifoPpPtr == em->fifoWrPtr) {
 1326              	 .loc 3 725 0
 1327 026e FB68     	 ldr r3,[r7,#12]
 1328 0270 DB7F     	 ldrb r3,[r3,#31]
 1329 0272 022B     	 cmp r3,#2
 1330 0274 10D1     	 bne .L68
 1331              	 .loc 3 725 0 is_stmt 0 discriminator 1
 1332 0276 FB68     	 ldr r3,[r7,#12]
 1333 0278 9A7F     	 ldrb r2,[r3,#30]
 1334 027a FB68     	 ldr r3,[r7,#12]
 1335 027c 5B7F     	 ldrb r3,[r3,#29]
 1336 027e 9A42     	 cmp r2,r3
 1337 0280 0AD1     	 bne .L68
 726:../CANopen/stack/301/CO_Emergency.c ****                 em->fifoOverflow = 0;
 1338              	 .loc 3 726 0 is_stmt 1
 1339 0282 FB68     	 ldr r3,[r7,#12]
 1340 0284 0022     	 movs r2,#0
 1341 0286 DA77     	 strb r2,[r3,#31]
 727:../CANopen/stack/301/CO_Emergency.c ****                 CO_errorReset(em, CO_EM_EMERGENCY_BUFFER_FULL, 0);
 1342              	 .loc 3 727 0
 1343 0288 0023     	 movs r3,#0
 1344 028a 0093     	 str r3,[sp]
 1345 028c F868     	 ldr r0,[r7,#12]
 1346 028e 0021     	 movs r1,#0
 1347 0290 2022     	 movs r2,#32
 1348 0292 0023     	 movs r3,#0
 1349 0294 FFF7FEFF 	 bl CO_error
 1350              	.L68:
 1351              	.LBE4:
 728:../CANopen/stack/301/CO_Emergency.c ****             }
 729:../CANopen/stack/301/CO_Emergency.c ****         }
 730:../CANopen/stack/301/CO_Emergency.c ****  #if (CO_CONFIG_EM) & CO_CONFIG_EM_PROD_INHIBIT
 731:../CANopen/stack/301/CO_Emergency.c ****   #if (CO_CONFIG_EM) & CO_CONFIG_FLAG_TIMERNEXT
 732:../CANopen/stack/301/CO_Emergency.c ****         else if (timerNext_us != NULL
 733:../CANopen/stack/301/CO_Emergency.c ****                  && em->inhibitEmTimer < em->inhibitEmTime_us)
 734:../CANopen/stack/301/CO_Emergency.c ****         {
 735:../CANopen/stack/301/CO_Emergency.c ****             /* check again after inhibit time elapsed */
 736:../CANopen/stack/301/CO_Emergency.c ****             uint32_t diff = em->inhibitEmTime_us - em->inhibitEmTimer;
 737:../CANopen/stack/301/CO_Emergency.c ****             if (*timerNext_us > diff) {
 738:../CANopen/stack/301/CO_Emergency.c ****                 *timerNext_us = diff;
 739:../CANopen/stack/301/CO_Emergency.c ****             }
 740:../CANopen/stack/301/CO_Emergency.c ****         }
 741:../CANopen/stack/301/CO_Emergency.c ****   #endif
 742:../CANopen/stack/301/CO_Emergency.c ****  #endif
 743:../CANopen/stack/301/CO_Emergency.c ****     }
 744:../CANopen/stack/301/CO_Emergency.c **** #elif (CO_CONFIG_EM) & CO_CONFIG_EM_HISTORY
 745:../CANopen/stack/301/CO_Emergency.c ****     if (em->fifoSize >= 2) {
 746:../CANopen/stack/301/CO_Emergency.c ****         uint8_t fifoPpPtr = em->fifoPpPtr;
 747:../CANopen/stack/301/CO_Emergency.c ****         while (fifoPpPtr != em->fifoWrPtr) {
 748:../CANopen/stack/301/CO_Emergency.c ****             /* add error register to emergency message and increment pointers */
 749:../CANopen/stack/301/CO_Emergency.c ****             em->fifo[fifoPpPtr].msg |= (uint32_t) errorRegister << 16;
 750:../CANopen/stack/301/CO_Emergency.c **** 
 751:../CANopen/stack/301/CO_Emergency.c ****             if (++fifoPpPtr >= em->fifoSize) {
 752:../CANopen/stack/301/CO_Emergency.c ****                 fifoPpPtr = 0;
 753:../CANopen/stack/301/CO_Emergency.c ****             }
 754:../CANopen/stack/301/CO_Emergency.c ****         }
 755:../CANopen/stack/301/CO_Emergency.c ****         em->fifoPpPtr = fifoPpPtr;
 756:../CANopen/stack/301/CO_Emergency.c ****     }
 757:../CANopen/stack/301/CO_Emergency.c **** #endif /* (CO_CONFIG_EM) & CO_CONFIG_EM_PRODUCER, #elif CO_CONFIG_EM_HISTORY */
 758:../CANopen/stack/301/CO_Emergency.c **** 
 759:../CANopen/stack/301/CO_Emergency.c ****     return;
 1352              	 .loc 3 759 0 discriminator 2
 1353 0298 00BF     	 nop
 1354              	.L53:
 760:../CANopen/stack/301/CO_Emergency.c **** }
 1355              	 .loc 3 760 0
 1356 029a 1837     	 adds r7,r7,#24
 1357              	.LCFI57:
 1358              	 .cfi_def_cfa_offset 8
 1359 029c BD46     	 mov sp,r7
 1360              	.LCFI58:
 1361              	 .cfi_def_cfa_register 13
 1362              	 
 1363 029e 80BD     	 pop {r7,pc}
 1364              	 .cfi_endproc
 1365              	.LFE39:
 1367              	 .section .text.CO_error,"ax",%progbits
 1368              	 .align 2
 1369              	 .global CO_error
 1370              	 .thumb
 1371              	 .thumb_func
 1373              	CO_error:
 1374              	.LFB40:
 761:../CANopen/stack/301/CO_Emergency.c **** 
 762:../CANopen/stack/301/CO_Emergency.c **** 
 763:../CANopen/stack/301/CO_Emergency.c **** /******************************************************************************/
 764:../CANopen/stack/301/CO_Emergency.c **** void CO_error(CO_EM_t *em, bool_t setError, const uint8_t errorBit,
 765:../CANopen/stack/301/CO_Emergency.c ****               uint16_t errorCode, uint32_t infoCode)
 766:../CANopen/stack/301/CO_Emergency.c **** {
 1375              	 .loc 3 766 0
 1376              	 .cfi_startproc
 1377              	 
 1378              	 
 1379              	 
 1380 0000 80B4     	 push {r7}
 1381              	.LCFI59:
 1382              	 .cfi_def_cfa_offset 4
 1383              	 .cfi_offset 7,-4
 1384 0002 8BB0     	 sub sp,sp,#44
 1385              	.LCFI60:
 1386              	 .cfi_def_cfa_offset 48
 1387 0004 00AF     	 add r7,sp,#0
 1388              	.LCFI61:
 1389              	 .cfi_def_cfa_register 7
 1390 0006 F860     	 str r0,[r7,#12]
 1391 0008 B960     	 str r1,[r7,#8]
 1392 000a 1146     	 mov r1,r2
 1393 000c 1A46     	 mov r2,r3
 1394 000e 0B46     	 mov r3,r1
 1395 0010 FB71     	 strb r3,[r7,#7]
 1396 0012 1346     	 mov r3,r2
 1397 0014 BB80     	 strh r3,[r7,#4]
 767:../CANopen/stack/301/CO_Emergency.c ****     if (em == NULL) return;
 1398              	 .loc 3 767 0
 1399 0016 FB68     	 ldr r3,[r7,#12]
 1400 0018 002B     	 cmp r3,#0
 1401 001a 00D1     	 bne .L73
 1402 001c 92E0     	 b .L72
 1403              	.L73:
 768:../CANopen/stack/301/CO_Emergency.c **** 
 769:../CANopen/stack/301/CO_Emergency.c ****     uint8_t index = errorBit >> 3;
 1404              	 .loc 3 769 0
 1405 001e FB79     	 ldrb r3,[r7,#7]
 1406 0020 DB08     	 lsrs r3,r3,#3
 1407 0022 87F82730 	 strb r3,[r7,#39]
 770:../CANopen/stack/301/CO_Emergency.c ****     uint8_t bitmask = 1 << (errorBit & 0x7);
 1408              	 .loc 3 770 0
 1409 0026 FB79     	 ldrb r3,[r7,#7]
 1410 0028 03F00703 	 and r3,r3,#7
 1411 002c 0122     	 movs r2,#1
 1412 002e 02FA03F3 	 lsl r3,r2,r3
 1413 0032 87F82630 	 strb r3,[r7,#38]
 771:../CANopen/stack/301/CO_Emergency.c **** 
 772:../CANopen/stack/301/CO_Emergency.c ****     /* if unsupported errorBit, change to 'CO_EM_WRONG_ERROR_REPORT' */
 773:../CANopen/stack/301/CO_Emergency.c ****     if (index >= (CO_CONFIG_EM_ERR_STATUS_BITS_COUNT / 8)) {
 1414              	 .loc 3 773 0
 1415 0036 97F82730 	 ldrb r3,[r7,#39]
 1416 003a 092B     	 cmp r3,#9
 1417 003c 0AD9     	 bls .L75
 774:../CANopen/stack/301/CO_Emergency.c ****         index = CO_EM_WRONG_ERROR_REPORT >> 3;
 1418              	 .loc 3 774 0
 1419 003e 0523     	 movs r3,#5
 1420 0040 87F82730 	 strb r3,[r7,#39]
 775:../CANopen/stack/301/CO_Emergency.c ****         bitmask = 1 << (CO_EM_WRONG_ERROR_REPORT & 0x7);
 1421              	 .loc 3 775 0
 1422 0044 0123     	 movs r3,#1
 1423 0046 87F82630 	 strb r3,[r7,#38]
 776:../CANopen/stack/301/CO_Emergency.c ****         errorCode = CO_EMC_SOFTWARE_INTERNAL;
 1424              	 .loc 3 776 0
 1425 004a 4FF4C243 	 mov r3,#24832
 1426 004e BB80     	 strh r3,[r7,#4]
 777:../CANopen/stack/301/CO_Emergency.c ****         infoCode = errorBit;
 1427              	 .loc 3 777 0
 1428 0050 FB79     	 ldrb r3,[r7,#7]
 1429 0052 3B63     	 str r3,[r7,#48]
 1430              	.L75:
 778:../CANopen/stack/301/CO_Emergency.c ****     }
 779:../CANopen/stack/301/CO_Emergency.c **** 
 780:../CANopen/stack/301/CO_Emergency.c ****     uint8_t *errorStatusBits = &em->errorStatusBits[index];
 1431              	 .loc 3 780 0
 1432 0054 97F82730 	 ldrb r3,[r7,#39]
 1433 0058 FA68     	 ldr r2,[r7,#12]
 1434 005a 1344     	 add r3,r3,r2
 1435 005c 3B62     	 str r3,[r7,#32]
 781:../CANopen/stack/301/CO_Emergency.c ****     uint8_t errorStatusBitMasked = *errorStatusBits & bitmask;
 1436              	 .loc 3 781 0
 1437 005e 3B6A     	 ldr r3,[r7,#32]
 1438 0060 1A78     	 ldrb r2,[r3]
 1439 0062 97F82630 	 ldrb r3,[r7,#38]
 1440 0066 1340     	 ands r3,r3,r2
 1441 0068 FB77     	 strb r3,[r7,#31]
 782:../CANopen/stack/301/CO_Emergency.c **** 
 783:../CANopen/stack/301/CO_Emergency.c ****     /* If error is already set (or unset), return without further actions,
 784:../CANopen/stack/301/CO_Emergency.c ****      * otherwise toggle bit and continue with error indication. */
 785:../CANopen/stack/301/CO_Emergency.c ****     if (setError) {
 1442              	 .loc 3 785 0
 1443 006a BB68     	 ldr r3,[r7,#8]
 1444 006c 002B     	 cmp r3,#0
 1445 006e 03D0     	 beq .L76
 786:../CANopen/stack/301/CO_Emergency.c ****         if (errorStatusBitMasked != 0) {
 1446              	 .loc 3 786 0
 1447 0070 FB7F     	 ldrb r3,[r7,#31]
 1448 0072 002B     	 cmp r3,#0
 1449 0074 06D0     	 beq .L77
 787:../CANopen/stack/301/CO_Emergency.c ****             return;
 1450              	 .loc 3 787 0 discriminator 2
 1451 0076 65E0     	 b .L72
 1452              	.L76:
 788:../CANopen/stack/301/CO_Emergency.c ****         }
 789:../CANopen/stack/301/CO_Emergency.c ****     }
 790:../CANopen/stack/301/CO_Emergency.c ****     else {
 791:../CANopen/stack/301/CO_Emergency.c ****         if (errorStatusBitMasked == 0) {
 1453              	 .loc 3 791 0
 1454 0078 FB7F     	 ldrb r3,[r7,#31]
 1455 007a 002B     	 cmp r3,#0
 1456 007c 00D1     	 bne .L78
 792:../CANopen/stack/301/CO_Emergency.c ****             return;
 1457              	 .loc 3 792 0 discriminator 3
 1458 007e 61E0     	 b .L72
 1459              	.L78:
 793:../CANopen/stack/301/CO_Emergency.c ****         }
 794:../CANopen/stack/301/CO_Emergency.c ****         errorCode = CO_EMC_NO_ERROR;
 1460              	 .loc 3 794 0
 1461 0080 0023     	 movs r3,#0
 1462 0082 BB80     	 strh r3,[r7,#4]
 1463              	.L77:
 795:../CANopen/stack/301/CO_Emergency.c ****     }
 796:../CANopen/stack/301/CO_Emergency.c **** 
 797:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & (CO_CONFIG_EM_PRODUCER | CO_CONFIG_EM_HISTORY)
 798:../CANopen/stack/301/CO_Emergency.c ****     /* prepare emergency message. Error register will be added in post-process*/
 799:../CANopen/stack/301/CO_Emergency.c ****     uint32_t errMsg = (uint32_t)errorBit << 24 | CO_SWAP_16(errorCode);
 1464              	 .loc 3 799 0
 1465 0084 FB79     	 ldrb r3,[r7,#7]
 1466 0086 1A06     	 lsls r2,r3,#24
 1467 0088 BB88     	 ldrh r3,[r7,#4]
 1468 008a 1343     	 orrs r3,r3,r2
 1469 008c BB61     	 str r3,[r7,#24]
 800:../CANopen/stack/301/CO_Emergency.c ****  #if (CO_CONFIG_EM) & CO_CONFIG_EM_PRODUCER
 801:../CANopen/stack/301/CO_Emergency.c ****     uint32_t infoCodeSwapped = CO_SWAP_32(infoCode);
 1470              	 .loc 3 801 0
 1471 008e 3B6B     	 ldr r3,[r7,#48]
 1472 0090 7B61     	 str r3,[r7,#20]
 802:../CANopen/stack/301/CO_Emergency.c ****  #endif
 803:../CANopen/stack/301/CO_Emergency.c **** #endif
 804:../CANopen/stack/301/CO_Emergency.c **** 
 805:../CANopen/stack/301/CO_Emergency.c ****     /* safely write data, and increment pointers */
 806:../CANopen/stack/301/CO_Emergency.c ****     CO_LOCK_EMCY(em->CANdevTx);
 807:../CANopen/stack/301/CO_Emergency.c ****     if (setError) *errorStatusBits |= bitmask;
 1473              	 .loc 3 807 0
 1474 0092 BB68     	 ldr r3,[r7,#8]
 1475 0094 002B     	 cmp r3,#0
 1476 0096 08D0     	 beq .L79
 1477              	 .loc 3 807 0 is_stmt 0 discriminator 1
 1478 0098 3B6A     	 ldr r3,[r7,#32]
 1479 009a 1A78     	 ldrb r2,[r3]
 1480 009c 97F82630 	 ldrb r3,[r7,#38]
 1481 00a0 1343     	 orrs r3,r3,r2
 1482 00a2 DAB2     	 uxtb r2,r3
 1483 00a4 3B6A     	 ldr r3,[r7,#32]
 1484 00a6 1A70     	 strb r2,[r3]
 1485 00a8 0BE0     	 b .L80
 1486              	.L79:
 808:../CANopen/stack/301/CO_Emergency.c ****     else          *errorStatusBits &= ~bitmask;
 1487              	 .loc 3 808 0 is_stmt 1
 1488 00aa 3B6A     	 ldr r3,[r7,#32]
 1489 00ac 1B78     	 ldrb r3,[r3]
 1490 00ae DAB2     	 uxtb r2,r3
 1491 00b0 97F82630 	 ldrb r3,[r7,#38]
 1492 00b4 DB43     	 mvns r3,r3
 1493 00b6 DBB2     	 uxtb r3,r3
 1494 00b8 1340     	 ands r3,r3,r2
 1495 00ba DBB2     	 uxtb r3,r3
 1496 00bc DAB2     	 uxtb r2,r3
 1497 00be 3B6A     	 ldr r3,[r7,#32]
 1498 00c0 1A70     	 strb r2,[r3]
 1499              	.L80:
 809:../CANopen/stack/301/CO_Emergency.c **** 
 810:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & (CO_CONFIG_EM_PRODUCER | CO_CONFIG_EM_HISTORY)
 811:../CANopen/stack/301/CO_Emergency.c ****     if (em->fifoSize >= 2) {
 1500              	 .loc 3 811 0
 1501 00c2 FB68     	 ldr r3,[r7,#12]
 1502 00c4 1B7F     	 ldrb r3,[r3,#28]
 1503 00c6 012B     	 cmp r3,#1
 1504 00c8 3CD9     	 bls .L72
 1505              	.LBB5:
 812:../CANopen/stack/301/CO_Emergency.c ****         uint8_t fifoWrPtr = em->fifoWrPtr;
 1506              	 .loc 3 812 0
 1507 00ca FB68     	 ldr r3,[r7,#12]
 1508 00cc 5B7F     	 ldrb r3,[r3,#29]
 1509 00ce FB74     	 strb r3,[r7,#19]
 813:../CANopen/stack/301/CO_Emergency.c ****         uint8_t fifoWrPtrNext = fifoWrPtr + 1;
 1510              	 .loc 3 813 0
 1511 00d0 FB7C     	 ldrb r3,[r7,#19]
 1512 00d2 0133     	 adds r3,r3,#1
 1513 00d4 87F82530 	 strb r3,[r7,#37]
 814:../CANopen/stack/301/CO_Emergency.c ****         if (fifoWrPtrNext >= em->fifoSize) {
 1514              	 .loc 3 814 0
 1515 00d8 FB68     	 ldr r3,[r7,#12]
 1516 00da 1B7F     	 ldrb r3,[r3,#28]
 1517 00dc 97F82520 	 ldrb r2,[r7,#37]
 1518 00e0 9A42     	 cmp r2,r3
 1519 00e2 02D3     	 bcc .L81
 815:../CANopen/stack/301/CO_Emergency.c ****             fifoWrPtrNext = 0;
 1520              	 .loc 3 815 0
 1521 00e4 0023     	 movs r3,#0
 1522 00e6 87F82530 	 strb r3,[r7,#37]
 1523              	.L81:
 816:../CANopen/stack/301/CO_Emergency.c ****         }
 817:../CANopen/stack/301/CO_Emergency.c **** 
 818:../CANopen/stack/301/CO_Emergency.c ****         if (fifoWrPtrNext == em->fifoPpPtr) {
 1524              	 .loc 3 818 0
 1525 00ea FB68     	 ldr r3,[r7,#12]
 1526 00ec 9B7F     	 ldrb r3,[r3,#30]
 1527 00ee 97F82520 	 ldrb r2,[r7,#37]
 1528 00f2 9A42     	 cmp r2,r3
 1529 00f4 03D1     	 bne .L82
 819:../CANopen/stack/301/CO_Emergency.c ****             em->fifoOverflow = 1;
 1530              	 .loc 3 819 0
 1531 00f6 FB68     	 ldr r3,[r7,#12]
 1532 00f8 0122     	 movs r2,#1
 1533 00fa DA77     	 strb r2,[r3,#31]
 1534 00fc 22E0     	 b .L72
 1535              	.L82:
 820:../CANopen/stack/301/CO_Emergency.c ****         }
 821:../CANopen/stack/301/CO_Emergency.c ****         else {
 822:../CANopen/stack/301/CO_Emergency.c ****             em->fifo[fifoWrPtr].msg = errMsg;
 1536              	 .loc 3 822 0
 1537 00fe FB68     	 ldr r3,[r7,#12]
 1538 0100 9A69     	 ldr r2,[r3,#24]
 1539 0102 FB7C     	 ldrb r3,[r7,#19]
 1540 0104 DB00     	 lsls r3,r3,#3
 1541 0106 1344     	 add r3,r3,r2
 1542 0108 BA69     	 ldr r2,[r7,#24]
 1543 010a 1A60     	 str r2,[r3]
 823:../CANopen/stack/301/CO_Emergency.c ****  #if (CO_CONFIG_EM) & CO_CONFIG_EM_PRODUCER
 824:../CANopen/stack/301/CO_Emergency.c ****             em->fifo[fifoWrPtr].info = infoCodeSwapped;
 1544              	 .loc 3 824 0
 1545 010c FB68     	 ldr r3,[r7,#12]
 1546 010e 9A69     	 ldr r2,[r3,#24]
 1547 0110 FB7C     	 ldrb r3,[r7,#19]
 1548 0112 DB00     	 lsls r3,r3,#3
 1549 0114 1344     	 add r3,r3,r2
 1550 0116 7A69     	 ldr r2,[r7,#20]
 1551 0118 5A60     	 str r2,[r3,#4]
 825:../CANopen/stack/301/CO_Emergency.c ****  #endif
 826:../CANopen/stack/301/CO_Emergency.c ****             em->fifoWrPtr = fifoWrPtrNext;
 1552              	 .loc 3 826 0
 1553 011a FB68     	 ldr r3,[r7,#12]
 1554 011c 97F82520 	 ldrb r2,[r7,#37]
 1555 0120 5A77     	 strb r2,[r3,#29]
 827:../CANopen/stack/301/CO_Emergency.c ****             if (em->fifoCount < (em->fifoSize - 1)) em->fifoCount++;
 1556              	 .loc 3 827 0
 1557 0122 FB68     	 ldr r3,[r7,#12]
 1558 0124 93F82030 	 ldrb r3,[r3,#32]
 1559 0128 1A46     	 mov r2,r3
 1560 012a FB68     	 ldr r3,[r7,#12]
 1561 012c 1B7F     	 ldrb r3,[r3,#28]
 1562 012e 013B     	 subs r3,r3,#1
 1563 0130 9A42     	 cmp r2,r3
 1564 0132 07DA     	 bge .L72
 1565              	 .loc 3 827 0 is_stmt 0 discriminator 1
 1566 0134 FB68     	 ldr r3,[r7,#12]
 1567 0136 93F82030 	 ldrb r3,[r3,#32]
 1568 013a 0133     	 adds r3,r3,#1
 1569 013c DAB2     	 uxtb r2,r3
 1570 013e FB68     	 ldr r3,[r7,#12]
 1571 0140 83F82020 	 strb r2,[r3,#32]
 1572              	.L72:
 1573              	.LBE5:
 828:../CANopen/stack/301/CO_Emergency.c ****         }
 829:../CANopen/stack/301/CO_Emergency.c ****     }
 830:../CANopen/stack/301/CO_Emergency.c **** #endif /* (CO_CONFIG_EM) & (CO_CONFIG_EM_PRODUCER | CO_CONFIG_EM_HISTORY) */
 831:../CANopen/stack/301/CO_Emergency.c **** 
 832:../CANopen/stack/301/CO_Emergency.c ****     CO_UNLOCK_EMCY(em->CANdevTx);
 833:../CANopen/stack/301/CO_Emergency.c **** 
 834:../CANopen/stack/301/CO_Emergency.c **** #if (CO_CONFIG_EM) & CO_CONFIG_FLAG_CALLBACK_PRE
 835:../CANopen/stack/301/CO_Emergency.c ****  #if (CO_CONFIG_EM) & CO_CONFIG_EM_PRODUCER
 836:../CANopen/stack/301/CO_Emergency.c ****     /* Optional signal to RTOS, which can resume task, which handles
 837:../CANopen/stack/301/CO_Emergency.c ****      * CO_EM_process */
 838:../CANopen/stack/301/CO_Emergency.c ****     if (em->pFunctSignalPre != NULL && em->producerEnabled) {
 839:../CANopen/stack/301/CO_Emergency.c ****         em->pFunctSignalPre(em->functSignalObjectPre);
 840:../CANopen/stack/301/CO_Emergency.c ****     }
 841:../CANopen/stack/301/CO_Emergency.c ****  #endif
 842:../CANopen/stack/301/CO_Emergency.c **** #endif
 843:../CANopen/stack/301/CO_Emergency.c **** }
 1574              	 .loc 3 843 0 is_stmt 1
 1575 0144 2C37     	 adds r7,r7,#44
 1576              	.LCFI62:
 1577              	 .cfi_def_cfa_offset 4
 1578 0146 BD46     	 mov sp,r7
 1579              	.LCFI63:
 1580              	 .cfi_def_cfa_register 13
 1581              	 
 1582 0148 5DF8047B 	 ldr r7,[sp],#4
 1583              	.LCFI64:
 1584              	 .cfi_restore 7
 1585              	 .cfi_def_cfa_offset 0
 1586 014c 7047     	 bx lr
 1587              	 .cfi_endproc
 1588              	.LFE40:
 1590 014e 00BF     	 .text
 1591              	.Letext0:
 1592              	 .file 4 "d:\\programs\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 1593              	 .file 5 "d:\\programs\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 1594              	 .file 6 "D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/driver/CO_driver_target.h"
 1595              	 .file 7 "D:/Workspace/Development/my/DAVE/Infineon_CANopen/CANopen/stack/301/CO_Emergency.h"
DEFINED SYMBOLS
                            *ABS*:00000000 CO_Emergency.c
    {standard input}:20     .text.CO_getUint8:00000000 $t
    {standard input}:24     .text.CO_getUint8:00000000 CO_getUint8
    {standard input}:66     .text.CO_setUint8:00000000 $t
    {standard input}:70     .text.CO_setUint8:00000000 CO_setUint8
    {standard input}:113    .text.CO_setUint32:00000000 $t
    {standard input}:117    .text.CO_setUint32:00000000 CO_setUint32
    {standard input}:157    .text.OD_getIndex:00000000 $t
    {standard input}:161    .text.OD_getIndex:00000000 OD_getIndex
    {standard input}:210    .text.OD_extension_init:00000000 $t
    {standard input}:214    .text.OD_extension_init:00000000 OD_extension_init
    {standard input}:267    .text.OD_get_u32:00000000 $t
    {standard input}:271    .text.OD_get_u32:00000000 OD_get_u32
    {standard input}:317    .text.OD_read_1014_default:00000000 $t
    {standard input}:321    .text.OD_read_1014_default:00000000 OD_read_1014_default
    {standard input}:421    .text.OD_read_1003:00000000 $t
    {standard input}:425    .text.OD_read_1003:00000000 OD_read_1003
    {standard input}:588    .text.OD_write_1003:00000000 $t
    {standard input}:592    .text.OD_write_1003:00000000 OD_write_1003
    {standard input}:679    .text.CO_EM_init:00000000 $t
    {standard input}:684    .text.CO_EM_init:00000000 CO_EM_init
    {standard input}:957    .text.CO_EM_init:000001a8 $d
    {standard input}:966    .text.CO_EM_process:00000000 $t
    {standard input}:971    .text.CO_EM_process:00000000 CO_EM_process
    {standard input}:1373   .text.CO_error:00000000 CO_error
    {standard input}:1368   .text.CO_error:00000000 $t
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memmove
OD_get_value
memset
OD_getPtr
CO_CANtxBufferInit
OD_writeOriginal
memcpy
CO_CANsend
